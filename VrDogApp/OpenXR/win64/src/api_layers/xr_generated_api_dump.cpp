// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See api_dump_generator.py for modifications
// ************************************************************

// Copyright (c) 2017-2025 The Khronos Group Inc.
// Copyright (c) 2017-2019 Valve Corporation
// Copyright (c) 2017-2019 LunarG, Inc.
//
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Mark Young <marky@lunarg.com>
//

#include "xr_generated_api_dump.hpp"
#include "xr_generated_dispatch_table.h"
#include "hex_and_handles.h"

#include <cstring>
#include <mutex>
#include <sstream>
#include <iomanip>
#include <unordered_map>


std::unordered_map<XrInstance, XrGeneratedDispatchTable*> g_instance_dispatch_map;
std::mutex g_instance_dispatch_mutex;
std::unordered_map<XrSession, XrGeneratedDispatchTable*> g_session_dispatch_map;
std::mutex g_session_dispatch_mutex;
std::unordered_map<XrSpace, XrGeneratedDispatchTable*> g_space_dispatch_map;
std::mutex g_space_dispatch_mutex;
std::unordered_map<XrAction, XrGeneratedDispatchTable*> g_action_dispatch_map;
std::mutex g_action_dispatch_mutex;
std::unordered_map<XrSwapchain, XrGeneratedDispatchTable*> g_swapchain_dispatch_map;
std::mutex g_swapchain_dispatch_mutex;
std::unordered_map<XrActionSet, XrGeneratedDispatchTable*> g_actionset_dispatch_map;
std::mutex g_actionset_dispatch_mutex;
std::unordered_map<XrDebugUtilsMessengerEXT, XrGeneratedDispatchTable*> g_debugutilsmessengerext_dispatch_map;
std::mutex g_debugutilsmessengerext_dispatch_mutex;
std::unordered_map<XrSpatialAnchorMSFT, XrGeneratedDispatchTable*> g_spatialanchormsft_dispatch_map;
std::mutex g_spatialanchormsft_dispatch_mutex;
std::unordered_map<XrSpatialGraphNodeBindingMSFT, XrGeneratedDispatchTable*> g_spatialgraphnodebindingmsft_dispatch_map;
std::mutex g_spatialgraphnodebindingmsft_dispatch_mutex;
std::unordered_map<XrHandTrackerEXT, XrGeneratedDispatchTable*> g_handtrackerext_dispatch_map;
std::mutex g_handtrackerext_dispatch_mutex;
std::unordered_map<XrBodyTrackerFB, XrGeneratedDispatchTable*> g_bodytrackerfb_dispatch_map;
std::mutex g_bodytrackerfb_dispatch_mutex;
std::unordered_map<XrSceneObserverMSFT, XrGeneratedDispatchTable*> g_sceneobservermsft_dispatch_map;
std::mutex g_sceneobservermsft_dispatch_mutex;
std::unordered_map<XrSceneMSFT, XrGeneratedDispatchTable*> g_scenemsft_dispatch_map;
std::mutex g_scenemsft_dispatch_mutex;
std::unordered_map<XrFacialTrackerHTC, XrGeneratedDispatchTable*> g_facialtrackerhtc_dispatch_map;
std::mutex g_facialtrackerhtc_dispatch_mutex;
std::unordered_map<XrFoveationProfileFB, XrGeneratedDispatchTable*> g_foveationprofilefb_dispatch_map;
std::mutex g_foveationprofilefb_dispatch_mutex;
std::unordered_map<XrTriangleMeshFB, XrGeneratedDispatchTable*> g_trianglemeshfb_dispatch_map;
std::mutex g_trianglemeshfb_dispatch_mutex;
std::unordered_map<XrPassthroughFB, XrGeneratedDispatchTable*> g_passthroughfb_dispatch_map;
std::mutex g_passthroughfb_dispatch_mutex;
std::unordered_map<XrPassthroughLayerFB, XrGeneratedDispatchTable*> g_passthroughlayerfb_dispatch_map;
std::mutex g_passthroughlayerfb_dispatch_mutex;
std::unordered_map<XrGeometryInstanceFB, XrGeneratedDispatchTable*> g_geometryinstancefb_dispatch_map;
std::mutex g_geometryinstancefb_dispatch_mutex;
std::unordered_map<XrMarkerDetectorML, XrGeneratedDispatchTable*> g_markerdetectorml_dispatch_map;
std::mutex g_markerdetectorml_dispatch_mutex;
std::unordered_map<XrExportedLocalizationMapML, XrGeneratedDispatchTable*> g_exportedlocalizationmapml_dispatch_map;
std::mutex g_exportedlocalizationmapml_dispatch_mutex;
std::unordered_map<XrSpatialAnchorsStorageML, XrGeneratedDispatchTable*> g_spatialanchorsstorageml_dispatch_map;
std::mutex g_spatialanchorsstorageml_dispatch_mutex;
std::unordered_map<XrSpatialAnchorStoreConnectionMSFT, XrGeneratedDispatchTable*> g_spatialanchorstoreconnectionmsft_dispatch_map;
std::mutex g_spatialanchorstoreconnectionmsft_dispatch_mutex;
std::unordered_map<XrSpaceUserFB, XrGeneratedDispatchTable*> g_spaceuserfb_dispatch_map;
std::mutex g_spaceuserfb_dispatch_mutex;
std::unordered_map<XrFaceTrackerFB, XrGeneratedDispatchTable*> g_facetrackerfb_dispatch_map;
std::mutex g_facetrackerfb_dispatch_mutex;
std::unordered_map<XrEyeTrackerFB, XrGeneratedDispatchTable*> g_eyetrackerfb_dispatch_map;
std::mutex g_eyetrackerfb_dispatch_mutex;
std::unordered_map<XrVirtualKeyboardMETA, XrGeneratedDispatchTable*> g_virtualkeyboardmeta_dispatch_map;
std::mutex g_virtualkeyboardmeta_dispatch_mutex;
std::unordered_map<XrPassthroughColorLutMETA, XrGeneratedDispatchTable*> g_passthroughcolorlutmeta_dispatch_map;
std::mutex g_passthroughcolorlutmeta_dispatch_mutex;
std::unordered_map<XrFaceTracker2FB, XrGeneratedDispatchTable*> g_facetracker2fb_dispatch_map;
std::mutex g_facetracker2fb_dispatch_mutex;
std::unordered_map<XrEnvironmentDepthProviderMETA, XrGeneratedDispatchTable*> g_environmentdepthprovidermeta_dispatch_map;
std::mutex g_environmentdepthprovidermeta_dispatch_mutex;
std::unordered_map<XrEnvironmentDepthSwapchainMETA, XrGeneratedDispatchTable*> g_environmentdepthswapchainmeta_dispatch_map;
std::mutex g_environmentdepthswapchainmeta_dispatch_mutex;
std::unordered_map<XrPassthroughHTC, XrGeneratedDispatchTable*> g_passthroughhtc_dispatch_map;
std::mutex g_passthroughhtc_dispatch_mutex;
std::unordered_map<XrBodyTrackerHTC, XrGeneratedDispatchTable*> g_bodytrackerhtc_dispatch_map;
std::mutex g_bodytrackerhtc_dispatch_mutex;
std::unordered_map<XrBodyTrackerBD, XrGeneratedDispatchTable*> g_bodytrackerbd_dispatch_map;
std::mutex g_bodytrackerbd_dispatch_mutex;
std::unordered_map<XrSenseDataProviderBD, XrGeneratedDispatchTable*> g_sensedataproviderbd_dispatch_map;
std::mutex g_sensedataproviderbd_dispatch_mutex;
std::unordered_map<XrSenseDataSnapshotBD, XrGeneratedDispatchTable*> g_sensedatasnapshotbd_dispatch_map;
std::mutex g_sensedatasnapshotbd_dispatch_mutex;
std::unordered_map<XrAnchorBD, XrGeneratedDispatchTable*> g_anchorbd_dispatch_map;
std::mutex g_anchorbd_dispatch_mutex;
std::unordered_map<XrPlaneDetectorEXT, XrGeneratedDispatchTable*> g_planedetectorext_dispatch_map;
std::mutex g_planedetectorext_dispatch_mutex;
std::unordered_map<XrWorldMeshDetectorML, XrGeneratedDispatchTable*> g_worldmeshdetectorml_dispatch_map;
std::mutex g_worldmeshdetectorml_dispatch_mutex;
std::unordered_map<XrFacialExpressionClientML, XrGeneratedDispatchTable*> g_facialexpressionclientml_dispatch_map;
std::mutex g_facialexpressionclientml_dispatch_mutex;

// Template function to reduce duplicating the map locking, searching, and deleting.`
template <typename MapType>
void eraseAllTableMapElements(MapType &search_map, std::mutex &mutex, XrGeneratedDispatchTable *search_value) {
    std::unique_lock<std::mutex> lock(mutex);
    for (auto it = search_map.begin(); it != search_map.end();) {
        if (it->second == search_value) {
            search_map.erase(it++);
        } else {
            ++it;
        }
    }
}

// Function used to clean up any residual map values that point to an instance prior to that
// instance being deleted.
void ApiDumpCleanUpMapsForTable(XrGeneratedDispatchTable *table) {
    eraseAllTableMapElements<std::unordered_map<XrInstance, XrGeneratedDispatchTable*>>(g_instance_dispatch_map, g_instance_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrSession, XrGeneratedDispatchTable*>>(g_session_dispatch_map, g_session_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrSpace, XrGeneratedDispatchTable*>>(g_space_dispatch_map, g_space_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrAction, XrGeneratedDispatchTable*>>(g_action_dispatch_map, g_action_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrSwapchain, XrGeneratedDispatchTable*>>(g_swapchain_dispatch_map, g_swapchain_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrActionSet, XrGeneratedDispatchTable*>>(g_actionset_dispatch_map, g_actionset_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrDebugUtilsMessengerEXT, XrGeneratedDispatchTable*>>(g_debugutilsmessengerext_dispatch_map, g_debugutilsmessengerext_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrSpatialAnchorMSFT, XrGeneratedDispatchTable*>>(g_spatialanchormsft_dispatch_map, g_spatialanchormsft_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrSpatialGraphNodeBindingMSFT, XrGeneratedDispatchTable*>>(g_spatialgraphnodebindingmsft_dispatch_map, g_spatialgraphnodebindingmsft_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrHandTrackerEXT, XrGeneratedDispatchTable*>>(g_handtrackerext_dispatch_map, g_handtrackerext_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrBodyTrackerFB, XrGeneratedDispatchTable*>>(g_bodytrackerfb_dispatch_map, g_bodytrackerfb_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrSceneObserverMSFT, XrGeneratedDispatchTable*>>(g_sceneobservermsft_dispatch_map, g_sceneobservermsft_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrSceneMSFT, XrGeneratedDispatchTable*>>(g_scenemsft_dispatch_map, g_scenemsft_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrFacialTrackerHTC, XrGeneratedDispatchTable*>>(g_facialtrackerhtc_dispatch_map, g_facialtrackerhtc_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrFoveationProfileFB, XrGeneratedDispatchTable*>>(g_foveationprofilefb_dispatch_map, g_foveationprofilefb_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrTriangleMeshFB, XrGeneratedDispatchTable*>>(g_trianglemeshfb_dispatch_map, g_trianglemeshfb_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrPassthroughFB, XrGeneratedDispatchTable*>>(g_passthroughfb_dispatch_map, g_passthroughfb_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrPassthroughLayerFB, XrGeneratedDispatchTable*>>(g_passthroughlayerfb_dispatch_map, g_passthroughlayerfb_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrGeometryInstanceFB, XrGeneratedDispatchTable*>>(g_geometryinstancefb_dispatch_map, g_geometryinstancefb_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrMarkerDetectorML, XrGeneratedDispatchTable*>>(g_markerdetectorml_dispatch_map, g_markerdetectorml_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrExportedLocalizationMapML, XrGeneratedDispatchTable*>>(g_exportedlocalizationmapml_dispatch_map, g_exportedlocalizationmapml_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrSpatialAnchorsStorageML, XrGeneratedDispatchTable*>>(g_spatialanchorsstorageml_dispatch_map, g_spatialanchorsstorageml_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrSpatialAnchorStoreConnectionMSFT, XrGeneratedDispatchTable*>>(g_spatialanchorstoreconnectionmsft_dispatch_map, g_spatialanchorstoreconnectionmsft_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrSpaceUserFB, XrGeneratedDispatchTable*>>(g_spaceuserfb_dispatch_map, g_spaceuserfb_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrFaceTrackerFB, XrGeneratedDispatchTable*>>(g_facetrackerfb_dispatch_map, g_facetrackerfb_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrEyeTrackerFB, XrGeneratedDispatchTable*>>(g_eyetrackerfb_dispatch_map, g_eyetrackerfb_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrVirtualKeyboardMETA, XrGeneratedDispatchTable*>>(g_virtualkeyboardmeta_dispatch_map, g_virtualkeyboardmeta_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrPassthroughColorLutMETA, XrGeneratedDispatchTable*>>(g_passthroughcolorlutmeta_dispatch_map, g_passthroughcolorlutmeta_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrFaceTracker2FB, XrGeneratedDispatchTable*>>(g_facetracker2fb_dispatch_map, g_facetracker2fb_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrEnvironmentDepthProviderMETA, XrGeneratedDispatchTable*>>(g_environmentdepthprovidermeta_dispatch_map, g_environmentdepthprovidermeta_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrEnvironmentDepthSwapchainMETA, XrGeneratedDispatchTable*>>(g_environmentdepthswapchainmeta_dispatch_map, g_environmentdepthswapchainmeta_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrPassthroughHTC, XrGeneratedDispatchTable*>>(g_passthroughhtc_dispatch_map, g_passthroughhtc_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrBodyTrackerHTC, XrGeneratedDispatchTable*>>(g_bodytrackerhtc_dispatch_map, g_bodytrackerhtc_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrBodyTrackerBD, XrGeneratedDispatchTable*>>(g_bodytrackerbd_dispatch_map, g_bodytrackerbd_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrSenseDataProviderBD, XrGeneratedDispatchTable*>>(g_sensedataproviderbd_dispatch_map, g_sensedataproviderbd_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrSenseDataSnapshotBD, XrGeneratedDispatchTable*>>(g_sensedatasnapshotbd_dispatch_map, g_sensedatasnapshotbd_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrAnchorBD, XrGeneratedDispatchTable*>>(g_anchorbd_dispatch_map, g_anchorbd_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrPlaneDetectorEXT, XrGeneratedDispatchTable*>>(g_planedetectorext_dispatch_map, g_planedetectorext_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrWorldMeshDetectorML, XrGeneratedDispatchTable*>>(g_worldmeshdetectorml_dispatch_map, g_worldmeshdetectorml_dispatch_mutex, table);
    eraseAllTableMapElements<std::unordered_map<XrFacialExpressionClientML, XrGeneratedDispatchTable*>>(g_facialexpressionclientml_dispatch_map, g_facialexpressionclientml_dispatch_mutex, table);
}


// Union/Structure Output Helper functions
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrApiLayerProperties* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string layername_prefix = prefix;
        layername_prefix += "layerName";
        contents.emplace_back("char*", layername_prefix, value->layerName);
        std::string specversion_prefix = prefix;
        specversion_prefix += "specVersion";
        std::ostringstream oss_specVersion;
        oss_specVersion << "0x" << std::hex << (value->specVersion);
        contents.emplace_back("XrVersion", specversion_prefix, oss_specVersion.str());
        std::string layerversion_prefix = prefix;
        layerversion_prefix += "layerVersion";
        std::ostringstream oss_layerVersion;
        oss_layerVersion << "0x" << std::hex << (value->layerVersion);
        contents.emplace_back("uint32_t", layerversion_prefix, oss_layerVersion.str());
        std::string description_prefix = prefix;
        description_prefix += "description";
        contents.emplace_back("char*", description_prefix, value->description);
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrExtensionProperties* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string extensionname_prefix = prefix;
        extensionname_prefix += "extensionName";
        contents.emplace_back("char*", extensionname_prefix, value->extensionName);
        std::string extensionversion_prefix = prefix;
        extensionversion_prefix += "extensionVersion";
        std::ostringstream oss_extensionVersion;
        oss_extensionVersion << "0x" << std::hex << (value->extensionVersion);
        contents.emplace_back("uint32_t", extensionversion_prefix, oss_extensionVersion.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrApplicationInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string applicationname_prefix = prefix;
        applicationname_prefix += "applicationName";
        contents.emplace_back("char*", applicationname_prefix, value->applicationName);
        std::string applicationversion_prefix = prefix;
        applicationversion_prefix += "applicationVersion";
        std::ostringstream oss_applicationVersion;
        oss_applicationVersion << "0x" << std::hex << (value->applicationVersion);
        contents.emplace_back("uint32_t", applicationversion_prefix, oss_applicationVersion.str());
        std::string enginename_prefix = prefix;
        enginename_prefix += "engineName";
        contents.emplace_back("char*", enginename_prefix, value->engineName);
        std::string engineversion_prefix = prefix;
        engineversion_prefix += "engineVersion";
        std::ostringstream oss_engineVersion;
        oss_engineVersion << "0x" << std::hex << (value->engineVersion);
        contents.emplace_back("uint32_t", engineversion_prefix, oss_engineVersion.str());
        std::string apiversion_prefix = prefix;
        apiversion_prefix += "apiVersion";
        std::ostringstream oss_apiVersion;
        oss_apiVersion << "0x" << std::hex << (value->apiVersion);
        contents.emplace_back("XrVersion", apiversion_prefix, oss_apiVersion.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrInstanceCreateInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string createflags_prefix = prefix;
        createflags_prefix += "createFlags";
        contents.emplace_back("XrInstanceCreateFlags", createflags_prefix, std::to_string(value->createFlags));
        std::string applicationinfo_prefix = prefix;
        applicationinfo_prefix += "applicationInfo";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->applicationInfo, applicationinfo_prefix, "XrApplicationInfo", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string enabledapilayercount_prefix = prefix;
        enabledapilayercount_prefix += "enabledApiLayerCount";
        std::ostringstream oss_enabledApiLayerCount;
        oss_enabledApiLayerCount << "0x" << std::hex << (value->enabledApiLayerCount);
        contents.emplace_back("uint32_t", enabledapilayercount_prefix, oss_enabledApiLayerCount.str());
        std::string enabledapilayernames_prefix = prefix;
        enabledapilayernames_prefix += "enabledApiLayerNames";
        std::ostringstream oss_enabledApiLayerNames_array;
        oss_enabledApiLayerNames_array << std::hex << reinterpret_cast<const void*>(value->enabledApiLayerNames);
        contents.emplace_back("const char* const*", enabledapilayernames_prefix, oss_enabledApiLayerNames_array.str());
        for (uint32_t value_enabledapilayernames_inc = 0; value_enabledapilayernames_inc < value->enabledApiLayerCount; ++value_enabledapilayernames_inc) {
            std::string enabledapilayernames_array_prefix = enabledapilayernames_prefix;
            enabledapilayernames_array_prefix += "[";
            enabledapilayernames_array_prefix += std::to_string(value_enabledapilayernames_inc);
            enabledapilayernames_array_prefix += "]";
            contents.emplace_back("const char* const*", enabledapilayernames_array_prefix, value->enabledApiLayerNames[value_enabledapilayernames_inc]);
        }
        std::string enabledextensioncount_prefix = prefix;
        enabledextensioncount_prefix += "enabledExtensionCount";
        std::ostringstream oss_enabledExtensionCount;
        oss_enabledExtensionCount << "0x" << std::hex << (value->enabledExtensionCount);
        contents.emplace_back("uint32_t", enabledextensioncount_prefix, oss_enabledExtensionCount.str());
        std::string enabledextensionnames_prefix = prefix;
        enabledextensionnames_prefix += "enabledExtensionNames";
        std::ostringstream oss_enabledExtensionNames_array;
        oss_enabledExtensionNames_array << std::hex << reinterpret_cast<const void*>(value->enabledExtensionNames);
        contents.emplace_back("const char* const*", enabledextensionnames_prefix, oss_enabledExtensionNames_array.str());
        for (uint32_t value_enabledextensionnames_inc = 0; value_enabledextensionnames_inc < value->enabledExtensionCount; ++value_enabledextensionnames_inc) {
            std::string enabledextensionnames_array_prefix = enabledextensionnames_prefix;
            enabledextensionnames_array_prefix += "[";
            enabledextensionnames_array_prefix += std::to_string(value_enabledextensionnames_inc);
            enabledextensionnames_array_prefix += "]";
            contents.emplace_back("const char* const*", enabledextensionnames_array_prefix, value->enabledExtensionNames[value_enabledextensionnames_inc]);
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrInstanceProperties* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string runtimeversion_prefix = prefix;
        runtimeversion_prefix += "runtimeVersion";
        std::ostringstream oss_runtimeVersion;
        oss_runtimeVersion << "0x" << std::hex << (value->runtimeVersion);
        contents.emplace_back("XrVersion", runtimeversion_prefix, oss_runtimeVersion.str());
        std::string runtimename_prefix = prefix;
        runtimename_prefix += "runtimeName";
        contents.emplace_back("char*", runtimename_prefix, value->runtimeName);
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataBuffer* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string varying_prefix = prefix;
        varying_prefix += "varying";
        std::ostringstream oss_varying_array;
        oss_varying_array << "0x" << std::hex << (value->varying);
        contents.emplace_back("uint8_t*", varying_prefix, oss_varying_array.str());
        for (uint32_t value_varying_inc = 0; value_varying_inc < 4000; ++value_varying_inc) {
            std::string varying_array_prefix = varying_prefix;
            varying_array_prefix += "[";
            varying_array_prefix += std::to_string(value_varying_inc);
            varying_array_prefix += "]";
            std::ostringstream oss_varying;
            oss_varying << "0x" << std::hex << (value->varying[value_varying_inc]);
            contents.emplace_back("uint8_t", varying_array_prefix, oss_varying.str());
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemGetInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string formfactor_prefix = prefix;
        formfactor_prefix += "formFactor";
        contents.emplace_back("XrFormFactor", formfactor_prefix, std::to_string(value->formFactor));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemGraphicsProperties* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string maxswapchainimageheight_prefix = prefix;
        maxswapchainimageheight_prefix += "maxSwapchainImageHeight";
        std::ostringstream oss_maxSwapchainImageHeight;
        oss_maxSwapchainImageHeight << "0x" << std::hex << (value->maxSwapchainImageHeight);
        contents.emplace_back("uint32_t", maxswapchainimageheight_prefix, oss_maxSwapchainImageHeight.str());
        std::string maxswapchainimagewidth_prefix = prefix;
        maxswapchainimagewidth_prefix += "maxSwapchainImageWidth";
        std::ostringstream oss_maxSwapchainImageWidth;
        oss_maxSwapchainImageWidth << "0x" << std::hex << (value->maxSwapchainImageWidth);
        contents.emplace_back("uint32_t", maxswapchainimagewidth_prefix, oss_maxSwapchainImageWidth.str());
        std::string maxlayercount_prefix = prefix;
        maxlayercount_prefix += "maxLayerCount";
        std::ostringstream oss_maxLayerCount;
        oss_maxLayerCount << "0x" << std::hex << (value->maxLayerCount);
        contents.emplace_back("uint32_t", maxlayercount_prefix, oss_maxLayerCount.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemTrackingProperties* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string orientationtracking_prefix = prefix;
        orientationtracking_prefix += "orientationTracking";
        std::ostringstream oss_orientationTracking;
        oss_orientationTracking << "0x" << std::hex << (value->orientationTracking);
        contents.emplace_back("XrBool32", orientationtracking_prefix, oss_orientationTracking.str());
        std::string positiontracking_prefix = prefix;
        positiontracking_prefix += "positionTracking";
        std::ostringstream oss_positionTracking;
        oss_positionTracking << "0x" << std::hex << (value->positionTracking);
        contents.emplace_back("XrBool32", positiontracking_prefix, oss_positionTracking.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemProperties* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string systemid_prefix = prefix;
        systemid_prefix += "systemId";
        contents.emplace_back("XrSystemId", systemid_prefix, std::to_string(value->systemId));
        std::string vendorid_prefix = prefix;
        vendorid_prefix += "vendorId";
        std::ostringstream oss_vendorId;
        oss_vendorId << "0x" << std::hex << (value->vendorId);
        contents.emplace_back("uint32_t", vendorid_prefix, oss_vendorId.str());
        std::string systemname_prefix = prefix;
        systemname_prefix += "systemName";
        contents.emplace_back("char*", systemname_prefix, value->systemName);
        std::string graphicsproperties_prefix = prefix;
        graphicsproperties_prefix += "graphicsProperties";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->graphicsProperties, graphicsproperties_prefix, "XrSystemGraphicsProperties", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string trackingproperties_prefix = prefix;
        trackingproperties_prefix += "trackingProperties";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->trackingProperties, trackingproperties_prefix, "XrSystemTrackingProperties", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSessionCreateInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string createflags_prefix = prefix;
        createflags_prefix += "createFlags";
        contents.emplace_back("XrSessionCreateFlags", createflags_prefix, std::to_string(value->createFlags));
        std::string systemid_prefix = prefix;
        systemid_prefix += "systemId";
        contents.emplace_back("XrSystemId", systemid_prefix, std::to_string(value->systemId));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVector3f* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string x_prefix = prefix;
        x_prefix += "x";
        std::ostringstream oss_x;
        oss_x << std::setprecision(32) << (value->x);
        contents.emplace_back("float", x_prefix, oss_x.str());
        std::string y_prefix = prefix;
        y_prefix += "y";
        std::ostringstream oss_y;
        oss_y << std::setprecision(32) << (value->y);
        contents.emplace_back("float", y_prefix, oss_y.str());
        std::string z_prefix = prefix;
        z_prefix += "z";
        std::ostringstream oss_z;
        oss_z << std::setprecision(32) << (value->z);
        contents.emplace_back("float", z_prefix, oss_z.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceVelocity* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string velocityflags_prefix = prefix;
        velocityflags_prefix += "velocityFlags";
        contents.emplace_back("XrSpaceVelocityFlags", velocityflags_prefix, std::to_string(value->velocityFlags));
        std::string linearvelocity_prefix = prefix;
        linearvelocity_prefix += "linearVelocity";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->linearVelocity, linearvelocity_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string angularvelocity_prefix = prefix;
        angularvelocity_prefix += "angularVelocity";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->angularVelocity, angularvelocity_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrQuaternionf* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string x_prefix = prefix;
        x_prefix += "x";
        std::ostringstream oss_x;
        oss_x << std::setprecision(32) << (value->x);
        contents.emplace_back("float", x_prefix, oss_x.str());
        std::string y_prefix = prefix;
        y_prefix += "y";
        std::ostringstream oss_y;
        oss_y << std::setprecision(32) << (value->y);
        contents.emplace_back("float", y_prefix, oss_y.str());
        std::string z_prefix = prefix;
        z_prefix += "z";
        std::ostringstream oss_z;
        oss_z << std::setprecision(32) << (value->z);
        contents.emplace_back("float", z_prefix, oss_z.str());
        std::string w_prefix = prefix;
        w_prefix += "w";
        std::ostringstream oss_w;
        oss_w << std::setprecision(32) << (value->w);
        contents.emplace_back("float", w_prefix, oss_w.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPosef* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string orientation_prefix = prefix;
        orientation_prefix += "orientation";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->orientation, orientation_prefix, "XrQuaternionf", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string position_prefix = prefix;
        position_prefix += "position";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->position, position_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrReferenceSpaceCreateInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string referencespacetype_prefix = prefix;
        referencespacetype_prefix += "referenceSpaceType";
        contents.emplace_back("XrReferenceSpaceType", referencespacetype_prefix, std::to_string(value->referenceSpaceType));
        std::string poseinreferencespace_prefix = prefix;
        poseinreferencespace_prefix += "poseInReferenceSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInReferenceSpace, poseinreferencespace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrExtent2Df* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string width_prefix = prefix;
        width_prefix += "width";
        std::ostringstream oss_width;
        oss_width << std::setprecision(32) << (value->width);
        contents.emplace_back("float", width_prefix, oss_width.str());
        std::string height_prefix = prefix;
        height_prefix += "height";
        std::ostringstream oss_height;
        oss_height << std::setprecision(32) << (value->height);
        contents.emplace_back("float", height_prefix, oss_height.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrActionSpaceCreateInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string action_prefix = prefix;
        action_prefix += "action";
        std::ostringstream oss_action;
        oss_action << std::hex << reinterpret_cast<const void*>(value->action);
        contents.emplace_back("XrAction", action_prefix, oss_action.str());
        std::string subactionpath_prefix = prefix;
        subactionpath_prefix += "subactionPath";
        contents.emplace_back("XrPath", subactionpath_prefix, std::to_string(value->subactionPath));
        std::string poseinactionspace_prefix = prefix;
        poseinactionspace_prefix += "poseInActionSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInActionSpace, poseinactionspace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceLocation* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string locationflags_prefix = prefix;
        locationflags_prefix += "locationFlags";
        contents.emplace_back("XrSpaceLocationFlags", locationflags_prefix, std::to_string(value->locationFlags));
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrViewConfigurationProperties* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string viewconfigurationtype_prefix = prefix;
        viewconfigurationtype_prefix += "viewConfigurationType";
        contents.emplace_back("XrViewConfigurationType", viewconfigurationtype_prefix, std::to_string(value->viewConfigurationType));
        std::string fovmutable_prefix = prefix;
        fovmutable_prefix += "fovMutable";
        std::ostringstream oss_fovMutable;
        oss_fovMutable << "0x" << std::hex << (value->fovMutable);
        contents.emplace_back("XrBool32", fovmutable_prefix, oss_fovMutable.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrViewConfigurationView* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string recommendedimagerectwidth_prefix = prefix;
        recommendedimagerectwidth_prefix += "recommendedImageRectWidth";
        std::ostringstream oss_recommendedImageRectWidth;
        oss_recommendedImageRectWidth << "0x" << std::hex << (value->recommendedImageRectWidth);
        contents.emplace_back("uint32_t", recommendedimagerectwidth_prefix, oss_recommendedImageRectWidth.str());
        std::string maximagerectwidth_prefix = prefix;
        maximagerectwidth_prefix += "maxImageRectWidth";
        std::ostringstream oss_maxImageRectWidth;
        oss_maxImageRectWidth << "0x" << std::hex << (value->maxImageRectWidth);
        contents.emplace_back("uint32_t", maximagerectwidth_prefix, oss_maxImageRectWidth.str());
        std::string recommendedimagerectheight_prefix = prefix;
        recommendedimagerectheight_prefix += "recommendedImageRectHeight";
        std::ostringstream oss_recommendedImageRectHeight;
        oss_recommendedImageRectHeight << "0x" << std::hex << (value->recommendedImageRectHeight);
        contents.emplace_back("uint32_t", recommendedimagerectheight_prefix, oss_recommendedImageRectHeight.str());
        std::string maximagerectheight_prefix = prefix;
        maximagerectheight_prefix += "maxImageRectHeight";
        std::ostringstream oss_maxImageRectHeight;
        oss_maxImageRectHeight << "0x" << std::hex << (value->maxImageRectHeight);
        contents.emplace_back("uint32_t", maximagerectheight_prefix, oss_maxImageRectHeight.str());
        std::string recommendedswapchainsamplecount_prefix = prefix;
        recommendedswapchainsamplecount_prefix += "recommendedSwapchainSampleCount";
        std::ostringstream oss_recommendedSwapchainSampleCount;
        oss_recommendedSwapchainSampleCount << "0x" << std::hex << (value->recommendedSwapchainSampleCount);
        contents.emplace_back("uint32_t", recommendedswapchainsamplecount_prefix, oss_recommendedSwapchainSampleCount.str());
        std::string maxswapchainsamplecount_prefix = prefix;
        maxswapchainsamplecount_prefix += "maxSwapchainSampleCount";
        std::ostringstream oss_maxSwapchainSampleCount;
        oss_maxSwapchainSampleCount << "0x" << std::hex << (value->maxSwapchainSampleCount);
        contents.emplace_back("uint32_t", maxswapchainsamplecount_prefix, oss_maxSwapchainSampleCount.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainCreateInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string createflags_prefix = prefix;
        createflags_prefix += "createFlags";
        contents.emplace_back("XrSwapchainCreateFlags", createflags_prefix, std::to_string(value->createFlags));
        std::string usageflags_prefix = prefix;
        usageflags_prefix += "usageFlags";
        contents.emplace_back("XrSwapchainUsageFlags", usageflags_prefix, std::to_string(value->usageFlags));
        std::string format_prefix = prefix;
        format_prefix += "format";
        contents.emplace_back("int64_t", format_prefix, std::to_string(value->format));
        std::string samplecount_prefix = prefix;
        samplecount_prefix += "sampleCount";
        std::ostringstream oss_sampleCount;
        oss_sampleCount << "0x" << std::hex << (value->sampleCount);
        contents.emplace_back("uint32_t", samplecount_prefix, oss_sampleCount.str());
        std::string width_prefix = prefix;
        width_prefix += "width";
        std::ostringstream oss_width;
        oss_width << "0x" << std::hex << (value->width);
        contents.emplace_back("uint32_t", width_prefix, oss_width.str());
        std::string height_prefix = prefix;
        height_prefix += "height";
        std::ostringstream oss_height;
        oss_height << "0x" << std::hex << (value->height);
        contents.emplace_back("uint32_t", height_prefix, oss_height.str());
        std::string facecount_prefix = prefix;
        facecount_prefix += "faceCount";
        std::ostringstream oss_faceCount;
        oss_faceCount << "0x" << std::hex << (value->faceCount);
        contents.emplace_back("uint32_t", facecount_prefix, oss_faceCount.str());
        std::string arraysize_prefix = prefix;
        arraysize_prefix += "arraySize";
        std::ostringstream oss_arraySize;
        oss_arraySize << "0x" << std::hex << (value->arraySize);
        contents.emplace_back("uint32_t", arraysize_prefix, oss_arraySize.str());
        std::string mipcount_prefix = prefix;
        mipcount_prefix += "mipCount";
        std::ostringstream oss_mipCount;
        oss_mipCount << "0x" << std::hex << (value->mipCount);
        contents.emplace_back("uint32_t", mipcount_prefix, oss_mipCount.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainImageBaseHeader* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
#if defined(XR_USE_GRAPHICS_API_OPENGL)
        if (value->type == XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR) {
            const XrSwapchainImageOpenGLKHR* new_value = reinterpret_cast<const XrSwapchainImageOpenGLKHR*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
        if (value->type == XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR) {
            const XrSwapchainImageOpenGLESKHR* new_value = reinterpret_cast<const XrSwapchainImageOpenGLESKHR*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (value->type == XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR) {
            const XrSwapchainImageVulkanKHR* new_value = reinterpret_cast<const XrSwapchainImageVulkanKHR*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_D3D11)
        if (value->type == XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR) {
            const XrSwapchainImageD3D11KHR* new_value = reinterpret_cast<const XrSwapchainImageD3D11KHR*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#if defined(XR_USE_GRAPHICS_API_D3D12)
        if (value->type == XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR) {
            const XrSwapchainImageD3D12KHR* new_value = reinterpret_cast<const XrSwapchainImageD3D12KHR*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
#endif // defined(XR_USE_GRAPHICS_API_D3D12)
        // Fallback path - Just output generic information about the base struct
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainImageAcquireInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainImageWaitInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string timeout_prefix = prefix;
        timeout_prefix += "timeout";
        contents.emplace_back("XrDuration", timeout_prefix, std::to_string(value->timeout));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainImageReleaseInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSessionBeginInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string primaryviewconfigurationtype_prefix = prefix;
        primaryviewconfigurationtype_prefix += "primaryViewConfigurationType";
        contents.emplace_back("XrViewConfigurationType", primaryviewconfigurationtype_prefix, std::to_string(value->primaryViewConfigurationType));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFrameWaitInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFrameState* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string predicteddisplaytime_prefix = prefix;
        predicteddisplaytime_prefix += "predictedDisplayTime";
        contents.emplace_back("XrTime", predicteddisplaytime_prefix, std::to_string(value->predictedDisplayTime));
        std::string predicteddisplayperiod_prefix = prefix;
        predicteddisplayperiod_prefix += "predictedDisplayPeriod";
        contents.emplace_back("XrDuration", predicteddisplayperiod_prefix, std::to_string(value->predictedDisplayPeriod));
        std::string shouldrender_prefix = prefix;
        shouldrender_prefix += "shouldRender";
        std::ostringstream oss_shouldRender;
        oss_shouldRender << "0x" << std::hex << (value->shouldRender);
        contents.emplace_back("XrBool32", shouldrender_prefix, oss_shouldRender.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFrameBeginInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerBaseHeader* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        if (value->type == XR_TYPE_COMPOSITION_LAYER_PROJECTION) {
            const XrCompositionLayerProjection* new_value = reinterpret_cast<const XrCompositionLayerProjection*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_COMPOSITION_LAYER_QUAD) {
            const XrCompositionLayerQuad* new_value = reinterpret_cast<const XrCompositionLayerQuad*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_COMPOSITION_LAYER_CUBE_KHR) {
            const XrCompositionLayerCubeKHR* new_value = reinterpret_cast<const XrCompositionLayerCubeKHR*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR) {
            const XrCompositionLayerCylinderKHR* new_value = reinterpret_cast<const XrCompositionLayerCylinderKHR*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR) {
            const XrCompositionLayerEquirectKHR* new_value = reinterpret_cast<const XrCompositionLayerEquirectKHR*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR) {
            const XrCompositionLayerEquirect2KHR* new_value = reinterpret_cast<const XrCompositionLayerEquirect2KHR*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_FB) {
            const XrCompositionLayerPassthroughFB* new_value = reinterpret_cast<const XrCompositionLayerPassthroughFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC) {
            const XrCompositionLayerPassthroughHTC* new_value = reinterpret_cast<const XrCompositionLayerPassthroughHTC*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        // Fallback path - Just output generic information about the base struct
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string layerflags_prefix = prefix;
        layerflags_prefix += "layerFlags";
        contents.emplace_back("XrCompositionLayerFlags", layerflags_prefix, std::to_string(value->layerFlags));
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFrameEndInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string displaytime_prefix = prefix;
        displaytime_prefix += "displayTime";
        contents.emplace_back("XrTime", displaytime_prefix, std::to_string(value->displayTime));
        std::string environmentblendmode_prefix = prefix;
        environmentblendmode_prefix += "environmentBlendMode";
        contents.emplace_back("XrEnvironmentBlendMode", environmentblendmode_prefix, std::to_string(value->environmentBlendMode));
        std::string layercount_prefix = prefix;
        layercount_prefix += "layerCount";
        std::ostringstream oss_layerCount;
        oss_layerCount << "0x" << std::hex << (value->layerCount);
        contents.emplace_back("uint32_t", layercount_prefix, oss_layerCount.str());
        std::string layers_prefix = prefix;
        layers_prefix += "layers";
        std::ostringstream oss_layers_array;
        oss_layers_array << std::hex << reinterpret_cast<const void*>(value->layers);
        contents.emplace_back("const XrCompositionLayerBaseHeader* const*", layers_prefix, oss_layers_array.str());
        for (uint32_t value_layers_inc = 0; value_layers_inc < value->layerCount; ++value_layers_inc) {
            std::string layers_array_prefix = layers_prefix;
            layers_array_prefix += "[";
            layers_array_prefix += std::to_string(value_layers_inc);
            layers_array_prefix += "]";
            if (nullptr == value->layers[value_layers_inc]) {
                std::ostringstream oss_layers;
                oss_layers << std::hex << reinterpret_cast<const void*>(value->layers[value_layers_inc]);
                contents.emplace_back("const XrCompositionLayerBaseHeader* const*", layers_array_prefix, oss_layers.str());
            } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, value->layers[value_layers_inc], layers_array_prefix, "const XrCompositionLayerBaseHeader* const*", true, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrViewLocateInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string viewconfigurationtype_prefix = prefix;
        viewconfigurationtype_prefix += "viewConfigurationType";
        contents.emplace_back("XrViewConfigurationType", viewconfigurationtype_prefix, std::to_string(value->viewConfigurationType));
        std::string displaytime_prefix = prefix;
        displaytime_prefix += "displayTime";
        contents.emplace_back("XrTime", displaytime_prefix, std::to_string(value->displayTime));
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrViewState* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string viewstateflags_prefix = prefix;
        viewstateflags_prefix += "viewStateFlags";
        contents.emplace_back("XrViewStateFlags", viewstateflags_prefix, std::to_string(value->viewStateFlags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFovf* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string angleleft_prefix = prefix;
        angleleft_prefix += "angleLeft";
        std::ostringstream oss_angleLeft;
        oss_angleLeft << std::setprecision(32) << (value->angleLeft);
        contents.emplace_back("float", angleleft_prefix, oss_angleLeft.str());
        std::string angleright_prefix = prefix;
        angleright_prefix += "angleRight";
        std::ostringstream oss_angleRight;
        oss_angleRight << std::setprecision(32) << (value->angleRight);
        contents.emplace_back("float", angleright_prefix, oss_angleRight.str());
        std::string angleup_prefix = prefix;
        angleup_prefix += "angleUp";
        std::ostringstream oss_angleUp;
        oss_angleUp << std::setprecision(32) << (value->angleUp);
        contents.emplace_back("float", angleup_prefix, oss_angleUp.str());
        std::string angledown_prefix = prefix;
        angledown_prefix += "angleDown";
        std::ostringstream oss_angleDown;
        oss_angleDown << std::setprecision(32) << (value->angleDown);
        contents.emplace_back("float", angledown_prefix, oss_angleDown.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrView* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string fov_prefix = prefix;
        fov_prefix += "fov";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->fov, fov_prefix, "XrFovf", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrActionSetCreateInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string actionsetname_prefix = prefix;
        actionsetname_prefix += "actionSetName";
        contents.emplace_back("char*", actionsetname_prefix, value->actionSetName);
        std::string localizedactionsetname_prefix = prefix;
        localizedactionsetname_prefix += "localizedActionSetName";
        contents.emplace_back("char*", localizedactionsetname_prefix, value->localizedActionSetName);
        std::string priority_prefix = prefix;
        priority_prefix += "priority";
        std::ostringstream oss_priority;
        oss_priority << "0x" << std::hex << (value->priority);
        contents.emplace_back("uint32_t", priority_prefix, oss_priority.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrActionCreateInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string actionname_prefix = prefix;
        actionname_prefix += "actionName";
        contents.emplace_back("char*", actionname_prefix, value->actionName);
        std::string actiontype_prefix = prefix;
        actiontype_prefix += "actionType";
        contents.emplace_back("XrActionType", actiontype_prefix, std::to_string(value->actionType));
        std::string countsubactionpaths_prefix = prefix;
        countsubactionpaths_prefix += "countSubactionPaths";
        std::ostringstream oss_countSubactionPaths;
        oss_countSubactionPaths << "0x" << std::hex << (value->countSubactionPaths);
        contents.emplace_back("uint32_t", countsubactionpaths_prefix, oss_countSubactionPaths.str());
        std::string subactionpaths_prefix = prefix;
        subactionpaths_prefix += "subactionPaths";
        std::ostringstream oss_subactionPaths_array;
        oss_subactionPaths_array << std::hex << reinterpret_cast<const void*>(value->subactionPaths);
        contents.emplace_back("const XrPath*", subactionpaths_prefix, oss_subactionPaths_array.str());
        for (uint32_t value_subactionpaths_inc = 0; value_subactionpaths_inc < value->countSubactionPaths; ++value_subactionpaths_inc) {
            std::string subactionpaths_array_prefix = subactionpaths_prefix;
            subactionpaths_array_prefix += "[";
            subactionpaths_array_prefix += std::to_string(value_subactionpaths_inc);
            subactionpaths_array_prefix += "]";
            contents.emplace_back("const XrPath*", subactionpaths_array_prefix, std::to_string(value->subactionPaths[value_subactionpaths_inc]));
        }
        std::string localizedactionname_prefix = prefix;
        localizedactionname_prefix += "localizedActionName";
        contents.emplace_back("char*", localizedactionname_prefix, value->localizedActionName);
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrActionSuggestedBinding* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string action_prefix = prefix;
        action_prefix += "action";
        std::ostringstream oss_action;
        oss_action << std::hex << reinterpret_cast<const void*>(value->action);
        contents.emplace_back("XrAction", action_prefix, oss_action.str());
        std::string binding_prefix = prefix;
        binding_prefix += "binding";
        contents.emplace_back("XrPath", binding_prefix, std::to_string(value->binding));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrInteractionProfileSuggestedBinding* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string interactionprofile_prefix = prefix;
        interactionprofile_prefix += "interactionProfile";
        contents.emplace_back("XrPath", interactionprofile_prefix, std::to_string(value->interactionProfile));
        std::string countsuggestedbindings_prefix = prefix;
        countsuggestedbindings_prefix += "countSuggestedBindings";
        std::ostringstream oss_countSuggestedBindings;
        oss_countSuggestedBindings << "0x" << std::hex << (value->countSuggestedBindings);
        contents.emplace_back("uint32_t", countsuggestedbindings_prefix, oss_countSuggestedBindings.str());
        std::string suggestedbindings_prefix = prefix;
        suggestedbindings_prefix += "suggestedBindings";
        std::ostringstream oss_suggestedBindings_array;
        oss_suggestedBindings_array << std::hex << reinterpret_cast<const void*>(value->suggestedBindings);
        contents.emplace_back("const XrActionSuggestedBinding*", suggestedbindings_prefix, oss_suggestedBindings_array.str());
        for (uint32_t value_suggestedbindings_inc = 0; value_suggestedbindings_inc < value->countSuggestedBindings; ++value_suggestedbindings_inc) {
            std::string suggestedbindings_array_prefix = suggestedbindings_prefix;
            suggestedbindings_array_prefix += "[";
            suggestedbindings_array_prefix += std::to_string(value_suggestedbindings_inc);
            suggestedbindings_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->suggestedBindings[value_suggestedbindings_inc], suggestedbindings_array_prefix, "const XrActionSuggestedBinding*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSessionActionSetsAttachInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string countactionsets_prefix = prefix;
        countactionsets_prefix += "countActionSets";
        std::ostringstream oss_countActionSets;
        oss_countActionSets << "0x" << std::hex << (value->countActionSets);
        contents.emplace_back("uint32_t", countactionsets_prefix, oss_countActionSets.str());
        std::string actionsets_prefix = prefix;
        actionsets_prefix += "actionSets";
        std::ostringstream oss_actionSets_array;
        oss_actionSets_array << std::hex << reinterpret_cast<const void*>(value->actionSets);
        contents.emplace_back("const XrActionSet*", actionsets_prefix, oss_actionSets_array.str());
        for (uint32_t value_actionsets_inc = 0; value_actionsets_inc < value->countActionSets; ++value_actionsets_inc) {
            std::string actionsets_array_prefix = actionsets_prefix;
            actionsets_array_prefix += "[";
            actionsets_array_prefix += std::to_string(value_actionsets_inc);
            actionsets_array_prefix += "]";
            std::ostringstream oss_actionSets;
            oss_actionSets << std::hex << reinterpret_cast<const void*>(value->actionSets[value_actionsets_inc]);
            contents.emplace_back("const XrActionSet*", actionsets_array_prefix, oss_actionSets.str());
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrInteractionProfileState* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string interactionprofile_prefix = prefix;
        interactionprofile_prefix += "interactionProfile";
        contents.emplace_back("XrPath", interactionprofile_prefix, std::to_string(value->interactionProfile));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrActionStateGetInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string action_prefix = prefix;
        action_prefix += "action";
        std::ostringstream oss_action;
        oss_action << std::hex << reinterpret_cast<const void*>(value->action);
        contents.emplace_back("XrAction", action_prefix, oss_action.str());
        std::string subactionpath_prefix = prefix;
        subactionpath_prefix += "subactionPath";
        contents.emplace_back("XrPath", subactionpath_prefix, std::to_string(value->subactionPath));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrActionStateBoolean* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string currentstate_prefix = prefix;
        currentstate_prefix += "currentState";
        std::ostringstream oss_currentState;
        oss_currentState << "0x" << std::hex << (value->currentState);
        contents.emplace_back("XrBool32", currentstate_prefix, oss_currentState.str());
        std::string changedsincelastsync_prefix = prefix;
        changedsincelastsync_prefix += "changedSinceLastSync";
        std::ostringstream oss_changedSinceLastSync;
        oss_changedSinceLastSync << "0x" << std::hex << (value->changedSinceLastSync);
        contents.emplace_back("XrBool32", changedsincelastsync_prefix, oss_changedSinceLastSync.str());
        std::string lastchangetime_prefix = prefix;
        lastchangetime_prefix += "lastChangeTime";
        contents.emplace_back("XrTime", lastchangetime_prefix, std::to_string(value->lastChangeTime));
        std::string isactive_prefix = prefix;
        isactive_prefix += "isActive";
        std::ostringstream oss_isActive;
        oss_isActive << "0x" << std::hex << (value->isActive);
        contents.emplace_back("XrBool32", isactive_prefix, oss_isActive.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrActionStateFloat* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string currentstate_prefix = prefix;
        currentstate_prefix += "currentState";
        std::ostringstream oss_currentState;
        oss_currentState << std::setprecision(32) << (value->currentState);
        contents.emplace_back("float", currentstate_prefix, oss_currentState.str());
        std::string changedsincelastsync_prefix = prefix;
        changedsincelastsync_prefix += "changedSinceLastSync";
        std::ostringstream oss_changedSinceLastSync;
        oss_changedSinceLastSync << "0x" << std::hex << (value->changedSinceLastSync);
        contents.emplace_back("XrBool32", changedsincelastsync_prefix, oss_changedSinceLastSync.str());
        std::string lastchangetime_prefix = prefix;
        lastchangetime_prefix += "lastChangeTime";
        contents.emplace_back("XrTime", lastchangetime_prefix, std::to_string(value->lastChangeTime));
        std::string isactive_prefix = prefix;
        isactive_prefix += "isActive";
        std::ostringstream oss_isActive;
        oss_isActive << "0x" << std::hex << (value->isActive);
        contents.emplace_back("XrBool32", isactive_prefix, oss_isActive.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVector2f* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string x_prefix = prefix;
        x_prefix += "x";
        std::ostringstream oss_x;
        oss_x << std::setprecision(32) << (value->x);
        contents.emplace_back("float", x_prefix, oss_x.str());
        std::string y_prefix = prefix;
        y_prefix += "y";
        std::ostringstream oss_y;
        oss_y << std::setprecision(32) << (value->y);
        contents.emplace_back("float", y_prefix, oss_y.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrActionStateVector2f* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string currentstate_prefix = prefix;
        currentstate_prefix += "currentState";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->currentState, currentstate_prefix, "XrVector2f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string changedsincelastsync_prefix = prefix;
        changedsincelastsync_prefix += "changedSinceLastSync";
        std::ostringstream oss_changedSinceLastSync;
        oss_changedSinceLastSync << "0x" << std::hex << (value->changedSinceLastSync);
        contents.emplace_back("XrBool32", changedsincelastsync_prefix, oss_changedSinceLastSync.str());
        std::string lastchangetime_prefix = prefix;
        lastchangetime_prefix += "lastChangeTime";
        contents.emplace_back("XrTime", lastchangetime_prefix, std::to_string(value->lastChangeTime));
        std::string isactive_prefix = prefix;
        isactive_prefix += "isActive";
        std::ostringstream oss_isActive;
        oss_isActive << "0x" << std::hex << (value->isActive);
        contents.emplace_back("XrBool32", isactive_prefix, oss_isActive.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrActionStatePose* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string isactive_prefix = prefix;
        isactive_prefix += "isActive";
        std::ostringstream oss_isActive;
        oss_isActive << "0x" << std::hex << (value->isActive);
        contents.emplace_back("XrBool32", isactive_prefix, oss_isActive.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrActiveActionSet* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string actionset_prefix = prefix;
        actionset_prefix += "actionSet";
        std::ostringstream oss_actionSet;
        oss_actionSet << std::hex << reinterpret_cast<const void*>(value->actionSet);
        contents.emplace_back("XrActionSet", actionset_prefix, oss_actionSet.str());
        std::string subactionpath_prefix = prefix;
        subactionpath_prefix += "subactionPath";
        contents.emplace_back("XrPath", subactionpath_prefix, std::to_string(value->subactionPath));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrActionsSyncInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string countactiveactionsets_prefix = prefix;
        countactiveactionsets_prefix += "countActiveActionSets";
        std::ostringstream oss_countActiveActionSets;
        oss_countActiveActionSets << "0x" << std::hex << (value->countActiveActionSets);
        contents.emplace_back("uint32_t", countactiveactionsets_prefix, oss_countActiveActionSets.str());
        std::string activeactionsets_prefix = prefix;
        activeactionsets_prefix += "activeActionSets";
        std::ostringstream oss_activeActionSets_array;
        oss_activeActionSets_array << std::hex << reinterpret_cast<const void*>(value->activeActionSets);
        contents.emplace_back("const XrActiveActionSet*", activeactionsets_prefix, oss_activeActionSets_array.str());
        for (uint32_t value_activeactionsets_inc = 0; value_activeactionsets_inc < value->countActiveActionSets; ++value_activeactionsets_inc) {
            std::string activeactionsets_array_prefix = activeactionsets_prefix;
            activeactionsets_array_prefix += "[";
            activeactionsets_array_prefix += std::to_string(value_activeactionsets_inc);
            activeactionsets_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->activeActionSets[value_activeactionsets_inc], activeactionsets_array_prefix, "const XrActiveActionSet*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBoundSourcesForActionEnumerateInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string action_prefix = prefix;
        action_prefix += "action";
        std::ostringstream oss_action;
        oss_action << std::hex << reinterpret_cast<const void*>(value->action);
        contents.emplace_back("XrAction", action_prefix, oss_action.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrInputSourceLocalizedNameGetInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string sourcepath_prefix = prefix;
        sourcepath_prefix += "sourcePath";
        contents.emplace_back("XrPath", sourcepath_prefix, std::to_string(value->sourcePath));
        std::string whichcomponents_prefix = prefix;
        whichcomponents_prefix += "whichComponents";
        contents.emplace_back("XrInputSourceLocalizedNameFlags", whichcomponents_prefix, std::to_string(value->whichComponents));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHapticActionInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string action_prefix = prefix;
        action_prefix += "action";
        std::ostringstream oss_action;
        oss_action << std::hex << reinterpret_cast<const void*>(value->action);
        contents.emplace_back("XrAction", action_prefix, oss_action.str());
        std::string subactionpath_prefix = prefix;
        subactionpath_prefix += "subactionPath";
        contents.emplace_back("XrPath", subactionpath_prefix, std::to_string(value->subactionPath));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHapticBaseHeader* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        if (value->type == XR_TYPE_HAPTIC_VIBRATION) {
            const XrHapticVibration* new_value = reinterpret_cast<const XrHapticVibration*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB) {
            const XrHapticAmplitudeEnvelopeVibrationFB* new_value = reinterpret_cast<const XrHapticAmplitudeEnvelopeVibrationFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_HAPTIC_PCM_VIBRATION_FB) {
            const XrHapticPcmVibrationFB* new_value = reinterpret_cast<const XrHapticPcmVibrationFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        // Fallback path - Just output generic information about the base struct
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBaseInStructure* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBaseOutStructure* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrOffset2Di* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string x_prefix = prefix;
        x_prefix += "x";
        contents.emplace_back("int32_t", x_prefix, std::to_string(value->x));
        std::string y_prefix = prefix;
        y_prefix += "y";
        contents.emplace_back("int32_t", y_prefix, std::to_string(value->y));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrExtent2Di* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string width_prefix = prefix;
        width_prefix += "width";
        contents.emplace_back("int32_t", width_prefix, std::to_string(value->width));
        std::string height_prefix = prefix;
        height_prefix += "height";
        contents.emplace_back("int32_t", height_prefix, std::to_string(value->height));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrRect2Di* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string offset_prefix = prefix;
        offset_prefix += "offset";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->offset, offset_prefix, "XrOffset2Di", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string extent_prefix = prefix;
        extent_prefix += "extent";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->extent, extent_prefix, "XrExtent2Di", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainSubImage* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string swapchain_prefix = prefix;
        swapchain_prefix += "swapchain";
        std::ostringstream oss_swapchain;
        oss_swapchain << std::hex << reinterpret_cast<const void*>(value->swapchain);
        contents.emplace_back("XrSwapchain", swapchain_prefix, oss_swapchain.str());
        std::string imagerect_prefix = prefix;
        imagerect_prefix += "imageRect";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->imageRect, imagerect_prefix, "XrRect2Di", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string imagearrayindex_prefix = prefix;
        imagearrayindex_prefix += "imageArrayIndex";
        std::ostringstream oss_imageArrayIndex;
        oss_imageArrayIndex << "0x" << std::hex << (value->imageArrayIndex);
        contents.emplace_back("uint32_t", imagearrayindex_prefix, oss_imageArrayIndex.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerProjectionView* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string fov_prefix = prefix;
        fov_prefix += "fov";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->fov, fov_prefix, "XrFovf", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string subimage_prefix = prefix;
        subimage_prefix += "subImage";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->subImage, subimage_prefix, "XrSwapchainSubImage", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerProjection* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string layerflags_prefix = prefix;
        layerflags_prefix += "layerFlags";
        contents.emplace_back("XrCompositionLayerFlags", layerflags_prefix, std::to_string(value->layerFlags));
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string viewcount_prefix = prefix;
        viewcount_prefix += "viewCount";
        std::ostringstream oss_viewCount;
        oss_viewCount << "0x" << std::hex << (value->viewCount);
        contents.emplace_back("uint32_t", viewcount_prefix, oss_viewCount.str());
        std::string views_prefix = prefix;
        views_prefix += "views";
        std::ostringstream oss_views_array;
        oss_views_array << std::hex << reinterpret_cast<const void*>(value->views);
        contents.emplace_back("const XrCompositionLayerProjectionView*", views_prefix, oss_views_array.str());
        for (uint32_t value_views_inc = 0; value_views_inc < value->viewCount; ++value_views_inc) {
            std::string views_array_prefix = views_prefix;
            views_array_prefix += "[";
            views_array_prefix += std::to_string(value_views_inc);
            views_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->views[value_views_inc], views_array_prefix, "const XrCompositionLayerProjectionView*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerQuad* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string layerflags_prefix = prefix;
        layerflags_prefix += "layerFlags";
        contents.emplace_back("XrCompositionLayerFlags", layerflags_prefix, std::to_string(value->layerFlags));
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string eyevisibility_prefix = prefix;
        eyevisibility_prefix += "eyeVisibility";
        contents.emplace_back("XrEyeVisibility", eyevisibility_prefix, std::to_string(value->eyeVisibility));
        std::string subimage_prefix = prefix;
        subimage_prefix += "subImage";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->subImage, subimage_prefix, "XrSwapchainSubImage", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string size_prefix = prefix;
        size_prefix += "size";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->size, size_prefix, "XrExtent2Df", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataBaseHeader* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        if (value->type == XR_TYPE_EVENT_DATA_EVENTS_LOST) {
            const XrEventDataEventsLost* new_value = reinterpret_cast<const XrEventDataEventsLost*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_INSTANCE_LOSS_PENDING) {
            const XrEventDataInstanceLossPending* new_value = reinterpret_cast<const XrEventDataInstanceLossPending*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED) {
            const XrEventDataSessionStateChanged* new_value = reinterpret_cast<const XrEventDataSessionStateChanged*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING) {
            const XrEventDataReferenceSpaceChangePending* new_value = reinterpret_cast<const XrEventDataReferenceSpaceChangePending*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED) {
            const XrEventDataInteractionProfileChanged* new_value = reinterpret_cast<const XrEventDataInteractionProfileChanged*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR) {
            const XrEventDataVisibilityMaskChangedKHR* new_value = reinterpret_cast<const XrEventDataVisibilityMaskChangedKHR*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT) {
            const XrEventDataPerfSettingsEXT* new_value = reinterpret_cast<const XrEventDataPerfSettingsEXT*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX) {
            const XrEventDataMainSessionVisibilityChangedEXTX* new_value = reinterpret_cast<const XrEventDataMainSessionVisibilityChangedEXTX*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB) {
            const XrEventDataDisplayRefreshRateChangedFB* new_value = reinterpret_cast<const XrEventDataDisplayRefreshRateChangedFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX) {
            const XrEventDataViveTrackerConnectedHTCX* new_value = reinterpret_cast<const XrEventDataViveTrackerConnectedHTCX*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB) {
            const XrEventDataSpatialAnchorCreateCompleteFB* new_value = reinterpret_cast<const XrEventDataSpatialAnchorCreateCompleteFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB) {
            const XrEventDataSpaceSetStatusCompleteFB* new_value = reinterpret_cast<const XrEventDataSpaceSetStatusCompleteFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO) {
            const XrEventDataMarkerTrackingUpdateVARJO* new_value = reinterpret_cast<const XrEventDataMarkerTrackingUpdateVARJO*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_LOCALIZATION_CHANGED_ML) {
            const XrEventDataLocalizationChangedML* new_value = reinterpret_cast<const XrEventDataLocalizationChangedML*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB) {
            const XrEventDataSpaceQueryResultsAvailableFB* new_value = reinterpret_cast<const XrEventDataSpaceQueryResultsAvailableFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB) {
            const XrEventDataSpaceQueryCompleteFB* new_value = reinterpret_cast<const XrEventDataSpaceQueryCompleteFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB) {
            const XrEventDataSpaceSaveCompleteFB* new_value = reinterpret_cast<const XrEventDataSpaceSaveCompleteFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB) {
            const XrEventDataSpaceEraseCompleteFB* new_value = reinterpret_cast<const XrEventDataSpaceEraseCompleteFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_SPACE_SHARE_COMPLETE_FB) {
            const XrEventDataSpaceShareCompleteFB* new_value = reinterpret_cast<const XrEventDataSpaceShareCompleteFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_SPACE_LIST_SAVE_COMPLETE_FB) {
            const XrEventDataSpaceListSaveCompleteFB* new_value = reinterpret_cast<const XrEventDataSpaceListSaveCompleteFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_PASSTHROUGH_LAYER_RESUMED_META) {
            const XrEventDataPassthroughLayerResumedMETA* new_value = reinterpret_cast<const XrEventDataPassthroughLayerResumedMETA*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_SENSE_DATA_PROVIDER_STATE_CHANGED_BD) {
            const XrEventDataSenseDataProviderStateChangedBD* new_value = reinterpret_cast<const XrEventDataSenseDataProviderStateChangedBD*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_SENSE_DATA_UPDATED_BD) {
            const XrEventDataSenseDataUpdatedBD* new_value = reinterpret_cast<const XrEventDataSenseDataUpdatedBD*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_HEADSET_FIT_CHANGED_ML) {
            const XrEventDataHeadsetFitChangedML* new_value = reinterpret_cast<const XrEventDataHeadsetFitChangedML*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_EVENT_DATA_EYE_CALIBRATION_CHANGED_ML) {
            const XrEventDataEyeCalibrationChangedML* new_value = reinterpret_cast<const XrEventDataEyeCalibrationChangedML*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        // Fallback path - Just output generic information about the base struct
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataEventsLost* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string losteventcount_prefix = prefix;
        losteventcount_prefix += "lostEventCount";
        std::ostringstream oss_lostEventCount;
        oss_lostEventCount << "0x" << std::hex << (value->lostEventCount);
        contents.emplace_back("uint32_t", losteventcount_prefix, oss_lostEventCount.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataInstanceLossPending* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string losstime_prefix = prefix;
        losstime_prefix += "lossTime";
        contents.emplace_back("XrTime", losstime_prefix, std::to_string(value->lossTime));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataSessionStateChanged* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string session_prefix = prefix;
        session_prefix += "session";
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(value->session);
        contents.emplace_back("XrSession", session_prefix, oss_session.str());
        std::string state_prefix = prefix;
        state_prefix += "state";
        contents.emplace_back("XrSessionState", state_prefix, std::to_string(value->state));
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataReferenceSpaceChangePending* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string session_prefix = prefix;
        session_prefix += "session";
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(value->session);
        contents.emplace_back("XrSession", session_prefix, oss_session.str());
        std::string referencespacetype_prefix = prefix;
        referencespacetype_prefix += "referenceSpaceType";
        contents.emplace_back("XrReferenceSpaceType", referencespacetype_prefix, std::to_string(value->referenceSpaceType));
        std::string changetime_prefix = prefix;
        changetime_prefix += "changeTime";
        contents.emplace_back("XrTime", changetime_prefix, std::to_string(value->changeTime));
        std::string posevalid_prefix = prefix;
        posevalid_prefix += "poseValid";
        std::ostringstream oss_poseValid;
        oss_poseValid << "0x" << std::hex << (value->poseValid);
        contents.emplace_back("XrBool32", posevalid_prefix, oss_poseValid.str());
        std::string poseinpreviousspace_prefix = prefix;
        poseinpreviousspace_prefix += "poseInPreviousSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInPreviousSpace, poseinpreviousspace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataInteractionProfileChanged* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string session_prefix = prefix;
        session_prefix += "session";
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(value->session);
        contents.emplace_back("XrSession", session_prefix, oss_session.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHapticVibration* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string duration_prefix = prefix;
        duration_prefix += "duration";
        contents.emplace_back("XrDuration", duration_prefix, std::to_string(value->duration));
        std::string frequency_prefix = prefix;
        frequency_prefix += "frequency";
        std::ostringstream oss_frequency;
        oss_frequency << std::setprecision(32) << (value->frequency);
        contents.emplace_back("float", frequency_prefix, oss_frequency.str());
        std::string amplitude_prefix = prefix;
        amplitude_prefix += "amplitude";
        std::ostringstream oss_amplitude;
        oss_amplitude << std::setprecision(32) << (value->amplitude);
        contents.emplace_back("float", amplitude_prefix, oss_amplitude.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrOffset2Df* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string x_prefix = prefix;
        x_prefix += "x";
        std::ostringstream oss_x;
        oss_x << std::setprecision(32) << (value->x);
        contents.emplace_back("float", x_prefix, oss_x.str());
        std::string y_prefix = prefix;
        y_prefix += "y";
        std::ostringstream oss_y;
        oss_y << std::setprecision(32) << (value->y);
        contents.emplace_back("float", y_prefix, oss_y.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrRect2Df* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string offset_prefix = prefix;
        offset_prefix += "offset";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->offset, offset_prefix, "XrOffset2Df", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string extent_prefix = prefix;
        extent_prefix += "extent";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->extent, extent_prefix, "XrExtent2Df", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVector4f* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string x_prefix = prefix;
        x_prefix += "x";
        std::ostringstream oss_x;
        oss_x << std::setprecision(32) << (value->x);
        contents.emplace_back("float", x_prefix, oss_x.str());
        std::string y_prefix = prefix;
        y_prefix += "y";
        std::ostringstream oss_y;
        oss_y << std::setprecision(32) << (value->y);
        contents.emplace_back("float", y_prefix, oss_y.str());
        std::string z_prefix = prefix;
        z_prefix += "z";
        std::ostringstream oss_z;
        oss_z << std::setprecision(32) << (value->z);
        contents.emplace_back("float", z_prefix, oss_z.str());
        std::string w_prefix = prefix;
        w_prefix += "w";
        std::ostringstream oss_w;
        oss_w << std::setprecision(32) << (value->w);
        contents.emplace_back("float", w_prefix, oss_w.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrColor4f* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string r_prefix = prefix;
        r_prefix += "r";
        std::ostringstream oss_r;
        oss_r << std::setprecision(32) << (value->r);
        contents.emplace_back("float", r_prefix, oss_r.str());
        std::string g_prefix = prefix;
        g_prefix += "g";
        std::ostringstream oss_g;
        oss_g << std::setprecision(32) << (value->g);
        contents.emplace_back("float", g_prefix, oss_g.str());
        std::string b_prefix = prefix;
        b_prefix += "b";
        std::ostringstream oss_b;
        oss_b << std::setprecision(32) << (value->b);
        contents.emplace_back("float", b_prefix, oss_b.str());
        std::string a_prefix = prefix;
        a_prefix += "a";
        std::ostringstream oss_a;
        oss_a << std::setprecision(32) << (value->a);
        contents.emplace_back("float", a_prefix, oss_a.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrColor3f* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string r_prefix = prefix;
        r_prefix += "r";
        std::ostringstream oss_r;
        oss_r << std::setprecision(32) << (value->r);
        contents.emplace_back("float", r_prefix, oss_r.str());
        std::string g_prefix = prefix;
        g_prefix += "g";
        std::ostringstream oss_g;
        oss_g << std::setprecision(32) << (value->g);
        contents.emplace_back("float", g_prefix, oss_g.str());
        std::string b_prefix = prefix;
        b_prefix += "b";
        std::ostringstream oss_b;
        oss_b << std::setprecision(32) << (value->b);
        contents.emplace_back("float", b_prefix, oss_b.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrExtent3Df* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string width_prefix = prefix;
        width_prefix += "width";
        std::ostringstream oss_width;
        oss_width << std::setprecision(32) << (value->width);
        contents.emplace_back("float", width_prefix, oss_width.str());
        std::string height_prefix = prefix;
        height_prefix += "height";
        std::ostringstream oss_height;
        oss_height << std::setprecision(32) << (value->height);
        contents.emplace_back("float", height_prefix, oss_height.str());
        std::string depth_prefix = prefix;
        depth_prefix += "depth";
        std::ostringstream oss_depth;
        oss_depth << std::setprecision(32) << (value->depth);
        contents.emplace_back("float", depth_prefix, oss_depth.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpheref* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string center_prefix = prefix;
        center_prefix += "center";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->center, center_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string radius_prefix = prefix;
        radius_prefix += "radius";
        std::ostringstream oss_radius;
        oss_radius << std::setprecision(32) << (value->radius);
        contents.emplace_back("float", radius_prefix, oss_radius.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBoxf* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string center_prefix = prefix;
        center_prefix += "center";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->center, center_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string extents_prefix = prefix;
        extents_prefix += "extents";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->extents, extents_prefix, "XrExtent3Df", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFrustumf* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string fov_prefix = prefix;
        fov_prefix += "fov";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->fov, fov_prefix, "XrFovf", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string nearz_prefix = prefix;
        nearz_prefix += "nearZ";
        std::ostringstream oss_nearZ;
        oss_nearZ << std::setprecision(32) << (value->nearZ);
        contents.emplace_back("float", nearz_prefix, oss_nearZ.str());
        std::string farz_prefix = prefix;
        farz_prefix += "farZ";
        std::ostringstream oss_farZ;
        oss_farZ << std::setprecision(32) << (value->farZ);
        contents.emplace_back("float", farz_prefix, oss_farZ.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrUuid* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string data_prefix = prefix;
        data_prefix += "data";
        std::ostringstream oss_data_array;
        oss_data_array << "0x" << std::hex << (value->data);
        contents.emplace_back("uint8_t*", data_prefix, oss_data_array.str());
        for (uint32_t value_data_inc = 0; value_data_inc < XR_UUID_SIZE; ++value_data_inc) {
            std::string data_array_prefix = data_prefix;
            data_array_prefix += "[";
            data_array_prefix += std::to_string(value_data_inc);
            data_array_prefix += "]";
            std::ostringstream oss_data;
            oss_data << "0x" << std::hex << (value->data[value_data_inc]);
            contents.emplace_back("uint8_t", data_array_prefix, oss_data.str());
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpacesLocateInfo* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        std::string spacecount_prefix = prefix;
        spacecount_prefix += "spaceCount";
        std::ostringstream oss_spaceCount;
        oss_spaceCount << "0x" << std::hex << (value->spaceCount);
        contents.emplace_back("uint32_t", spacecount_prefix, oss_spaceCount.str());
        std::string spaces_prefix = prefix;
        spaces_prefix += "spaces";
        std::ostringstream oss_spaces_array;
        oss_spaces_array << std::hex << reinterpret_cast<const void*>(value->spaces);
        contents.emplace_back("const XrSpace*", spaces_prefix, oss_spaces_array.str());
        for (uint32_t value_spaces_inc = 0; value_spaces_inc < value->spaceCount; ++value_spaces_inc) {
            std::string spaces_array_prefix = spaces_prefix;
            spaces_array_prefix += "[";
            spaces_array_prefix += std::to_string(value_spaces_inc);
            spaces_array_prefix += "]";
            std::ostringstream oss_spaces;
            oss_spaces << std::hex << reinterpret_cast<const void*>(value->spaces[value_spaces_inc]);
            contents.emplace_back("const XrSpace*", spaces_array_prefix, oss_spaces.str());
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceLocationData* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string locationflags_prefix = prefix;
        locationflags_prefix += "locationFlags";
        contents.emplace_back("XrSpaceLocationFlags", locationflags_prefix, std::to_string(value->locationFlags));
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceLocations* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string locationcount_prefix = prefix;
        locationcount_prefix += "locationCount";
        std::ostringstream oss_locationCount;
        oss_locationCount << "0x" << std::hex << (value->locationCount);
        contents.emplace_back("uint32_t", locationcount_prefix, oss_locationCount.str());
        std::string locations_prefix = prefix;
        locations_prefix += "locations";
        std::ostringstream oss_locations;
        oss_locations << std::hex << reinterpret_cast<const void*>(value->locations);
        contents.emplace_back("XrSpaceLocationData*", locations_prefix, oss_locations.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceVelocityData* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string velocityflags_prefix = prefix;
        velocityflags_prefix += "velocityFlags";
        contents.emplace_back("XrSpaceVelocityFlags", velocityflags_prefix, std::to_string(value->velocityFlags));
        std::string linearvelocity_prefix = prefix;
        linearvelocity_prefix += "linearVelocity";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->linearVelocity, linearvelocity_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string angularvelocity_prefix = prefix;
        angularvelocity_prefix += "angularVelocity";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->angularVelocity, angularvelocity_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceVelocities* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string velocitycount_prefix = prefix;
        velocitycount_prefix += "velocityCount";
        std::ostringstream oss_velocityCount;
        oss_velocityCount << "0x" << std::hex << (value->velocityCount);
        contents.emplace_back("uint32_t", velocitycount_prefix, oss_velocityCount.str());
        std::string velocities_prefix = prefix;
        velocities_prefix += "velocities";
        std::ostringstream oss_velocities;
        oss_velocities << std::hex << reinterpret_cast<const void*>(value->velocities);
        contents.emplace_back("XrSpaceVelocityData*", velocities_prefix, oss_velocities.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerCubeKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string layerflags_prefix = prefix;
        layerflags_prefix += "layerFlags";
        contents.emplace_back("XrCompositionLayerFlags", layerflags_prefix, std::to_string(value->layerFlags));
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string eyevisibility_prefix = prefix;
        eyevisibility_prefix += "eyeVisibility";
        contents.emplace_back("XrEyeVisibility", eyevisibility_prefix, std::to_string(value->eyeVisibility));
        std::string swapchain_prefix = prefix;
        swapchain_prefix += "swapchain";
        std::ostringstream oss_swapchain;
        oss_swapchain << std::hex << reinterpret_cast<const void*>(value->swapchain);
        contents.emplace_back("XrSwapchain", swapchain_prefix, oss_swapchain.str());
        std::string imagearrayindex_prefix = prefix;
        imagearrayindex_prefix += "imageArrayIndex";
        std::ostringstream oss_imageArrayIndex;
        oss_imageArrayIndex << "0x" << std::hex << (value->imageArrayIndex);
        contents.emplace_back("uint32_t", imagearrayindex_prefix, oss_imageArrayIndex.str());
        std::string orientation_prefix = prefix;
        orientation_prefix += "orientation";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->orientation, orientation_prefix, "XrQuaternionf", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

#if defined(XR_USE_PLATFORM_ANDROID)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrInstanceCreateInfoAndroidKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string applicationvm_prefix = prefix;
        applicationvm_prefix += "applicationVM";
        std::ostringstream oss_applicationVM;
        oss_applicationVM << std::hex << reinterpret_cast<const void*>(value->applicationVM);
        contents.emplace_back("void* XR_MAY_ALIAS", applicationvm_prefix, oss_applicationVM.str());
        std::string applicationactivity_prefix = prefix;
        applicationactivity_prefix += "applicationActivity";
        std::ostringstream oss_applicationActivity;
        oss_applicationActivity << std::hex << reinterpret_cast<const void*>(value->applicationActivity);
        contents.emplace_back("void* XR_MAY_ALIAS", applicationactivity_prefix, oss_applicationActivity.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_PLATFORM_ANDROID)

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerDepthInfoKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string subimage_prefix = prefix;
        subimage_prefix += "subImage";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->subImage, subimage_prefix, "XrSwapchainSubImage", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string mindepth_prefix = prefix;
        mindepth_prefix += "minDepth";
        std::ostringstream oss_minDepth;
        oss_minDepth << std::setprecision(32) << (value->minDepth);
        contents.emplace_back("float", mindepth_prefix, oss_minDepth.str());
        std::string maxdepth_prefix = prefix;
        maxdepth_prefix += "maxDepth";
        std::ostringstream oss_maxDepth;
        oss_maxDepth << std::setprecision(32) << (value->maxDepth);
        contents.emplace_back("float", maxdepth_prefix, oss_maxDepth.str());
        std::string nearz_prefix = prefix;
        nearz_prefix += "nearZ";
        std::ostringstream oss_nearZ;
        oss_nearZ << std::setprecision(32) << (value->nearZ);
        contents.emplace_back("float", nearz_prefix, oss_nearZ.str());
        std::string farz_prefix = prefix;
        farz_prefix += "farZ";
        std::ostringstream oss_farZ;
        oss_farZ << std::setprecision(32) << (value->farZ);
        contents.emplace_back("float", farz_prefix, oss_farZ.str());
        return true;
    } catch(...) {
    }
    return false;
}

#if defined(XR_USE_GRAPHICS_API_VULKAN)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVulkanSwapchainFormatListCreateInfoKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string viewformatcount_prefix = prefix;
        viewformatcount_prefix += "viewFormatCount";
        std::ostringstream oss_viewFormatCount;
        oss_viewFormatCount << "0x" << std::hex << (value->viewFormatCount);
        contents.emplace_back("uint32_t", viewformatcount_prefix, oss_viewFormatCount.str());
        std::string viewformats_prefix = prefix;
        viewformats_prefix += "viewFormats";
        std::ostringstream oss_viewFormats_array;
        oss_viewFormats_array << std::hex << reinterpret_cast<const void*>(value->viewFormats);
        contents.emplace_back("const VkFormat*", viewformats_prefix, oss_viewFormats_array.str());
        for (uint32_t value_viewformats_inc = 0; value_viewformats_inc < value->viewFormatCount; ++value_viewformats_inc) {
            std::string viewformats_array_prefix = viewformats_prefix;
            viewformats_array_prefix += "[";
            viewformats_array_prefix += std::to_string(value_viewformats_inc);
            viewformats_array_prefix += "]";
            std::ostringstream oss_viewFormats;
            oss_viewFormats << std::hex << reinterpret_cast<const void*>(value->viewFormats[value_viewformats_inc]);
            contents.emplace_back("const VkFormat*", viewformats_array_prefix, oss_viewFormats.str());
        }
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerCylinderKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string layerflags_prefix = prefix;
        layerflags_prefix += "layerFlags";
        contents.emplace_back("XrCompositionLayerFlags", layerflags_prefix, std::to_string(value->layerFlags));
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string eyevisibility_prefix = prefix;
        eyevisibility_prefix += "eyeVisibility";
        contents.emplace_back("XrEyeVisibility", eyevisibility_prefix, std::to_string(value->eyeVisibility));
        std::string subimage_prefix = prefix;
        subimage_prefix += "subImage";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->subImage, subimage_prefix, "XrSwapchainSubImage", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string radius_prefix = prefix;
        radius_prefix += "radius";
        std::ostringstream oss_radius;
        oss_radius << std::setprecision(32) << (value->radius);
        contents.emplace_back("float", radius_prefix, oss_radius.str());
        std::string centralangle_prefix = prefix;
        centralangle_prefix += "centralAngle";
        std::ostringstream oss_centralAngle;
        oss_centralAngle << std::setprecision(32) << (value->centralAngle);
        contents.emplace_back("float", centralangle_prefix, oss_centralAngle.str());
        std::string aspectratio_prefix = prefix;
        aspectratio_prefix += "aspectRatio";
        std::ostringstream oss_aspectRatio;
        oss_aspectRatio << std::setprecision(32) << (value->aspectRatio);
        contents.emplace_back("float", aspectratio_prefix, oss_aspectRatio.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerEquirectKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string layerflags_prefix = prefix;
        layerflags_prefix += "layerFlags";
        contents.emplace_back("XrCompositionLayerFlags", layerflags_prefix, std::to_string(value->layerFlags));
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string eyevisibility_prefix = prefix;
        eyevisibility_prefix += "eyeVisibility";
        contents.emplace_back("XrEyeVisibility", eyevisibility_prefix, std::to_string(value->eyeVisibility));
        std::string subimage_prefix = prefix;
        subimage_prefix += "subImage";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->subImage, subimage_prefix, "XrSwapchainSubImage", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string radius_prefix = prefix;
        radius_prefix += "radius";
        std::ostringstream oss_radius;
        oss_radius << std::setprecision(32) << (value->radius);
        contents.emplace_back("float", radius_prefix, oss_radius.str());
        std::string scale_prefix = prefix;
        scale_prefix += "scale";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->scale, scale_prefix, "XrVector2f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string bias_prefix = prefix;
        bias_prefix += "bias";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->bias, bias_prefix, "XrVector2f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsBindingOpenGLWin32KHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string hdc_prefix = prefix;
        hdc_prefix += "hDC";
        std::ostringstream oss_hDC;
        oss_hDC << std::hex << reinterpret_cast<const void*>(value->hDC);
        contents.emplace_back("HDC", hdc_prefix, oss_hDC.str());
        std::string hglrc_prefix = prefix;
        hglrc_prefix += "hGLRC";
        std::ostringstream oss_hGLRC;
        oss_hGLRC << std::hex << reinterpret_cast<const void*>(value->hGLRC);
        contents.emplace_back("HGLRC", hglrc_prefix, oss_hGLRC.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)

#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsBindingOpenGLXlibKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string xdisplay_prefix = prefix;
        xdisplay_prefix += "xDisplay";
        std::ostringstream oss_xDisplay;
        oss_xDisplay << std::hex << reinterpret_cast<const void*>(value->xDisplay);
        contents.emplace_back("Display*", xdisplay_prefix, oss_xDisplay.str());
        std::string visualid_prefix = prefix;
        visualid_prefix += "visualid";
        std::ostringstream oss_visualid;
        oss_visualid << "0x" << std::hex << (value->visualid);
        contents.emplace_back("uint32_t", visualid_prefix, oss_visualid.str());
        std::string glxfbconfig_prefix = prefix;
        glxfbconfig_prefix += "glxFBConfig";
        std::ostringstream oss_glxFBConfig;
        oss_glxFBConfig << std::hex << reinterpret_cast<const void*>(value->glxFBConfig);
        contents.emplace_back("GLXFBConfig", glxfbconfig_prefix, oss_glxFBConfig.str());
        std::string glxdrawable_prefix = prefix;
        glxdrawable_prefix += "glxDrawable";
        std::ostringstream oss_glxDrawable;
        oss_glxDrawable << std::hex << reinterpret_cast<const void*>(value->glxDrawable);
        contents.emplace_back("GLXDrawable", glxdrawable_prefix, oss_glxDrawable.str());
        std::string glxcontext_prefix = prefix;
        glxcontext_prefix += "glxContext";
        std::ostringstream oss_glxContext;
        oss_glxContext << std::hex << reinterpret_cast<const void*>(value->glxContext);
        contents.emplace_back("GLXContext", glxcontext_prefix, oss_glxContext.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)

#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsBindingOpenGLXcbKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string connection_prefix = prefix;
        connection_prefix += "connection";
        std::ostringstream oss_connection;
        oss_connection << std::hex << reinterpret_cast<const void*>(value->connection);
        contents.emplace_back("xcb_connection_t*", connection_prefix, oss_connection.str());
        std::string screennumber_prefix = prefix;
        screennumber_prefix += "screenNumber";
        std::ostringstream oss_screenNumber;
        oss_screenNumber << "0x" << std::hex << (value->screenNumber);
        contents.emplace_back("uint32_t", screennumber_prefix, oss_screenNumber.str());
        std::string fbconfigid_prefix = prefix;
        fbconfigid_prefix += "fbconfigid";
        std::ostringstream oss_fbconfigid;
        oss_fbconfigid << std::hex << reinterpret_cast<const void*>(value->fbconfigid);
        contents.emplace_back("xcb_glx_fbconfig_t", fbconfigid_prefix, oss_fbconfigid.str());
        std::string visualid_prefix = prefix;
        visualid_prefix += "visualid";
        std::ostringstream oss_visualid;
        oss_visualid << std::hex << reinterpret_cast<const void*>(value->visualid);
        contents.emplace_back("xcb_visualid_t", visualid_prefix, oss_visualid.str());
        std::string glxdrawable_prefix = prefix;
        glxdrawable_prefix += "glxDrawable";
        std::ostringstream oss_glxDrawable;
        oss_glxDrawable << std::hex << reinterpret_cast<const void*>(value->glxDrawable);
        contents.emplace_back("xcb_glx_drawable_t", glxdrawable_prefix, oss_glxDrawable.str());
        std::string glxcontext_prefix = prefix;
        glxcontext_prefix += "glxContext";
        std::ostringstream oss_glxContext;
        oss_glxContext << std::hex << reinterpret_cast<const void*>(value->glxContext);
        contents.emplace_back("xcb_glx_context_t", glxcontext_prefix, oss_glxContext.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)

#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsBindingOpenGLWaylandKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string display_prefix = prefix;
        display_prefix += "display";
        std::ostringstream oss_display;
        oss_display << std::hex << reinterpret_cast<const void*>(value->display);
        contents.emplace_back("struct wl_display*", display_prefix, oss_display.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)

#if defined(XR_USE_GRAPHICS_API_OPENGL)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainImageOpenGLKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string image_prefix = prefix;
        image_prefix += "image";
        std::ostringstream oss_image;
        oss_image << "0x" << std::hex << (value->image);
        contents.emplace_back("uint32_t", image_prefix, oss_image.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_OPENGL)

#if defined(XR_USE_GRAPHICS_API_OPENGL)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsRequirementsOpenGLKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string minapiversionsupported_prefix = prefix;
        minapiversionsupported_prefix += "minApiVersionSupported";
        std::ostringstream oss_minApiVersionSupported;
        oss_minApiVersionSupported << "0x" << std::hex << (value->minApiVersionSupported);
        contents.emplace_back("XrVersion", minapiversionsupported_prefix, oss_minApiVersionSupported.str());
        std::string maxapiversionsupported_prefix = prefix;
        maxapiversionsupported_prefix += "maxApiVersionSupported";
        std::ostringstream oss_maxApiVersionSupported;
        oss_maxApiVersionSupported << "0x" << std::hex << (value->maxApiVersionSupported);
        contents.emplace_back("XrVersion", maxapiversionsupported_prefix, oss_maxApiVersionSupported.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_OPENGL)

#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsBindingOpenGLESAndroidKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string display_prefix = prefix;
        display_prefix += "display";
        std::ostringstream oss_display;
        oss_display << std::hex << reinterpret_cast<const void*>(value->display);
        contents.emplace_back("EGLDisplay", display_prefix, oss_display.str());
        std::string config_prefix = prefix;
        config_prefix += "config";
        std::ostringstream oss_config;
        oss_config << std::hex << reinterpret_cast<const void*>(value->config);
        contents.emplace_back("EGLConfig", config_prefix, oss_config.str());
        std::string context_prefix = prefix;
        context_prefix += "context";
        std::ostringstream oss_context;
        oss_context << std::hex << reinterpret_cast<const void*>(value->context);
        contents.emplace_back("EGLContext", context_prefix, oss_context.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)

#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainImageOpenGLESKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string image_prefix = prefix;
        image_prefix += "image";
        std::ostringstream oss_image;
        oss_image << "0x" << std::hex << (value->image);
        contents.emplace_back("uint32_t", image_prefix, oss_image.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)

#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsRequirementsOpenGLESKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string minapiversionsupported_prefix = prefix;
        minapiversionsupported_prefix += "minApiVersionSupported";
        std::ostringstream oss_minApiVersionSupported;
        oss_minApiVersionSupported << "0x" << std::hex << (value->minApiVersionSupported);
        contents.emplace_back("XrVersion", minapiversionsupported_prefix, oss_minApiVersionSupported.str());
        std::string maxapiversionsupported_prefix = prefix;
        maxapiversionsupported_prefix += "maxApiVersionSupported";
        std::ostringstream oss_maxApiVersionSupported;
        oss_maxApiVersionSupported << "0x" << std::hex << (value->maxApiVersionSupported);
        contents.emplace_back("XrVersion", maxapiversionsupported_prefix, oss_maxApiVersionSupported.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)

#if defined(XR_USE_GRAPHICS_API_VULKAN)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsBindingVulkanKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string instance_prefix = prefix;
        instance_prefix += "instance";
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(value->instance);
        contents.emplace_back("VkInstance", instance_prefix, oss_instance.str());
        std::string physicaldevice_prefix = prefix;
        physicaldevice_prefix += "physicalDevice";
        std::ostringstream oss_physicalDevice;
        oss_physicalDevice << std::hex << reinterpret_cast<const void*>(value->physicalDevice);
        contents.emplace_back("VkPhysicalDevice", physicaldevice_prefix, oss_physicalDevice.str());
        std::string device_prefix = prefix;
        device_prefix += "device";
        std::ostringstream oss_device;
        oss_device << std::hex << reinterpret_cast<const void*>(value->device);
        contents.emplace_back("VkDevice", device_prefix, oss_device.str());
        std::string queuefamilyindex_prefix = prefix;
        queuefamilyindex_prefix += "queueFamilyIndex";
        std::ostringstream oss_queueFamilyIndex;
        oss_queueFamilyIndex << "0x" << std::hex << (value->queueFamilyIndex);
        contents.emplace_back("uint32_t", queuefamilyindex_prefix, oss_queueFamilyIndex.str());
        std::string queueindex_prefix = prefix;
        queueindex_prefix += "queueIndex";
        std::ostringstream oss_queueIndex;
        oss_queueIndex << "0x" << std::hex << (value->queueIndex);
        contents.emplace_back("uint32_t", queueindex_prefix, oss_queueIndex.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

#if defined(XR_USE_GRAPHICS_API_VULKAN)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainImageVulkanKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string image_prefix = prefix;
        image_prefix += "image";
        std::ostringstream oss_image;
        oss_image << std::hex << reinterpret_cast<const void*>(value->image);
        contents.emplace_back("VkImage", image_prefix, oss_image.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

#if defined(XR_USE_GRAPHICS_API_VULKAN)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsRequirementsVulkanKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string minapiversionsupported_prefix = prefix;
        minapiversionsupported_prefix += "minApiVersionSupported";
        std::ostringstream oss_minApiVersionSupported;
        oss_minApiVersionSupported << "0x" << std::hex << (value->minApiVersionSupported);
        contents.emplace_back("XrVersion", minapiversionsupported_prefix, oss_minApiVersionSupported.str());
        std::string maxapiversionsupported_prefix = prefix;
        maxapiversionsupported_prefix += "maxApiVersionSupported";
        std::ostringstream oss_maxApiVersionSupported;
        oss_maxApiVersionSupported << "0x" << std::hex << (value->maxApiVersionSupported);
        contents.emplace_back("XrVersion", maxapiversionsupported_prefix, oss_maxApiVersionSupported.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

#if defined(XR_USE_GRAPHICS_API_D3D11)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsBindingD3D11KHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string device_prefix = prefix;
        device_prefix += "device";
        std::ostringstream oss_device;
        oss_device << std::hex << reinterpret_cast<const void*>(value->device);
        contents.emplace_back("ID3D11Device*", device_prefix, oss_device.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_D3D11)

#if defined(XR_USE_GRAPHICS_API_D3D11)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainImageD3D11KHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string texture_prefix = prefix;
        texture_prefix += "texture";
        std::ostringstream oss_texture;
        oss_texture << std::hex << reinterpret_cast<const void*>(value->texture);
        contents.emplace_back("ID3D11Texture2D*", texture_prefix, oss_texture.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_D3D11)

#if defined(XR_USE_GRAPHICS_API_D3D11)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsRequirementsD3D11KHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string adapterluid_prefix = prefix;
        adapterluid_prefix += "adapterLuid";
        {
            std::ostringstream oss_adapterLuid;
            oss_adapterLuid << std::uppercase;
            oss_adapterLuid.width(8);
            oss_adapterLuid << std::hex << value->adapterLuid.LowPart;
            oss_adapterLuid << std::hex << value->adapterLuid.HighPart;
            oss_adapterLuid << std::nouppercase;
            contents.emplace_back("LUID", adapterluid_prefix, oss_adapterLuid.str());
        }
        std::string minfeaturelevel_prefix = prefix;
        minfeaturelevel_prefix += "minFeatureLevel";
        contents.emplace_back("D3D_FEATURE_LEVEL", minfeaturelevel_prefix, std::to_string(value->minFeatureLevel));
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_D3D11)

#if defined(XR_USE_GRAPHICS_API_D3D12)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsBindingD3D12KHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string device_prefix = prefix;
        device_prefix += "device";
        std::ostringstream oss_device;
        oss_device << std::hex << reinterpret_cast<const void*>(value->device);
        contents.emplace_back("ID3D12Device*", device_prefix, oss_device.str());
        std::string queue_prefix = prefix;
        queue_prefix += "queue";
        std::ostringstream oss_queue;
        oss_queue << std::hex << reinterpret_cast<const void*>(value->queue);
        contents.emplace_back("ID3D12CommandQueue*", queue_prefix, oss_queue.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_D3D12)

#if defined(XR_USE_GRAPHICS_API_D3D12)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainImageD3D12KHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string texture_prefix = prefix;
        texture_prefix += "texture";
        std::ostringstream oss_texture;
        oss_texture << std::hex << reinterpret_cast<const void*>(value->texture);
        contents.emplace_back("ID3D12Resource*", texture_prefix, oss_texture.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_D3D12)

#if defined(XR_USE_GRAPHICS_API_D3D12)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsRequirementsD3D12KHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string adapterluid_prefix = prefix;
        adapterluid_prefix += "adapterLuid";
        {
            std::ostringstream oss_adapterLuid;
            oss_adapterLuid << std::uppercase;
            oss_adapterLuid.width(8);
            oss_adapterLuid << std::hex << value->adapterLuid.LowPart;
            oss_adapterLuid << std::hex << value->adapterLuid.HighPart;
            oss_adapterLuid << std::nouppercase;
            contents.emplace_back("LUID", adapterluid_prefix, oss_adapterLuid.str());
        }
        std::string minfeaturelevel_prefix = prefix;
        minfeaturelevel_prefix += "minFeatureLevel";
        contents.emplace_back("D3D_FEATURE_LEVEL", minfeaturelevel_prefix, std::to_string(value->minFeatureLevel));
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_D3D12)

#if defined(XR_USE_GRAPHICS_API_METAL)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsBindingMetalKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string commandqueue_prefix = prefix;
        commandqueue_prefix += "commandQueue";
        std::ostringstream oss_commandQueue;
        oss_commandQueue << std::hex << reinterpret_cast<const void*>(value->commandQueue);
        contents.emplace_back("void* XR_MAY_ALIAS", commandqueue_prefix, oss_commandQueue.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_METAL)

#if defined(XR_USE_GRAPHICS_API_METAL)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainImageMetalKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string texture_prefix = prefix;
        texture_prefix += "texture";
        std::ostringstream oss_texture;
        oss_texture << std::hex << reinterpret_cast<const void*>(value->texture);
        contents.emplace_back("void* XR_MAY_ALIAS", texture_prefix, oss_texture.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_METAL)

#if defined(XR_USE_GRAPHICS_API_METAL)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsRequirementsMetalKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string metaldevice_prefix = prefix;
        metaldevice_prefix += "metalDevice";
        std::ostringstream oss_metalDevice;
        oss_metalDevice << std::hex << reinterpret_cast<const void*>(value->metalDevice);
        contents.emplace_back("void* XR_MAY_ALIAS", metaldevice_prefix, oss_metalDevice.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_METAL)

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVisibilityMaskKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string vertexcapacityinput_prefix = prefix;
        vertexcapacityinput_prefix += "vertexCapacityInput";
        std::ostringstream oss_vertexCapacityInput;
        oss_vertexCapacityInput << "0x" << std::hex << (value->vertexCapacityInput);
        contents.emplace_back("uint32_t", vertexcapacityinput_prefix, oss_vertexCapacityInput.str());
        std::string vertexcountoutput_prefix = prefix;
        vertexcountoutput_prefix += "vertexCountOutput";
        std::ostringstream oss_vertexCountOutput;
        oss_vertexCountOutput << "0x" << std::hex << (value->vertexCountOutput);
        contents.emplace_back("uint32_t", vertexcountoutput_prefix, oss_vertexCountOutput.str());
        std::string vertices_prefix = prefix;
        vertices_prefix += "vertices";
        std::ostringstream oss_vertices;
        oss_vertices << std::hex << reinterpret_cast<const void*>(value->vertices);
        contents.emplace_back("XrVector2f*", vertices_prefix, oss_vertices.str());
        std::string indexcapacityinput_prefix = prefix;
        indexcapacityinput_prefix += "indexCapacityInput";
        std::ostringstream oss_indexCapacityInput;
        oss_indexCapacityInput << "0x" << std::hex << (value->indexCapacityInput);
        contents.emplace_back("uint32_t", indexcapacityinput_prefix, oss_indexCapacityInput.str());
        std::string indexcountoutput_prefix = prefix;
        indexcountoutput_prefix += "indexCountOutput";
        std::ostringstream oss_indexCountOutput;
        oss_indexCountOutput << "0x" << std::hex << (value->indexCountOutput);
        contents.emplace_back("uint32_t", indexcountoutput_prefix, oss_indexCountOutput.str());
        std::string indices_prefix = prefix;
        indices_prefix += "indices";
        std::ostringstream oss_indices;
        oss_indices << "0x" << std::hex << (value->indices);
        contents.emplace_back("uint32_t*", indices_prefix, oss_indices.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataVisibilityMaskChangedKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string session_prefix = prefix;
        session_prefix += "session";
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(value->session);
        contents.emplace_back("XrSession", session_prefix, oss_session.str());
        std::string viewconfigurationtype_prefix = prefix;
        viewconfigurationtype_prefix += "viewConfigurationType";
        contents.emplace_back("XrViewConfigurationType", viewconfigurationtype_prefix, std::to_string(value->viewConfigurationType));
        std::string viewindex_prefix = prefix;
        viewindex_prefix += "viewIndex";
        std::ostringstream oss_viewIndex;
        oss_viewIndex << "0x" << std::hex << (value->viewIndex);
        contents.emplace_back("uint32_t", viewindex_prefix, oss_viewIndex.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerColorScaleBiasKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string colorscale_prefix = prefix;
        colorscale_prefix += "colorScale";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->colorScale, colorscale_prefix, "XrColor4f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string colorbias_prefix = prefix;
        colorbias_prefix += "colorBias";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->colorBias, colorbias_prefix, "XrColor4f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrLoaderInitInfoBaseHeaderKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
#if defined(XR_USE_PLATFORM_ANDROID)
        if (value->type == XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR) {
            const XrLoaderInitInfoAndroidKHR* new_value = reinterpret_cast<const XrLoaderInitInfoAndroidKHR*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
#endif // defined(XR_USE_PLATFORM_ANDROID)
        // Fallback path - Just output generic information about the base struct
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

#if defined(XR_USE_PLATFORM_ANDROID)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrLoaderInitInfoAndroidKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string applicationvm_prefix = prefix;
        applicationvm_prefix += "applicationVM";
        std::ostringstream oss_applicationVM;
        oss_applicationVM << std::hex << reinterpret_cast<const void*>(value->applicationVM);
        contents.emplace_back("void* XR_MAY_ALIAS", applicationvm_prefix, oss_applicationVM.str());
        std::string applicationcontext_prefix = prefix;
        applicationcontext_prefix += "applicationContext";
        std::ostringstream oss_applicationContext;
        oss_applicationContext << std::hex << reinterpret_cast<const void*>(value->applicationContext);
        contents.emplace_back("void* XR_MAY_ALIAS", applicationcontext_prefix, oss_applicationContext.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_PLATFORM_ANDROID)

#if defined(XR_USE_GRAPHICS_API_VULKAN)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVulkanInstanceCreateInfoKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string systemid_prefix = prefix;
        systemid_prefix += "systemId";
        contents.emplace_back("XrSystemId", systemid_prefix, std::to_string(value->systemId));
        std::string createflags_prefix = prefix;
        createflags_prefix += "createFlags";
        contents.emplace_back("XrVulkanInstanceCreateFlagsKHR", createflags_prefix, std::to_string(value->createFlags));
        std::string pfngetinstanceprocaddr_prefix = prefix;
        pfngetinstanceprocaddr_prefix += "pfnGetInstanceProcAddr";
        std::ostringstream oss_pfnGetInstanceProcAddr;
        oss_pfnGetInstanceProcAddr << std::hex << reinterpret_cast<const void*>(value->pfnGetInstanceProcAddr);
        contents.emplace_back("PFN_vkGetInstanceProcAddr", pfngetinstanceprocaddr_prefix, oss_pfnGetInstanceProcAddr.str());
        std::string vulkancreateinfo_prefix = prefix;
        vulkancreateinfo_prefix += "vulkanCreateInfo";
        std::ostringstream oss_vulkanCreateInfo;
        oss_vulkanCreateInfo << std::hex << reinterpret_cast<const void*>(value->vulkanCreateInfo);
        contents.emplace_back("const VkInstanceCreateInfo*", vulkancreateinfo_prefix, oss_vulkanCreateInfo.str());
        std::string vulkanallocator_prefix = prefix;
        vulkanallocator_prefix += "vulkanAllocator";
        if (nullptr == value->vulkanAllocator) {
            std::ostringstream oss_vulkanAllocator;
            oss_vulkanAllocator << std::hex << reinterpret_cast<const void*>(value->vulkanAllocator);
            contents.emplace_back("const VkAllocationCallbacks*", vulkanallocator_prefix, oss_vulkanAllocator.str());
        } else {
            std::ostringstream oss_vulkanAllocator;
            oss_vulkanAllocator << std::hex << reinterpret_cast<const void*>(value->vulkanAllocator);
            contents.emplace_back("const VkAllocationCallbacks*", vulkanallocator_prefix, oss_vulkanAllocator.str());
        }
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

#if defined(XR_USE_GRAPHICS_API_VULKAN)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVulkanDeviceCreateInfoKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string systemid_prefix = prefix;
        systemid_prefix += "systemId";
        contents.emplace_back("XrSystemId", systemid_prefix, std::to_string(value->systemId));
        std::string createflags_prefix = prefix;
        createflags_prefix += "createFlags";
        contents.emplace_back("XrVulkanDeviceCreateFlagsKHR", createflags_prefix, std::to_string(value->createFlags));
        std::string pfngetinstanceprocaddr_prefix = prefix;
        pfngetinstanceprocaddr_prefix += "pfnGetInstanceProcAddr";
        std::ostringstream oss_pfnGetInstanceProcAddr;
        oss_pfnGetInstanceProcAddr << std::hex << reinterpret_cast<const void*>(value->pfnGetInstanceProcAddr);
        contents.emplace_back("PFN_vkGetInstanceProcAddr", pfngetinstanceprocaddr_prefix, oss_pfnGetInstanceProcAddr.str());
        std::string vulkanphysicaldevice_prefix = prefix;
        vulkanphysicaldevice_prefix += "vulkanPhysicalDevice";
        std::ostringstream oss_vulkanPhysicalDevice;
        oss_vulkanPhysicalDevice << std::hex << reinterpret_cast<const void*>(value->vulkanPhysicalDevice);
        contents.emplace_back("VkPhysicalDevice", vulkanphysicaldevice_prefix, oss_vulkanPhysicalDevice.str());
        std::string vulkancreateinfo_prefix = prefix;
        vulkancreateinfo_prefix += "vulkanCreateInfo";
        std::ostringstream oss_vulkanCreateInfo;
        oss_vulkanCreateInfo << std::hex << reinterpret_cast<const void*>(value->vulkanCreateInfo);
        contents.emplace_back("const VkDeviceCreateInfo*", vulkancreateinfo_prefix, oss_vulkanCreateInfo.str());
        std::string vulkanallocator_prefix = prefix;
        vulkanallocator_prefix += "vulkanAllocator";
        if (nullptr == value->vulkanAllocator) {
            std::ostringstream oss_vulkanAllocator;
            oss_vulkanAllocator << std::hex << reinterpret_cast<const void*>(value->vulkanAllocator);
            contents.emplace_back("const VkAllocationCallbacks*", vulkanallocator_prefix, oss_vulkanAllocator.str());
        } else {
            std::ostringstream oss_vulkanAllocator;
            oss_vulkanAllocator << std::hex << reinterpret_cast<const void*>(value->vulkanAllocator);
            contents.emplace_back("const VkAllocationCallbacks*", vulkanallocator_prefix, oss_vulkanAllocator.str());
        }
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

#if defined(XR_USE_GRAPHICS_API_VULKAN)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVulkanGraphicsDeviceGetInfoKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string systemid_prefix = prefix;
        systemid_prefix += "systemId";
        contents.emplace_back("XrSystemId", systemid_prefix, std::to_string(value->systemId));
        std::string vulkaninstance_prefix = prefix;
        vulkaninstance_prefix += "vulkanInstance";
        std::ostringstream oss_vulkanInstance;
        oss_vulkanInstance << std::hex << reinterpret_cast<const void*>(value->vulkanInstance);
        contents.emplace_back("VkInstance", vulkaninstance_prefix, oss_vulkanInstance.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerEquirect2KHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string layerflags_prefix = prefix;
        layerflags_prefix += "layerFlags";
        contents.emplace_back("XrCompositionLayerFlags", layerflags_prefix, std::to_string(value->layerFlags));
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string eyevisibility_prefix = prefix;
        eyevisibility_prefix += "eyeVisibility";
        contents.emplace_back("XrEyeVisibility", eyevisibility_prefix, std::to_string(value->eyeVisibility));
        std::string subimage_prefix = prefix;
        subimage_prefix += "subImage";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->subImage, subimage_prefix, "XrSwapchainSubImage", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string radius_prefix = prefix;
        radius_prefix += "radius";
        std::ostringstream oss_radius;
        oss_radius << std::setprecision(32) << (value->radius);
        contents.emplace_back("float", radius_prefix, oss_radius.str());
        std::string centralhorizontalangle_prefix = prefix;
        centralhorizontalangle_prefix += "centralHorizontalAngle";
        std::ostringstream oss_centralHorizontalAngle;
        oss_centralHorizontalAngle << std::setprecision(32) << (value->centralHorizontalAngle);
        contents.emplace_back("float", centralhorizontalangle_prefix, oss_centralHorizontalAngle.str());
        std::string upperverticalangle_prefix = prefix;
        upperverticalangle_prefix += "upperVerticalAngle";
        std::ostringstream oss_upperVerticalAngle;
        oss_upperVerticalAngle << std::setprecision(32) << (value->upperVerticalAngle);
        contents.emplace_back("float", upperverticalangle_prefix, oss_upperVerticalAngle.str());
        std::string lowerverticalangle_prefix = prefix;
        lowerverticalangle_prefix += "lowerVerticalAngle";
        std::ostringstream oss_lowerVerticalAngle;
        oss_lowerVerticalAngle << std::setprecision(32) << (value->lowerVerticalAngle);
        contents.emplace_back("float", lowerverticalangle_prefix, oss_lowerVerticalAngle.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBindingModificationBaseHeaderKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        if (value->type == XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT) {
            const XrInteractionProfileDpadBindingEXT* new_value = reinterpret_cast<const XrInteractionProfileDpadBindingEXT*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE) {
            const XrInteractionProfileAnalogThresholdVALVE* new_value = reinterpret_cast<const XrInteractionProfileAnalogThresholdVALVE*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        // Fallback path - Just output generic information about the base struct
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBindingModificationsKHR* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string bindingmodificationcount_prefix = prefix;
        bindingmodificationcount_prefix += "bindingModificationCount";
        std::ostringstream oss_bindingModificationCount;
        oss_bindingModificationCount << "0x" << std::hex << (value->bindingModificationCount);
        contents.emplace_back("uint32_t", bindingmodificationcount_prefix, oss_bindingModificationCount.str());
        std::string bindingmodifications_prefix = prefix;
        bindingmodifications_prefix += "bindingModifications";
        std::ostringstream oss_bindingModifications_array;
        oss_bindingModifications_array << std::hex << reinterpret_cast<const void*>(value->bindingModifications);
        contents.emplace_back("const XrBindingModificationBaseHeaderKHR* const*", bindingmodifications_prefix, oss_bindingModifications_array.str());
        for (uint32_t value_bindingmodifications_inc = 0; value_bindingmodifications_inc < value->bindingModificationCount; ++value_bindingmodifications_inc) {
            std::string bindingmodifications_array_prefix = bindingmodifications_prefix;
            bindingmodifications_array_prefix += "[";
            bindingmodifications_array_prefix += std::to_string(value_bindingmodifications_inc);
            bindingmodifications_array_prefix += "]";
            if (nullptr == value->bindingModifications[value_bindingmodifications_inc]) {
                std::ostringstream oss_bindingModifications;
                oss_bindingModifications << std::hex << reinterpret_cast<const void*>(value->bindingModifications[value_bindingmodifications_inc]);
                contents.emplace_back("const XrBindingModificationBaseHeaderKHR* const*", bindingmodifications_array_prefix, oss_bindingModifications.str());
            } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, value->bindingModifications[value_bindingmodifications_inc], bindingmodifications_array_prefix, "const XrBindingModificationBaseHeaderKHR* const*", true, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataPerfSettingsEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string domain_prefix = prefix;
        domain_prefix += "domain";
        contents.emplace_back("XrPerfSettingsDomainEXT", domain_prefix, std::to_string(value->domain));
        std::string subdomain_prefix = prefix;
        subdomain_prefix += "subDomain";
        contents.emplace_back("XrPerfSettingsSubDomainEXT", subdomain_prefix, std::to_string(value->subDomain));
        std::string fromlevel_prefix = prefix;
        fromlevel_prefix += "fromLevel";
        contents.emplace_back("XrPerfSettingsNotificationLevelEXT", fromlevel_prefix, std::to_string(value->fromLevel));
        std::string tolevel_prefix = prefix;
        tolevel_prefix += "toLevel";
        contents.emplace_back("XrPerfSettingsNotificationLevelEXT", tolevel_prefix, std::to_string(value->toLevel));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrDebugUtilsObjectNameInfoEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string objecttype_prefix = prefix;
        objecttype_prefix += "objectType";
        contents.emplace_back("XrObjectType", objecttype_prefix, std::to_string(value->objectType));
        std::string objecthandle_prefix = prefix;
        objecthandle_prefix += "objectHandle";
        std::ostringstream oss_objectHandle;
        oss_objectHandle << "0x" << std::hex << (value->objectHandle);
        contents.emplace_back("uint64_t", objecthandle_prefix, oss_objectHandle.str());
        std::string objectname_prefix = prefix;
        objectname_prefix += "objectName";
        if (nullptr == value->objectName) {
            std::ostringstream oss_objectName_array;
            oss_objectName_array << std::hex << reinterpret_cast<const void*>(value->objectName);
            contents.emplace_back("const char*", objectname_prefix, oss_objectName_array.str());
        } else {
            std::ostringstream oss_objectName;
            oss_objectName << std::hex << reinterpret_cast<const void*>(*value->objectName);
            contents.emplace_back("const char*", objectname_prefix, oss_objectName.str());
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrDebugUtilsLabelEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string labelname_prefix = prefix;
        labelname_prefix += "labelName";
        std::ostringstream oss_labelName;
        oss_labelName << std::hex << reinterpret_cast<const void*>(*value->labelName);
        contents.emplace_back("const char*", labelname_prefix, oss_labelName.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrDebugUtilsMessengerCallbackDataEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string messageid_prefix = prefix;
        messageid_prefix += "messageId";
        if (nullptr == value->messageId) {
            std::ostringstream oss_messageId_array;
            oss_messageId_array << std::hex << reinterpret_cast<const void*>(value->messageId);
            contents.emplace_back("const char*", messageid_prefix, oss_messageId_array.str());
        } else {
            std::ostringstream oss_messageId;
            oss_messageId << std::hex << reinterpret_cast<const void*>(*value->messageId);
            contents.emplace_back("const char*", messageid_prefix, oss_messageId.str());
        }
        std::string functionname_prefix = prefix;
        functionname_prefix += "functionName";
        if (nullptr == value->functionName) {
            std::ostringstream oss_functionName_array;
            oss_functionName_array << std::hex << reinterpret_cast<const void*>(value->functionName);
            contents.emplace_back("const char*", functionname_prefix, oss_functionName_array.str());
        } else {
            std::ostringstream oss_functionName;
            oss_functionName << std::hex << reinterpret_cast<const void*>(*value->functionName);
            contents.emplace_back("const char*", functionname_prefix, oss_functionName.str());
        }
        std::string message_prefix = prefix;
        message_prefix += "message";
        std::ostringstream oss_message;
        oss_message << std::hex << reinterpret_cast<const void*>(*value->message);
        contents.emplace_back("const char*", message_prefix, oss_message.str());
        std::string objectcount_prefix = prefix;
        objectcount_prefix += "objectCount";
        std::ostringstream oss_objectCount;
        oss_objectCount << "0x" << std::hex << (value->objectCount);
        contents.emplace_back("uint32_t", objectcount_prefix, oss_objectCount.str());
        std::string objects_prefix = prefix;
        objects_prefix += "objects";
        std::ostringstream oss_objects;
        oss_objects << std::hex << reinterpret_cast<const void*>(value->objects);
        contents.emplace_back("XrDebugUtilsObjectNameInfoEXT*", objects_prefix, oss_objects.str());
        std::string sessionlabelcount_prefix = prefix;
        sessionlabelcount_prefix += "sessionLabelCount";
        std::ostringstream oss_sessionLabelCount;
        oss_sessionLabelCount << "0x" << std::hex << (value->sessionLabelCount);
        contents.emplace_back("uint32_t", sessionlabelcount_prefix, oss_sessionLabelCount.str());
        std::string sessionlabels_prefix = prefix;
        sessionlabels_prefix += "sessionLabels";
        std::ostringstream oss_sessionLabels;
        oss_sessionLabels << std::hex << reinterpret_cast<const void*>(value->sessionLabels);
        contents.emplace_back("XrDebugUtilsLabelEXT*", sessionlabels_prefix, oss_sessionLabels.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrDebugUtilsMessengerCreateInfoEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string messageseverities_prefix = prefix;
        messageseverities_prefix += "messageSeverities";
        contents.emplace_back("XrDebugUtilsMessageSeverityFlagsEXT", messageseverities_prefix, std::to_string(value->messageSeverities));
        std::string messagetypes_prefix = prefix;
        messagetypes_prefix += "messageTypes";
        contents.emplace_back("XrDebugUtilsMessageTypeFlagsEXT", messagetypes_prefix, std::to_string(value->messageTypes));
        std::string usercallback_prefix = prefix;
        usercallback_prefix += "userCallback";
        std::ostringstream oss_userCallback;
        oss_userCallback << std::hex << reinterpret_cast<const void*>(value->userCallback);
        contents.emplace_back("PFN_xrDebugUtilsMessengerCallbackEXT", usercallback_prefix, oss_userCallback.str());
        std::string userdata_prefix = prefix;
        userdata_prefix += "userData";
        std::ostringstream oss_userData;
        oss_userData << std::hex << reinterpret_cast<const void*>(value->userData);
        contents.emplace_back("void* XR_MAY_ALIAS", userdata_prefix, oss_userData.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemEyeGazeInteractionPropertiesEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportseyegazeinteraction_prefix = prefix;
        supportseyegazeinteraction_prefix += "supportsEyeGazeInteraction";
        std::ostringstream oss_supportsEyeGazeInteraction;
        oss_supportsEyeGazeInteraction << "0x" << std::hex << (value->supportsEyeGazeInteraction);
        contents.emplace_back("XrBool32", supportseyegazeinteraction_prefix, oss_supportsEyeGazeInteraction.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEyeGazeSampleTimeEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSessionCreateInfoOverlayEXTX* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string createflags_prefix = prefix;
        createflags_prefix += "createFlags";
        contents.emplace_back("XrOverlaySessionCreateFlagsEXTX", createflags_prefix, std::to_string(value->createFlags));
        std::string sessionlayersplacement_prefix = prefix;
        sessionlayersplacement_prefix += "sessionLayersPlacement";
        std::ostringstream oss_sessionLayersPlacement;
        oss_sessionLayersPlacement << "0x" << std::hex << (value->sessionLayersPlacement);
        contents.emplace_back("uint32_t", sessionlayersplacement_prefix, oss_sessionLayersPlacement.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataMainSessionVisibilityChangedEXTX* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string visible_prefix = prefix;
        visible_prefix += "visible";
        std::ostringstream oss_visible;
        oss_visible << "0x" << std::hex << (value->visible);
        contents.emplace_back("XrBool32", visible_prefix, oss_visible.str());
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrOverlayMainSessionFlagsEXTX", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorCreateInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorSpaceCreateInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string anchor_prefix = prefix;
        anchor_prefix += "anchor";
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(value->anchor);
        contents.emplace_back("XrSpatialAnchorMSFT", anchor_prefix, oss_anchor.str());
        std::string poseinanchorspace_prefix = prefix;
        poseinanchorspace_prefix += "poseInAnchorSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInAnchorSpace, poseinanchorspace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerImageLayoutFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrCompositionLayerImageLayoutFlagsFB", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerAlphaBlendFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string srcfactorcolor_prefix = prefix;
        srcfactorcolor_prefix += "srcFactorColor";
        contents.emplace_back("XrBlendFactorFB", srcfactorcolor_prefix, std::to_string(value->srcFactorColor));
        std::string dstfactorcolor_prefix = prefix;
        dstfactorcolor_prefix += "dstFactorColor";
        contents.emplace_back("XrBlendFactorFB", dstfactorcolor_prefix, std::to_string(value->dstFactorColor));
        std::string srcfactoralpha_prefix = prefix;
        srcfactoralpha_prefix += "srcFactorAlpha";
        contents.emplace_back("XrBlendFactorFB", srcfactoralpha_prefix, std::to_string(value->srcFactorAlpha));
        std::string dstfactoralpha_prefix = prefix;
        dstfactoralpha_prefix += "dstFactorAlpha";
        contents.emplace_back("XrBlendFactorFB", dstfactoralpha_prefix, std::to_string(value->dstFactorAlpha));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrViewConfigurationDepthRangeEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string recommendednearz_prefix = prefix;
        recommendednearz_prefix += "recommendedNearZ";
        std::ostringstream oss_recommendedNearZ;
        oss_recommendedNearZ << std::setprecision(32) << (value->recommendedNearZ);
        contents.emplace_back("float", recommendednearz_prefix, oss_recommendedNearZ.str());
        std::string minnearz_prefix = prefix;
        minnearz_prefix += "minNearZ";
        std::ostringstream oss_minNearZ;
        oss_minNearZ << std::setprecision(32) << (value->minNearZ);
        contents.emplace_back("float", minnearz_prefix, oss_minNearZ.str());
        std::string recommendedfarz_prefix = prefix;
        recommendedfarz_prefix += "recommendedFarZ";
        std::ostringstream oss_recommendedFarZ;
        oss_recommendedFarZ << std::setprecision(32) << (value->recommendedFarZ);
        contents.emplace_back("float", recommendedfarz_prefix, oss_recommendedFarZ.str());
        std::string maxfarz_prefix = prefix;
        maxfarz_prefix += "maxFarZ";
        std::ostringstream oss_maxFarZ;
        oss_maxFarZ << std::setprecision(32) << (value->maxFarZ);
        contents.emplace_back("float", maxfarz_prefix, oss_maxFarZ.str());
        return true;
    } catch(...) {
    }
    return false;
}

#if defined(XR_USE_PLATFORM_EGL)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGraphicsBindingEGLMNDX* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string getprocaddress_prefix = prefix;
        getprocaddress_prefix += "getProcAddress";
        std::ostringstream oss_getProcAddress;
        oss_getProcAddress << std::hex << reinterpret_cast<const void*>(value->getProcAddress);
        contents.emplace_back("PFN_xrEglGetProcAddressMNDX", getprocaddress_prefix, oss_getProcAddress.str());
        std::string display_prefix = prefix;
        display_prefix += "display";
        std::ostringstream oss_display;
        oss_display << std::hex << reinterpret_cast<const void*>(value->display);
        contents.emplace_back("EGLDisplay", display_prefix, oss_display.str());
        std::string config_prefix = prefix;
        config_prefix += "config";
        std::ostringstream oss_config;
        oss_config << std::hex << reinterpret_cast<const void*>(value->config);
        contents.emplace_back("EGLConfig", config_prefix, oss_config.str());
        std::string context_prefix = prefix;
        context_prefix += "context";
        std::ostringstream oss_context;
        oss_context << std::hex << reinterpret_cast<const void*>(value->context);
        contents.emplace_back("EGLContext", context_prefix, oss_context.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_PLATFORM_EGL)

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialGraphNodeSpaceCreateInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string nodetype_prefix = prefix;
        nodetype_prefix += "nodeType";
        contents.emplace_back("XrSpatialGraphNodeTypeMSFT", nodetype_prefix, std::to_string(value->nodeType));
        std::string nodeid_prefix = prefix;
        nodeid_prefix += "nodeId";
        std::ostringstream oss_nodeId_array;
        oss_nodeId_array << "0x" << std::hex << (value->nodeId);
        contents.emplace_back("uint8_t*", nodeid_prefix, oss_nodeId_array.str());
        for (uint32_t value_nodeid_inc = 0; value_nodeid_inc < XR_GUID_SIZE_MSFT; ++value_nodeid_inc) {
            std::string nodeid_array_prefix = nodeid_prefix;
            nodeid_array_prefix += "[";
            nodeid_array_prefix += std::to_string(value_nodeid_inc);
            nodeid_array_prefix += "]";
            std::ostringstream oss_nodeId;
            oss_nodeId << "0x" << std::hex << (value->nodeId[value_nodeid_inc]);
            contents.emplace_back("uint8_t", nodeid_array_prefix, oss_nodeId.str());
        }
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialGraphStaticNodeBindingCreateInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string poseinspace_prefix = prefix;
        poseinspace_prefix += "poseInSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInSpace, poseinspace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialGraphNodeBindingPropertiesMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string nodeid_prefix = prefix;
        nodeid_prefix += "nodeId";
        std::ostringstream oss_nodeId_array;
        oss_nodeId_array << "0x" << std::hex << (value->nodeId);
        contents.emplace_back("uint8_t*", nodeid_prefix, oss_nodeId_array.str());
        for (uint32_t value_nodeid_inc = 0; value_nodeid_inc < XR_GUID_SIZE_MSFT; ++value_nodeid_inc) {
            std::string nodeid_array_prefix = nodeid_prefix;
            nodeid_array_prefix += "[";
            nodeid_array_prefix += std::to_string(value_nodeid_inc);
            nodeid_array_prefix += "]";
            std::ostringstream oss_nodeId;
            oss_nodeId << "0x" << std::hex << (value->nodeId[value_nodeid_inc]);
            contents.emplace_back("uint8_t", nodeid_array_prefix, oss_nodeId.str());
        }
        std::string poseinnodespace_prefix = prefix;
        poseinnodespace_prefix += "poseInNodeSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInNodeSpace, poseinnodespace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemHandTrackingPropertiesEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportshandtracking_prefix = prefix;
        supportshandtracking_prefix += "supportsHandTracking";
        std::ostringstream oss_supportsHandTracking;
        oss_supportsHandTracking << "0x" << std::hex << (value->supportsHandTracking);
        contents.emplace_back("XrBool32", supportshandtracking_prefix, oss_supportsHandTracking.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandTrackerCreateInfoEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string hand_prefix = prefix;
        hand_prefix += "hand";
        contents.emplace_back("XrHandEXT", hand_prefix, std::to_string(value->hand));
        std::string handjointset_prefix = prefix;
        handjointset_prefix += "handJointSet";
        contents.emplace_back("XrHandJointSetEXT", handjointset_prefix, std::to_string(value->handJointSet));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandJointsLocateInfoEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandJointLocationEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string locationflags_prefix = prefix;
        locationflags_prefix += "locationFlags";
        contents.emplace_back("XrSpaceLocationFlags", locationflags_prefix, std::to_string(value->locationFlags));
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string radius_prefix = prefix;
        radius_prefix += "radius";
        std::ostringstream oss_radius;
        oss_radius << std::setprecision(32) << (value->radius);
        contents.emplace_back("float", radius_prefix, oss_radius.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandJointVelocityEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string velocityflags_prefix = prefix;
        velocityflags_prefix += "velocityFlags";
        contents.emplace_back("XrSpaceVelocityFlags", velocityflags_prefix, std::to_string(value->velocityFlags));
        std::string linearvelocity_prefix = prefix;
        linearvelocity_prefix += "linearVelocity";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->linearVelocity, linearvelocity_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string angularvelocity_prefix = prefix;
        angularvelocity_prefix += "angularVelocity";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->angularVelocity, angularvelocity_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandJointLocationsEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string isactive_prefix = prefix;
        isactive_prefix += "isActive";
        std::ostringstream oss_isActive;
        oss_isActive << "0x" << std::hex << (value->isActive);
        contents.emplace_back("XrBool32", isactive_prefix, oss_isActive.str());
        std::string jointcount_prefix = prefix;
        jointcount_prefix += "jointCount";
        std::ostringstream oss_jointCount;
        oss_jointCount << "0x" << std::hex << (value->jointCount);
        contents.emplace_back("uint32_t", jointcount_prefix, oss_jointCount.str());
        std::string jointlocations_prefix = prefix;
        jointlocations_prefix += "jointLocations";
        std::ostringstream oss_jointLocations;
        oss_jointLocations << std::hex << reinterpret_cast<const void*>(value->jointLocations);
        contents.emplace_back("XrHandJointLocationEXT*", jointlocations_prefix, oss_jointLocations.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandJointVelocitiesEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string jointcount_prefix = prefix;
        jointcount_prefix += "jointCount";
        std::ostringstream oss_jointCount;
        oss_jointCount << "0x" << std::hex << (value->jointCount);
        contents.emplace_back("uint32_t", jointcount_prefix, oss_jointCount.str());
        std::string jointvelocities_prefix = prefix;
        jointvelocities_prefix += "jointVelocities";
        std::ostringstream oss_jointVelocities;
        oss_jointVelocities << std::hex << reinterpret_cast<const void*>(value->jointVelocities);
        contents.emplace_back("XrHandJointVelocityEXT*", jointvelocities_prefix, oss_jointVelocities.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemHandTrackingMeshPropertiesMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportshandtrackingmesh_prefix = prefix;
        supportshandtrackingmesh_prefix += "supportsHandTrackingMesh";
        std::ostringstream oss_supportsHandTrackingMesh;
        oss_supportsHandTrackingMesh << "0x" << std::hex << (value->supportsHandTrackingMesh);
        contents.emplace_back("XrBool32", supportshandtrackingmesh_prefix, oss_supportsHandTrackingMesh.str());
        std::string maxhandmeshindexcount_prefix = prefix;
        maxhandmeshindexcount_prefix += "maxHandMeshIndexCount";
        std::ostringstream oss_maxHandMeshIndexCount;
        oss_maxHandMeshIndexCount << "0x" << std::hex << (value->maxHandMeshIndexCount);
        contents.emplace_back("uint32_t", maxhandmeshindexcount_prefix, oss_maxHandMeshIndexCount.str());
        std::string maxhandmeshvertexcount_prefix = prefix;
        maxhandmeshvertexcount_prefix += "maxHandMeshVertexCount";
        std::ostringstream oss_maxHandMeshVertexCount;
        oss_maxHandMeshVertexCount << "0x" << std::hex << (value->maxHandMeshVertexCount);
        contents.emplace_back("uint32_t", maxhandmeshvertexcount_prefix, oss_maxHandMeshVertexCount.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandMeshSpaceCreateInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string handposetype_prefix = prefix;
        handposetype_prefix += "handPoseType";
        contents.emplace_back("XrHandPoseTypeMSFT", handposetype_prefix, std::to_string(value->handPoseType));
        std::string poseinhandmeshspace_prefix = prefix;
        poseinhandmeshspace_prefix += "poseInHandMeshSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInHandMeshSpace, poseinhandmeshspace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandMeshUpdateInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        std::string handposetype_prefix = prefix;
        handposetype_prefix += "handPoseType";
        contents.emplace_back("XrHandPoseTypeMSFT", handposetype_prefix, std::to_string(value->handPoseType));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandMeshIndexBufferMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string indexbufferkey_prefix = prefix;
        indexbufferkey_prefix += "indexBufferKey";
        std::ostringstream oss_indexBufferKey;
        oss_indexBufferKey << "0x" << std::hex << (value->indexBufferKey);
        contents.emplace_back("uint32_t", indexbufferkey_prefix, oss_indexBufferKey.str());
        std::string indexcapacityinput_prefix = prefix;
        indexcapacityinput_prefix += "indexCapacityInput";
        std::ostringstream oss_indexCapacityInput;
        oss_indexCapacityInput << "0x" << std::hex << (value->indexCapacityInput);
        contents.emplace_back("uint32_t", indexcapacityinput_prefix, oss_indexCapacityInput.str());
        std::string indexcountoutput_prefix = prefix;
        indexcountoutput_prefix += "indexCountOutput";
        std::ostringstream oss_indexCountOutput;
        oss_indexCountOutput << "0x" << std::hex << (value->indexCountOutput);
        contents.emplace_back("uint32_t", indexcountoutput_prefix, oss_indexCountOutput.str());
        std::string indices_prefix = prefix;
        indices_prefix += "indices";
        std::ostringstream oss_indices;
        oss_indices << "0x" << std::hex << (value->indices);
        contents.emplace_back("uint32_t*", indices_prefix, oss_indices.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandMeshVertexMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string position_prefix = prefix;
        position_prefix += "position";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->position, position_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string normal_prefix = prefix;
        normal_prefix += "normal";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->normal, normal_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandMeshVertexBufferMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string vertexupdatetime_prefix = prefix;
        vertexupdatetime_prefix += "vertexUpdateTime";
        contents.emplace_back("XrTime", vertexupdatetime_prefix, std::to_string(value->vertexUpdateTime));
        std::string vertexcapacityinput_prefix = prefix;
        vertexcapacityinput_prefix += "vertexCapacityInput";
        std::ostringstream oss_vertexCapacityInput;
        oss_vertexCapacityInput << "0x" << std::hex << (value->vertexCapacityInput);
        contents.emplace_back("uint32_t", vertexcapacityinput_prefix, oss_vertexCapacityInput.str());
        std::string vertexcountoutput_prefix = prefix;
        vertexcountoutput_prefix += "vertexCountOutput";
        std::ostringstream oss_vertexCountOutput;
        oss_vertexCountOutput << "0x" << std::hex << (value->vertexCountOutput);
        contents.emplace_back("uint32_t", vertexcountoutput_prefix, oss_vertexCountOutput.str());
        std::string vertices_prefix = prefix;
        vertices_prefix += "vertices";
        std::ostringstream oss_vertices;
        oss_vertices << std::hex << reinterpret_cast<const void*>(value->vertices);
        contents.emplace_back("XrHandMeshVertexMSFT*", vertices_prefix, oss_vertices.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandMeshMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string isactive_prefix = prefix;
        isactive_prefix += "isActive";
        std::ostringstream oss_isActive;
        oss_isActive << "0x" << std::hex << (value->isActive);
        contents.emplace_back("XrBool32", isactive_prefix, oss_isActive.str());
        std::string indexbufferchanged_prefix = prefix;
        indexbufferchanged_prefix += "indexBufferChanged";
        std::ostringstream oss_indexBufferChanged;
        oss_indexBufferChanged << "0x" << std::hex << (value->indexBufferChanged);
        contents.emplace_back("XrBool32", indexbufferchanged_prefix, oss_indexBufferChanged.str());
        std::string vertexbufferchanged_prefix = prefix;
        vertexbufferchanged_prefix += "vertexBufferChanged";
        std::ostringstream oss_vertexBufferChanged;
        oss_vertexBufferChanged << "0x" << std::hex << (value->vertexBufferChanged);
        contents.emplace_back("XrBool32", vertexbufferchanged_prefix, oss_vertexBufferChanged.str());
        std::string indexbuffer_prefix = prefix;
        indexbuffer_prefix += "indexBuffer";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->indexBuffer, indexbuffer_prefix, "XrHandMeshIndexBufferMSFT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string vertexbuffer_prefix = prefix;
        vertexbuffer_prefix += "vertexBuffer";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->vertexBuffer, vertexbuffer_prefix, "XrHandMeshVertexBufferMSFT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandPoseTypeInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string handposetype_prefix = prefix;
        handposetype_prefix += "handPoseType";
        contents.emplace_back("XrHandPoseTypeMSFT", handposetype_prefix, std::to_string(value->handPoseType));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSecondaryViewConfigurationSessionBeginInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string viewconfigurationcount_prefix = prefix;
        viewconfigurationcount_prefix += "viewConfigurationCount";
        std::ostringstream oss_viewConfigurationCount;
        oss_viewConfigurationCount << "0x" << std::hex << (value->viewConfigurationCount);
        contents.emplace_back("uint32_t", viewconfigurationcount_prefix, oss_viewConfigurationCount.str());
        std::string enabledviewconfigurationtypes_prefix = prefix;
        enabledviewconfigurationtypes_prefix += "enabledViewConfigurationTypes";
        std::ostringstream oss_enabledViewConfigurationTypes_array;
        oss_enabledViewConfigurationTypes_array << std::hex << reinterpret_cast<const void*>(value->enabledViewConfigurationTypes);
        contents.emplace_back("const XrViewConfigurationType*", enabledviewconfigurationtypes_prefix, oss_enabledViewConfigurationTypes_array.str());
        for (uint32_t value_enabledviewconfigurationtypes_inc = 0; value_enabledviewconfigurationtypes_inc < value->viewConfigurationCount; ++value_enabledviewconfigurationtypes_inc) {
            std::string enabledviewconfigurationtypes_array_prefix = enabledviewconfigurationtypes_prefix;
            enabledviewconfigurationtypes_array_prefix += "[";
            enabledviewconfigurationtypes_array_prefix += std::to_string(value_enabledviewconfigurationtypes_inc);
            enabledviewconfigurationtypes_array_prefix += "]";
            contents.emplace_back("const XrViewConfigurationType*", enabledviewconfigurationtypes_array_prefix, std::to_string(value->enabledViewConfigurationTypes[value_enabledviewconfigurationtypes_inc]));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSecondaryViewConfigurationStateMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string viewconfigurationtype_prefix = prefix;
        viewconfigurationtype_prefix += "viewConfigurationType";
        contents.emplace_back("XrViewConfigurationType", viewconfigurationtype_prefix, std::to_string(value->viewConfigurationType));
        std::string active_prefix = prefix;
        active_prefix += "active";
        std::ostringstream oss_active;
        oss_active << "0x" << std::hex << (value->active);
        contents.emplace_back("XrBool32", active_prefix, oss_active.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSecondaryViewConfigurationFrameStateMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string viewconfigurationcount_prefix = prefix;
        viewconfigurationcount_prefix += "viewConfigurationCount";
        std::ostringstream oss_viewConfigurationCount;
        oss_viewConfigurationCount << "0x" << std::hex << (value->viewConfigurationCount);
        contents.emplace_back("uint32_t", viewconfigurationcount_prefix, oss_viewConfigurationCount.str());
        std::string viewconfigurationstates_prefix = prefix;
        viewconfigurationstates_prefix += "viewConfigurationStates";
        std::ostringstream oss_viewConfigurationStates;
        oss_viewConfigurationStates << std::hex << reinterpret_cast<const void*>(value->viewConfigurationStates);
        contents.emplace_back("XrSecondaryViewConfigurationStateMSFT*", viewconfigurationstates_prefix, oss_viewConfigurationStates.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSecondaryViewConfigurationLayerInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string viewconfigurationtype_prefix = prefix;
        viewconfigurationtype_prefix += "viewConfigurationType";
        contents.emplace_back("XrViewConfigurationType", viewconfigurationtype_prefix, std::to_string(value->viewConfigurationType));
        std::string environmentblendmode_prefix = prefix;
        environmentblendmode_prefix += "environmentBlendMode";
        contents.emplace_back("XrEnvironmentBlendMode", environmentblendmode_prefix, std::to_string(value->environmentBlendMode));
        std::string layercount_prefix = prefix;
        layercount_prefix += "layerCount";
        std::ostringstream oss_layerCount;
        oss_layerCount << "0x" << std::hex << (value->layerCount);
        contents.emplace_back("uint32_t", layercount_prefix, oss_layerCount.str());
        std::string layers_prefix = prefix;
        layers_prefix += "layers";
        std::ostringstream oss_layers_array;
        oss_layers_array << std::hex << reinterpret_cast<const void*>(value->layers);
        contents.emplace_back("const XrCompositionLayerBaseHeader* const*", layers_prefix, oss_layers_array.str());
        for (uint32_t value_layers_inc = 0; value_layers_inc < value->layerCount; ++value_layers_inc) {
            std::string layers_array_prefix = layers_prefix;
            layers_array_prefix += "[";
            layers_array_prefix += std::to_string(value_layers_inc);
            layers_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, value->layers[value_layers_inc], layers_array_prefix, "const XrCompositionLayerBaseHeader* const*", true, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSecondaryViewConfigurationFrameEndInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string viewconfigurationcount_prefix = prefix;
        viewconfigurationcount_prefix += "viewConfigurationCount";
        std::ostringstream oss_viewConfigurationCount;
        oss_viewConfigurationCount << "0x" << std::hex << (value->viewConfigurationCount);
        contents.emplace_back("uint32_t", viewconfigurationcount_prefix, oss_viewConfigurationCount.str());
        std::string viewconfigurationlayersinfo_prefix = prefix;
        viewconfigurationlayersinfo_prefix += "viewConfigurationLayersInfo";
        std::ostringstream oss_viewConfigurationLayersInfo_array;
        oss_viewConfigurationLayersInfo_array << std::hex << reinterpret_cast<const void*>(value->viewConfigurationLayersInfo);
        contents.emplace_back("const XrSecondaryViewConfigurationLayerInfoMSFT*", viewconfigurationlayersinfo_prefix, oss_viewConfigurationLayersInfo_array.str());
        for (uint32_t value_viewconfigurationlayersinfo_inc = 0; value_viewconfigurationlayersinfo_inc < value->viewConfigurationCount; ++value_viewconfigurationlayersinfo_inc) {
            std::string viewconfigurationlayersinfo_array_prefix = viewconfigurationlayersinfo_prefix;
            viewconfigurationlayersinfo_array_prefix += "[";
            viewconfigurationlayersinfo_array_prefix += std::to_string(value_viewconfigurationlayersinfo_inc);
            viewconfigurationlayersinfo_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->viewConfigurationLayersInfo[value_viewconfigurationlayersinfo_inc], viewconfigurationlayersinfo_array_prefix, "const XrSecondaryViewConfigurationLayerInfoMSFT*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string viewconfigurationtype_prefix = prefix;
        viewconfigurationtype_prefix += "viewConfigurationType";
        contents.emplace_back("XrViewConfigurationType", viewconfigurationtype_prefix, std::to_string(value->viewConfigurationType));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrControllerModelKeyStateMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string modelkey_prefix = prefix;
        modelkey_prefix += "modelKey";
        contents.emplace_back("XrControllerModelKeyMSFT", modelkey_prefix, std::to_string(value->modelKey));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrControllerModelNodePropertiesMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string parentnodename_prefix = prefix;
        parentnodename_prefix += "parentNodeName";
        contents.emplace_back("char*", parentnodename_prefix, value->parentNodeName);
        std::string nodename_prefix = prefix;
        nodename_prefix += "nodeName";
        contents.emplace_back("char*", nodename_prefix, value->nodeName);
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrControllerModelPropertiesMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string nodecapacityinput_prefix = prefix;
        nodecapacityinput_prefix += "nodeCapacityInput";
        std::ostringstream oss_nodeCapacityInput;
        oss_nodeCapacityInput << "0x" << std::hex << (value->nodeCapacityInput);
        contents.emplace_back("uint32_t", nodecapacityinput_prefix, oss_nodeCapacityInput.str());
        std::string nodecountoutput_prefix = prefix;
        nodecountoutput_prefix += "nodeCountOutput";
        std::ostringstream oss_nodeCountOutput;
        oss_nodeCountOutput << "0x" << std::hex << (value->nodeCountOutput);
        contents.emplace_back("uint32_t", nodecountoutput_prefix, oss_nodeCountOutput.str());
        std::string nodeproperties_prefix = prefix;
        nodeproperties_prefix += "nodeProperties";
        std::ostringstream oss_nodeProperties;
        oss_nodeProperties << std::hex << reinterpret_cast<const void*>(value->nodeProperties);
        contents.emplace_back("XrControllerModelNodePropertiesMSFT*", nodeproperties_prefix, oss_nodeProperties.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrControllerModelNodeStateMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string nodepose_prefix = prefix;
        nodepose_prefix += "nodePose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->nodePose, nodepose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrControllerModelStateMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string nodecapacityinput_prefix = prefix;
        nodecapacityinput_prefix += "nodeCapacityInput";
        std::ostringstream oss_nodeCapacityInput;
        oss_nodeCapacityInput << "0x" << std::hex << (value->nodeCapacityInput);
        contents.emplace_back("uint32_t", nodecapacityinput_prefix, oss_nodeCapacityInput.str());
        std::string nodecountoutput_prefix = prefix;
        nodecountoutput_prefix += "nodeCountOutput";
        std::ostringstream oss_nodeCountOutput;
        oss_nodeCountOutput << "0x" << std::hex << (value->nodeCountOutput);
        contents.emplace_back("uint32_t", nodecountoutput_prefix, oss_nodeCountOutput.str());
        std::string nodestates_prefix = prefix;
        nodestates_prefix += "nodeStates";
        std::ostringstream oss_nodeStates;
        oss_nodeStates << std::hex << reinterpret_cast<const void*>(value->nodeStates);
        contents.emplace_back("XrControllerModelNodeStateMSFT*", nodestates_prefix, oss_nodeStates.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrViewConfigurationViewFovEPIC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string recommendedfov_prefix = prefix;
        recommendedfov_prefix += "recommendedFov";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->recommendedFov, recommendedfov_prefix, "XrFovf", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string maxmutablefov_prefix = prefix;
        maxmutablefov_prefix += "maxMutableFov";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->maxMutableFov, maxmutablefov_prefix, "XrFovf", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

#if defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHolographicWindowAttachmentMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string holographicspace_prefix = prefix;
        holographicspace_prefix += "holographicSpace";
        std::ostringstream oss_holographicSpace;
        oss_holographicSpace << std::hex << reinterpret_cast<const void*>(value->holographicSpace);
        contents.emplace_back("IUnknown*", holographicspace_prefix, oss_holographicSpace.str());
        std::string corewindow_prefix = prefix;
        corewindow_prefix += "coreWindow";
        std::ostringstream oss_coreWindow;
        oss_coreWindow << std::hex << reinterpret_cast<const void*>(value->coreWindow);
        contents.emplace_back("IUnknown*", corewindow_prefix, oss_coreWindow.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerReprojectionInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string reprojectionmode_prefix = prefix;
        reprojectionmode_prefix += "reprojectionMode";
        contents.emplace_back("XrReprojectionModeMSFT", reprojectionmode_prefix, std::to_string(value->reprojectionMode));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerReprojectionPlaneOverrideMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string position_prefix = prefix;
        position_prefix += "position";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->position, position_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string normal_prefix = prefix;
        normal_prefix += "normal";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->normal, normal_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string velocity_prefix = prefix;
        velocity_prefix += "velocity";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->velocity, velocity_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrAndroidSurfaceSwapchainCreateInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string createflags_prefix = prefix;
        createflags_prefix += "createFlags";
        contents.emplace_back("XrAndroidSurfaceSwapchainFlagsFB", createflags_prefix, std::to_string(value->createFlags));
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainStateBaseHeaderFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        if (value->type == XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB) {
            const XrSwapchainStateFoveationFB* new_value = reinterpret_cast<const XrSwapchainStateFoveationFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
        if (value->type == XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB) {
            const XrSwapchainStateAndroidSurfaceDimensionsFB* new_value = reinterpret_cast<const XrSwapchainStateAndroidSurfaceDimensionsFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
        if (value->type == XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB) {
            const XrSwapchainStateSamplerOpenGLESFB* new_value = reinterpret_cast<const XrSwapchainStateSamplerOpenGLESFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
        if (value->type == XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB) {
            const XrSwapchainStateSamplerVulkanFB* new_value = reinterpret_cast<const XrSwapchainStateSamplerVulkanFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
        // Fallback path - Just output generic information about the base struct
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerSecureContentFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrCompositionLayerSecureContentFlagsFB", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodyJointLocationFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string locationflags_prefix = prefix;
        locationflags_prefix += "locationFlags";
        contents.emplace_back("XrSpaceLocationFlags", locationflags_prefix, std::to_string(value->locationFlags));
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemBodyTrackingPropertiesFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsbodytracking_prefix = prefix;
        supportsbodytracking_prefix += "supportsBodyTracking";
        std::ostringstream oss_supportsBodyTracking;
        oss_supportsBodyTracking << "0x" << std::hex << (value->supportsBodyTracking);
        contents.emplace_back("XrBool32", supportsbodytracking_prefix, oss_supportsBodyTracking.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodyTrackerCreateInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string bodyjointset_prefix = prefix;
        bodyjointset_prefix += "bodyJointSet";
        contents.emplace_back("XrBodyJointSetFB", bodyjointset_prefix, std::to_string(value->bodyJointSet));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodySkeletonJointFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string joint_prefix = prefix;
        joint_prefix += "joint";
        contents.emplace_back("int32_t", joint_prefix, std::to_string(value->joint));
        std::string parentjoint_prefix = prefix;
        parentjoint_prefix += "parentJoint";
        contents.emplace_back("int32_t", parentjoint_prefix, std::to_string(value->parentJoint));
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodySkeletonFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string jointcount_prefix = prefix;
        jointcount_prefix += "jointCount";
        std::ostringstream oss_jointCount;
        oss_jointCount << "0x" << std::hex << (value->jointCount);
        contents.emplace_back("uint32_t", jointcount_prefix, oss_jointCount.str());
        std::string joints_prefix = prefix;
        joints_prefix += "joints";
        std::ostringstream oss_joints;
        oss_joints << std::hex << reinterpret_cast<const void*>(value->joints);
        contents.emplace_back("XrBodySkeletonJointFB*", joints_prefix, oss_joints.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodyJointsLocateInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodyJointLocationsFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string isactive_prefix = prefix;
        isactive_prefix += "isActive";
        std::ostringstream oss_isActive;
        oss_isActive << "0x" << std::hex << (value->isActive);
        contents.emplace_back("XrBool32", isactive_prefix, oss_isActive.str());
        std::string confidence_prefix = prefix;
        confidence_prefix += "confidence";
        std::ostringstream oss_confidence;
        oss_confidence << std::setprecision(32) << (value->confidence);
        contents.emplace_back("float", confidence_prefix, oss_confidence.str());
        std::string jointcount_prefix = prefix;
        jointcount_prefix += "jointCount";
        std::ostringstream oss_jointCount;
        oss_jointCount << "0x" << std::hex << (value->jointCount);
        contents.emplace_back("uint32_t", jointcount_prefix, oss_jointCount.str());
        std::string jointlocations_prefix = prefix;
        jointlocations_prefix += "jointLocations";
        std::ostringstream oss_jointLocations;
        oss_jointLocations << std::hex << reinterpret_cast<const void*>(value->jointLocations);
        contents.emplace_back("XrBodyJointLocationFB*", jointlocations_prefix, oss_jointLocations.str());
        std::string skeletonchangedcount_prefix = prefix;
        skeletonchangedcount_prefix += "skeletonChangedCount";
        std::ostringstream oss_skeletonChangedCount;
        oss_skeletonChangedCount << "0x" << std::hex << (value->skeletonChangedCount);
        contents.emplace_back("uint32_t", skeletonchangedcount_prefix, oss_skeletonChangedCount.str());
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrInteractionProfileDpadBindingEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string binding_prefix = prefix;
        binding_prefix += "binding";
        contents.emplace_back("XrPath", binding_prefix, std::to_string(value->binding));
        std::string actionset_prefix = prefix;
        actionset_prefix += "actionSet";
        std::ostringstream oss_actionSet;
        oss_actionSet << std::hex << reinterpret_cast<const void*>(value->actionSet);
        contents.emplace_back("XrActionSet", actionset_prefix, oss_actionSet.str());
        std::string forcethreshold_prefix = prefix;
        forcethreshold_prefix += "forceThreshold";
        std::ostringstream oss_forceThreshold;
        oss_forceThreshold << std::setprecision(32) << (value->forceThreshold);
        contents.emplace_back("float", forcethreshold_prefix, oss_forceThreshold.str());
        std::string forcethresholdreleased_prefix = prefix;
        forcethresholdreleased_prefix += "forceThresholdReleased";
        std::ostringstream oss_forceThresholdReleased;
        oss_forceThresholdReleased << std::setprecision(32) << (value->forceThresholdReleased);
        contents.emplace_back("float", forcethresholdreleased_prefix, oss_forceThresholdReleased.str());
        std::string centerregion_prefix = prefix;
        centerregion_prefix += "centerRegion";
        std::ostringstream oss_centerRegion;
        oss_centerRegion << std::setprecision(32) << (value->centerRegion);
        contents.emplace_back("float", centerregion_prefix, oss_centerRegion.str());
        std::string wedgeangle_prefix = prefix;
        wedgeangle_prefix += "wedgeAngle";
        std::ostringstream oss_wedgeAngle;
        oss_wedgeAngle << std::setprecision(32) << (value->wedgeAngle);
        contents.emplace_back("float", wedgeangle_prefix, oss_wedgeAngle.str());
        std::string issticky_prefix = prefix;
        issticky_prefix += "isSticky";
        std::ostringstream oss_isSticky;
        oss_isSticky << "0x" << std::hex << (value->isSticky);
        contents.emplace_back("XrBool32", issticky_prefix, oss_isSticky.str());
        std::string onhaptic_prefix = prefix;
        onhaptic_prefix += "onHaptic";
        if (nullptr == value->onHaptic) {
            std::ostringstream oss_onHaptic;
            oss_onHaptic << std::hex << reinterpret_cast<const void*>(value->onHaptic);
            contents.emplace_back("const XrHapticBaseHeader*", onhaptic_prefix, oss_onHaptic.str());
        } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, value->onHaptic, onhaptic_prefix, "const XrHapticBaseHeader*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string offhaptic_prefix = prefix;
        offhaptic_prefix += "offHaptic";
        if (nullptr == value->offHaptic) {
            std::ostringstream oss_offHaptic;
            oss_offHaptic << std::hex << reinterpret_cast<const void*>(value->offHaptic);
            contents.emplace_back("const XrHapticBaseHeader*", offhaptic_prefix, oss_offHaptic.str());
        } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, value->offHaptic, offhaptic_prefix, "const XrHapticBaseHeader*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrInteractionProfileAnalogThresholdVALVE* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string action_prefix = prefix;
        action_prefix += "action";
        std::ostringstream oss_action;
        oss_action << std::hex << reinterpret_cast<const void*>(value->action);
        contents.emplace_back("XrAction", action_prefix, oss_action.str());
        std::string binding_prefix = prefix;
        binding_prefix += "binding";
        contents.emplace_back("XrPath", binding_prefix, std::to_string(value->binding));
        std::string onthreshold_prefix = prefix;
        onthreshold_prefix += "onThreshold";
        std::ostringstream oss_onThreshold;
        oss_onThreshold << std::setprecision(32) << (value->onThreshold);
        contents.emplace_back("float", onthreshold_prefix, oss_onThreshold.str());
        std::string offthreshold_prefix = prefix;
        offthreshold_prefix += "offThreshold";
        std::ostringstream oss_offThreshold;
        oss_offThreshold << std::setprecision(32) << (value->offThreshold);
        contents.emplace_back("float", offthreshold_prefix, oss_offThreshold.str());
        std::string onhaptic_prefix = prefix;
        onhaptic_prefix += "onHaptic";
        if (nullptr == value->onHaptic) {
            std::ostringstream oss_onHaptic;
            oss_onHaptic << std::hex << reinterpret_cast<const void*>(value->onHaptic);
            contents.emplace_back("const XrHapticBaseHeader*", onhaptic_prefix, oss_onHaptic.str());
        } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, value->onHaptic, onhaptic_prefix, "const XrHapticBaseHeader*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string offhaptic_prefix = prefix;
        offhaptic_prefix += "offHaptic";
        if (nullptr == value->offHaptic) {
            std::ostringstream oss_offHaptic;
            oss_offHaptic << std::hex << reinterpret_cast<const void*>(value->offHaptic);
            contents.emplace_back("const XrHapticBaseHeader*", offhaptic_prefix, oss_offHaptic.str());
        } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, value->offHaptic, offhaptic_prefix, "const XrHapticBaseHeader*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandJointsMotionRangeInfoEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string handjointsmotionrange_prefix = prefix;
        handjointsmotionrange_prefix += "handJointsMotionRange";
        contents.emplace_back("XrHandJointsMotionRangeEXT", handjointsmotionrange_prefix, std::to_string(value->handJointsMotionRange));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrUuidMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string bytes_prefix = prefix;
        bytes_prefix += "bytes";
        std::ostringstream oss_bytes_array;
        oss_bytes_array << "0x" << std::hex << (value->bytes);
        contents.emplace_back("uint8_t*", bytes_prefix, oss_bytes_array.str());
        for (uint32_t value_bytes_inc = 0; value_bytes_inc < 16; ++value_bytes_inc) {
            std::string bytes_array_prefix = bytes_prefix;
            bytes_array_prefix += "[";
            bytes_array_prefix += std::to_string(value_bytes_inc);
            bytes_array_prefix += "]";
            std::ostringstream oss_bytes;
            oss_bytes << "0x" << std::hex << (value->bytes[value_bytes_inc]);
            contents.emplace_back("uint8_t", bytes_array_prefix, oss_bytes.str());
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneObserverCreateInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneCreateInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneSphereBoundMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string center_prefix = prefix;
        center_prefix += "center";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->center, center_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string radius_prefix = prefix;
        radius_prefix += "radius";
        std::ostringstream oss_radius;
        oss_radius << std::setprecision(32) << (value->radius);
        contents.emplace_back("float", radius_prefix, oss_radius.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneOrientedBoxBoundMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string extents_prefix = prefix;
        extents_prefix += "extents";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->extents, extents_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneFrustumBoundMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string fov_prefix = prefix;
        fov_prefix += "fov";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->fov, fov_prefix, "XrFovf", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string fardistance_prefix = prefix;
        fardistance_prefix += "farDistance";
        std::ostringstream oss_farDistance;
        oss_farDistance << std::setprecision(32) << (value->farDistance);
        contents.emplace_back("float", fardistance_prefix, oss_farDistance.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneBoundsMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        std::string spherecount_prefix = prefix;
        spherecount_prefix += "sphereCount";
        std::ostringstream oss_sphereCount;
        oss_sphereCount << "0x" << std::hex << (value->sphereCount);
        contents.emplace_back("uint32_t", spherecount_prefix, oss_sphereCount.str());
        std::string spheres_prefix = prefix;
        spheres_prefix += "spheres";
        std::ostringstream oss_spheres_array;
        oss_spheres_array << std::hex << reinterpret_cast<const void*>(value->spheres);
        contents.emplace_back("const XrSceneSphereBoundMSFT*", spheres_prefix, oss_spheres_array.str());
        for (uint32_t value_spheres_inc = 0; value_spheres_inc < value->sphereCount; ++value_spheres_inc) {
            std::string spheres_array_prefix = spheres_prefix;
            spheres_array_prefix += "[";
            spheres_array_prefix += std::to_string(value_spheres_inc);
            spheres_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->spheres[value_spheres_inc], spheres_array_prefix, "const XrSceneSphereBoundMSFT*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        std::string boxcount_prefix = prefix;
        boxcount_prefix += "boxCount";
        std::ostringstream oss_boxCount;
        oss_boxCount << "0x" << std::hex << (value->boxCount);
        contents.emplace_back("uint32_t", boxcount_prefix, oss_boxCount.str());
        std::string boxes_prefix = prefix;
        boxes_prefix += "boxes";
        std::ostringstream oss_boxes_array;
        oss_boxes_array << std::hex << reinterpret_cast<const void*>(value->boxes);
        contents.emplace_back("const XrSceneOrientedBoxBoundMSFT*", boxes_prefix, oss_boxes_array.str());
        for (uint32_t value_boxes_inc = 0; value_boxes_inc < value->boxCount; ++value_boxes_inc) {
            std::string boxes_array_prefix = boxes_prefix;
            boxes_array_prefix += "[";
            boxes_array_prefix += std::to_string(value_boxes_inc);
            boxes_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->boxes[value_boxes_inc], boxes_array_prefix, "const XrSceneOrientedBoxBoundMSFT*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        std::string frustumcount_prefix = prefix;
        frustumcount_prefix += "frustumCount";
        std::ostringstream oss_frustumCount;
        oss_frustumCount << "0x" << std::hex << (value->frustumCount);
        contents.emplace_back("uint32_t", frustumcount_prefix, oss_frustumCount.str());
        std::string frustums_prefix = prefix;
        frustums_prefix += "frustums";
        std::ostringstream oss_frustums_array;
        oss_frustums_array << std::hex << reinterpret_cast<const void*>(value->frustums);
        contents.emplace_back("const XrSceneFrustumBoundMSFT*", frustums_prefix, oss_frustums_array.str());
        for (uint32_t value_frustums_inc = 0; value_frustums_inc < value->frustumCount; ++value_frustums_inc) {
            std::string frustums_array_prefix = frustums_prefix;
            frustums_array_prefix += "[";
            frustums_array_prefix += std::to_string(value_frustums_inc);
            frustums_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->frustums[value_frustums_inc], frustums_array_prefix, "const XrSceneFrustumBoundMSFT*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrNewSceneComputeInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestedfeaturecount_prefix = prefix;
        requestedfeaturecount_prefix += "requestedFeatureCount";
        std::ostringstream oss_requestedFeatureCount;
        oss_requestedFeatureCount << "0x" << std::hex << (value->requestedFeatureCount);
        contents.emplace_back("uint32_t", requestedfeaturecount_prefix, oss_requestedFeatureCount.str());
        std::string requestedfeatures_prefix = prefix;
        requestedfeatures_prefix += "requestedFeatures";
        std::ostringstream oss_requestedFeatures_array;
        oss_requestedFeatures_array << std::hex << reinterpret_cast<const void*>(value->requestedFeatures);
        contents.emplace_back("const XrSceneComputeFeatureMSFT*", requestedfeatures_prefix, oss_requestedFeatures_array.str());
        for (uint32_t value_requestedfeatures_inc = 0; value_requestedfeatures_inc < value->requestedFeatureCount; ++value_requestedfeatures_inc) {
            std::string requestedfeatures_array_prefix = requestedfeatures_prefix;
            requestedfeatures_array_prefix += "[";
            requestedfeatures_array_prefix += std::to_string(value_requestedfeatures_inc);
            requestedfeatures_array_prefix += "]";
            contents.emplace_back("const XrSceneComputeFeatureMSFT*", requestedfeatures_array_prefix, std::to_string(value->requestedFeatures[value_requestedfeatures_inc]));
        }
        std::string consistency_prefix = prefix;
        consistency_prefix += "consistency";
        contents.emplace_back("XrSceneComputeConsistencyMSFT", consistency_prefix, std::to_string(value->consistency));
        std::string bounds_prefix = prefix;
        bounds_prefix += "bounds";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->bounds, bounds_prefix, "XrSceneBoundsMSFT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVisualMeshComputeLodInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string lod_prefix = prefix;
        lod_prefix += "lod";
        contents.emplace_back("XrMeshComputeLodMSFT", lod_prefix, std::to_string(value->lod));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneComponentMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string componenttype_prefix = prefix;
        componenttype_prefix += "componentType";
        contents.emplace_back("XrSceneComponentTypeMSFT", componenttype_prefix, std::to_string(value->componentType));
        std::string id_prefix = prefix;
        id_prefix += "id";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->id, id_prefix, "XrUuidMSFT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string parentid_prefix = prefix;
        parentid_prefix += "parentId";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->parentId, parentid_prefix, "XrUuidMSFT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string updatetime_prefix = prefix;
        updatetime_prefix += "updateTime";
        contents.emplace_back("XrTime", updatetime_prefix, std::to_string(value->updateTime));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneComponentsMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string componentcapacityinput_prefix = prefix;
        componentcapacityinput_prefix += "componentCapacityInput";
        std::ostringstream oss_componentCapacityInput;
        oss_componentCapacityInput << "0x" << std::hex << (value->componentCapacityInput);
        contents.emplace_back("uint32_t", componentcapacityinput_prefix, oss_componentCapacityInput.str());
        std::string componentcountoutput_prefix = prefix;
        componentcountoutput_prefix += "componentCountOutput";
        std::ostringstream oss_componentCountOutput;
        oss_componentCountOutput << "0x" << std::hex << (value->componentCountOutput);
        contents.emplace_back("uint32_t", componentcountoutput_prefix, oss_componentCountOutput.str());
        std::string components_prefix = prefix;
        components_prefix += "components";
        std::ostringstream oss_components;
        oss_components << std::hex << reinterpret_cast<const void*>(value->components);
        contents.emplace_back("XrSceneComponentMSFT*", components_prefix, oss_components.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneComponentsGetInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string componenttype_prefix = prefix;
        componenttype_prefix += "componentType";
        contents.emplace_back("XrSceneComponentTypeMSFT", componenttype_prefix, std::to_string(value->componentType));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneComponentLocationMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrSpaceLocationFlags", flags_prefix, std::to_string(value->flags));
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneComponentLocationsMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string locationcount_prefix = prefix;
        locationcount_prefix += "locationCount";
        std::ostringstream oss_locationCount;
        oss_locationCount << "0x" << std::hex << (value->locationCount);
        contents.emplace_back("uint32_t", locationcount_prefix, oss_locationCount.str());
        std::string locations_prefix = prefix;
        locations_prefix += "locations";
        std::ostringstream oss_locations;
        oss_locations << std::hex << reinterpret_cast<const void*>(value->locations);
        contents.emplace_back("XrSceneComponentLocationMSFT*", locations_prefix, oss_locations.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneComponentsLocateInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        std::string componentidcount_prefix = prefix;
        componentidcount_prefix += "componentIdCount";
        std::ostringstream oss_componentIdCount;
        oss_componentIdCount << "0x" << std::hex << (value->componentIdCount);
        contents.emplace_back("uint32_t", componentidcount_prefix, oss_componentIdCount.str());
        std::string componentids_prefix = prefix;
        componentids_prefix += "componentIds";
        std::ostringstream oss_componentIds_array;
        oss_componentIds_array << std::hex << reinterpret_cast<const void*>(value->componentIds);
        contents.emplace_back("const XrUuidMSFT*", componentids_prefix, oss_componentIds_array.str());
        for (uint32_t value_componentids_inc = 0; value_componentids_inc < value->componentIdCount; ++value_componentids_inc) {
            std::string componentids_array_prefix = componentids_prefix;
            componentids_array_prefix += "[";
            componentids_array_prefix += std::to_string(value_componentids_inc);
            componentids_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->componentIds[value_componentids_inc], componentids_array_prefix, "const XrUuidMSFT*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneObjectMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string objecttype_prefix = prefix;
        objecttype_prefix += "objectType";
        contents.emplace_back("XrSceneObjectTypeMSFT", objecttype_prefix, std::to_string(value->objectType));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneObjectsMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string sceneobjectcount_prefix = prefix;
        sceneobjectcount_prefix += "sceneObjectCount";
        std::ostringstream oss_sceneObjectCount;
        oss_sceneObjectCount << "0x" << std::hex << (value->sceneObjectCount);
        contents.emplace_back("uint32_t", sceneobjectcount_prefix, oss_sceneObjectCount.str());
        std::string sceneobjects_prefix = prefix;
        sceneobjects_prefix += "sceneObjects";
        std::ostringstream oss_sceneObjects;
        oss_sceneObjects << std::hex << reinterpret_cast<const void*>(value->sceneObjects);
        contents.emplace_back("XrSceneObjectMSFT*", sceneobjects_prefix, oss_sceneObjects.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneComponentParentFilterInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string parentid_prefix = prefix;
        parentid_prefix += "parentId";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->parentId, parentid_prefix, "XrUuidMSFT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneObjectTypesFilterInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string objecttypecount_prefix = prefix;
        objecttypecount_prefix += "objectTypeCount";
        std::ostringstream oss_objectTypeCount;
        oss_objectTypeCount << "0x" << std::hex << (value->objectTypeCount);
        contents.emplace_back("uint32_t", objecttypecount_prefix, oss_objectTypeCount.str());
        std::string objecttypes_prefix = prefix;
        objecttypes_prefix += "objectTypes";
        std::ostringstream oss_objectTypes_array;
        oss_objectTypes_array << std::hex << reinterpret_cast<const void*>(value->objectTypes);
        contents.emplace_back("const XrSceneObjectTypeMSFT*", objecttypes_prefix, oss_objectTypes_array.str());
        for (uint32_t value_objecttypes_inc = 0; value_objecttypes_inc < value->objectTypeCount; ++value_objecttypes_inc) {
            std::string objecttypes_array_prefix = objecttypes_prefix;
            objecttypes_array_prefix += "[";
            objecttypes_array_prefix += std::to_string(value_objecttypes_inc);
            objecttypes_array_prefix += "]";
            contents.emplace_back("const XrSceneObjectTypeMSFT*", objecttypes_array_prefix, std::to_string(value->objectTypes[value_objecttypes_inc]));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrScenePlaneMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string alignment_prefix = prefix;
        alignment_prefix += "alignment";
        contents.emplace_back("XrScenePlaneAlignmentTypeMSFT", alignment_prefix, std::to_string(value->alignment));
        std::string size_prefix = prefix;
        size_prefix += "size";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->size, size_prefix, "XrExtent2Df", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string meshbufferid_prefix = prefix;
        meshbufferid_prefix += "meshBufferId";
        std::ostringstream oss_meshBufferId;
        oss_meshBufferId << "0x" << std::hex << (value->meshBufferId);
        contents.emplace_back("uint64_t", meshbufferid_prefix, oss_meshBufferId.str());
        std::string supportsindicesuint16_prefix = prefix;
        supportsindicesuint16_prefix += "supportsIndicesUint16";
        std::ostringstream oss_supportsIndicesUint16;
        oss_supportsIndicesUint16 << "0x" << std::hex << (value->supportsIndicesUint16);
        contents.emplace_back("XrBool32", supportsindicesuint16_prefix, oss_supportsIndicesUint16.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrScenePlanesMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string sceneplanecount_prefix = prefix;
        sceneplanecount_prefix += "scenePlaneCount";
        std::ostringstream oss_scenePlaneCount;
        oss_scenePlaneCount << "0x" << std::hex << (value->scenePlaneCount);
        contents.emplace_back("uint32_t", sceneplanecount_prefix, oss_scenePlaneCount.str());
        std::string sceneplanes_prefix = prefix;
        sceneplanes_prefix += "scenePlanes";
        std::ostringstream oss_scenePlanes;
        oss_scenePlanes << std::hex << reinterpret_cast<const void*>(value->scenePlanes);
        contents.emplace_back("XrScenePlaneMSFT*", sceneplanes_prefix, oss_scenePlanes.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrScenePlaneAlignmentFilterInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string alignmentcount_prefix = prefix;
        alignmentcount_prefix += "alignmentCount";
        std::ostringstream oss_alignmentCount;
        oss_alignmentCount << "0x" << std::hex << (value->alignmentCount);
        contents.emplace_back("uint32_t", alignmentcount_prefix, oss_alignmentCount.str());
        std::string alignments_prefix = prefix;
        alignments_prefix += "alignments";
        std::ostringstream oss_alignments_array;
        oss_alignments_array << std::hex << reinterpret_cast<const void*>(value->alignments);
        contents.emplace_back("const XrScenePlaneAlignmentTypeMSFT*", alignments_prefix, oss_alignments_array.str());
        for (uint32_t value_alignments_inc = 0; value_alignments_inc < value->alignmentCount; ++value_alignments_inc) {
            std::string alignments_array_prefix = alignments_prefix;
            alignments_array_prefix += "[";
            alignments_array_prefix += std::to_string(value_alignments_inc);
            alignments_array_prefix += "]";
            contents.emplace_back("const XrScenePlaneAlignmentTypeMSFT*", alignments_array_prefix, std::to_string(value->alignments[value_alignments_inc]));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneMeshMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string meshbufferid_prefix = prefix;
        meshbufferid_prefix += "meshBufferId";
        std::ostringstream oss_meshBufferId;
        oss_meshBufferId << "0x" << std::hex << (value->meshBufferId);
        contents.emplace_back("uint64_t", meshbufferid_prefix, oss_meshBufferId.str());
        std::string supportsindicesuint16_prefix = prefix;
        supportsindicesuint16_prefix += "supportsIndicesUint16";
        std::ostringstream oss_supportsIndicesUint16;
        oss_supportsIndicesUint16 << "0x" << std::hex << (value->supportsIndicesUint16);
        contents.emplace_back("XrBool32", supportsindicesuint16_prefix, oss_supportsIndicesUint16.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneMeshesMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string scenemeshcount_prefix = prefix;
        scenemeshcount_prefix += "sceneMeshCount";
        std::ostringstream oss_sceneMeshCount;
        oss_sceneMeshCount << "0x" << std::hex << (value->sceneMeshCount);
        contents.emplace_back("uint32_t", scenemeshcount_prefix, oss_sceneMeshCount.str());
        std::string scenemeshes_prefix = prefix;
        scenemeshes_prefix += "sceneMeshes";
        std::ostringstream oss_sceneMeshes;
        oss_sceneMeshes << std::hex << reinterpret_cast<const void*>(value->sceneMeshes);
        contents.emplace_back("XrSceneMeshMSFT*", scenemeshes_prefix, oss_sceneMeshes.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneMeshBuffersGetInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string meshbufferid_prefix = prefix;
        meshbufferid_prefix += "meshBufferId";
        std::ostringstream oss_meshBufferId;
        oss_meshBufferId << "0x" << std::hex << (value->meshBufferId);
        contents.emplace_back("uint64_t", meshbufferid_prefix, oss_meshBufferId.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneMeshBuffersMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneMeshVertexBufferMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string vertexcapacityinput_prefix = prefix;
        vertexcapacityinput_prefix += "vertexCapacityInput";
        std::ostringstream oss_vertexCapacityInput;
        oss_vertexCapacityInput << "0x" << std::hex << (value->vertexCapacityInput);
        contents.emplace_back("uint32_t", vertexcapacityinput_prefix, oss_vertexCapacityInput.str());
        std::string vertexcountoutput_prefix = prefix;
        vertexcountoutput_prefix += "vertexCountOutput";
        std::ostringstream oss_vertexCountOutput;
        oss_vertexCountOutput << "0x" << std::hex << (value->vertexCountOutput);
        contents.emplace_back("uint32_t", vertexcountoutput_prefix, oss_vertexCountOutput.str());
        std::string vertices_prefix = prefix;
        vertices_prefix += "vertices";
        std::ostringstream oss_vertices;
        oss_vertices << std::hex << reinterpret_cast<const void*>(value->vertices);
        contents.emplace_back("XrVector3f*", vertices_prefix, oss_vertices.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneMeshIndicesUint32MSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string indexcapacityinput_prefix = prefix;
        indexcapacityinput_prefix += "indexCapacityInput";
        std::ostringstream oss_indexCapacityInput;
        oss_indexCapacityInput << "0x" << std::hex << (value->indexCapacityInput);
        contents.emplace_back("uint32_t", indexcapacityinput_prefix, oss_indexCapacityInput.str());
        std::string indexcountoutput_prefix = prefix;
        indexcountoutput_prefix += "indexCountOutput";
        std::ostringstream oss_indexCountOutput;
        oss_indexCountOutput << "0x" << std::hex << (value->indexCountOutput);
        contents.emplace_back("uint32_t", indexcountoutput_prefix, oss_indexCountOutput.str());
        std::string indices_prefix = prefix;
        indices_prefix += "indices";
        std::ostringstream oss_indices;
        oss_indices << "0x" << std::hex << (value->indices);
        contents.emplace_back("uint32_t*", indices_prefix, oss_indices.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneMeshIndicesUint16MSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string indexcapacityinput_prefix = prefix;
        indexcapacityinput_prefix += "indexCapacityInput";
        std::ostringstream oss_indexCapacityInput;
        oss_indexCapacityInput << "0x" << std::hex << (value->indexCapacityInput);
        contents.emplace_back("uint32_t", indexcapacityinput_prefix, oss_indexCapacityInput.str());
        std::string indexcountoutput_prefix = prefix;
        indexcountoutput_prefix += "indexCountOutput";
        std::ostringstream oss_indexCountOutput;
        oss_indexCountOutput << "0x" << std::hex << (value->indexCountOutput);
        contents.emplace_back("uint32_t", indexcountoutput_prefix, oss_indexCountOutput.str());
        std::string indices_prefix = prefix;
        indices_prefix += "indices";
        std::ostringstream oss_indices;
        oss_indices << "0x" << std::hex << (value->indices);
        contents.emplace_back("uint16_t*", indices_prefix, oss_indices.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSerializedSceneFragmentDataGetInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string scenefragmentid_prefix = prefix;
        scenefragmentid_prefix += "sceneFragmentId";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->sceneFragmentId, scenefragmentid_prefix, "XrUuidMSFT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrDeserializeSceneFragmentMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string buffersize_prefix = prefix;
        buffersize_prefix += "bufferSize";
        std::ostringstream oss_bufferSize;
        oss_bufferSize << "0x" << std::hex << (value->bufferSize);
        contents.emplace_back("uint32_t", buffersize_prefix, oss_bufferSize.str());
        std::string buffer_prefix = prefix;
        buffer_prefix += "buffer";
        std::ostringstream oss_buffer_array;
        oss_buffer_array << std::hex << (value->buffer);
        contents.emplace_back("const uint8_t*", buffer_prefix, oss_buffer_array.str());
        for (uint32_t value_buffer_inc = 0; value_buffer_inc < value->bufferSize; ++value_buffer_inc) {
            std::string buffer_array_prefix = buffer_prefix;
            buffer_array_prefix += "[";
            buffer_array_prefix += std::to_string(value_buffer_inc);
            buffer_array_prefix += "]";
            std::ostringstream oss_buffer;
            oss_buffer << "0x" << std::hex << (value->buffer[value_buffer_inc]);
            contents.emplace_back("const uint8_t*", buffer_array_prefix, oss_buffer.str());
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneDeserializeInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string fragmentcount_prefix = prefix;
        fragmentcount_prefix += "fragmentCount";
        std::ostringstream oss_fragmentCount;
        oss_fragmentCount << "0x" << std::hex << (value->fragmentCount);
        contents.emplace_back("uint32_t", fragmentcount_prefix, oss_fragmentCount.str());
        std::string fragments_prefix = prefix;
        fragments_prefix += "fragments";
        std::ostringstream oss_fragments_array;
        oss_fragments_array << std::hex << reinterpret_cast<const void*>(value->fragments);
        contents.emplace_back("const XrDeserializeSceneFragmentMSFT*", fragments_prefix, oss_fragments_array.str());
        for (uint32_t value_fragments_inc = 0; value_fragments_inc < value->fragmentCount; ++value_fragments_inc) {
            std::string fragments_array_prefix = fragments_prefix;
            fragments_array_prefix += "[";
            fragments_array_prefix += std::to_string(value_fragments_inc);
            fragments_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->fragments[value_fragments_inc], fragments_array_prefix, "const XrDeserializeSceneFragmentMSFT*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataDisplayRefreshRateChangedFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string fromdisplayrefreshrate_prefix = prefix;
        fromdisplayrefreshrate_prefix += "fromDisplayRefreshRate";
        std::ostringstream oss_fromDisplayRefreshRate;
        oss_fromDisplayRefreshRate << std::setprecision(32) << (value->fromDisplayRefreshRate);
        contents.emplace_back("float", fromdisplayrefreshrate_prefix, oss_fromDisplayRefreshRate.str());
        std::string todisplayrefreshrate_prefix = prefix;
        todisplayrefreshrate_prefix += "toDisplayRefreshRate";
        std::ostringstream oss_toDisplayRefreshRate;
        oss_toDisplayRefreshRate << std::setprecision(32) << (value->toDisplayRefreshRate);
        contents.emplace_back("float", todisplayrefreshrate_prefix, oss_toDisplayRefreshRate.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrViveTrackerPathsHTCX* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string persistentpath_prefix = prefix;
        persistentpath_prefix += "persistentPath";
        contents.emplace_back("XrPath", persistentpath_prefix, std::to_string(value->persistentPath));
        std::string rolepath_prefix = prefix;
        rolepath_prefix += "rolePath";
        contents.emplace_back("XrPath", rolepath_prefix, std::to_string(value->rolePath));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataViveTrackerConnectedHTCX* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string paths_prefix = prefix;
        paths_prefix += "paths";
        std::ostringstream oss_paths;
        oss_paths << std::hex << reinterpret_cast<const void*>(value->paths);
        contents.emplace_back("XrViveTrackerPathsHTCX*", paths_prefix, oss_paths.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemFacialTrackingPropertiesHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supporteyefacialtracking_prefix = prefix;
        supporteyefacialtracking_prefix += "supportEyeFacialTracking";
        std::ostringstream oss_supportEyeFacialTracking;
        oss_supportEyeFacialTracking << "0x" << std::hex << (value->supportEyeFacialTracking);
        contents.emplace_back("XrBool32", supporteyefacialtracking_prefix, oss_supportEyeFacialTracking.str());
        std::string supportlipfacialtracking_prefix = prefix;
        supportlipfacialtracking_prefix += "supportLipFacialTracking";
        std::ostringstream oss_supportLipFacialTracking;
        oss_supportLipFacialTracking << "0x" << std::hex << (value->supportLipFacialTracking);
        contents.emplace_back("XrBool32", supportlipfacialtracking_prefix, oss_supportLipFacialTracking.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFacialExpressionsHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string isactive_prefix = prefix;
        isactive_prefix += "isActive";
        std::ostringstream oss_isActive;
        oss_isActive << "0x" << std::hex << (value->isActive);
        contents.emplace_back("XrBool32", isactive_prefix, oss_isActive.str());
        std::string sampletime_prefix = prefix;
        sampletime_prefix += "sampleTime";
        contents.emplace_back("XrTime", sampletime_prefix, std::to_string(value->sampleTime));
        std::string expressioncount_prefix = prefix;
        expressioncount_prefix += "expressionCount";
        std::ostringstream oss_expressionCount;
        oss_expressionCount << "0x" << std::hex << (value->expressionCount);
        contents.emplace_back("uint32_t", expressioncount_prefix, oss_expressionCount.str());
        std::string expressionweightings_prefix = prefix;
        expressionweightings_prefix += "expressionWeightings";
        std::ostringstream oss_expressionWeightings;
        oss_expressionWeightings << std::setprecision(32) << (value->expressionWeightings);
        contents.emplace_back("float*", expressionweightings_prefix, oss_expressionWeightings.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFacialTrackerCreateInfoHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string facialtrackingtype_prefix = prefix;
        facialtrackingtype_prefix += "facialTrackingType";
        contents.emplace_back("XrFacialTrackingTypeHTC", facialtrackingtype_prefix, std::to_string(value->facialTrackingType));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemColorSpacePropertiesFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string colorspace_prefix = prefix;
        colorspace_prefix += "colorSpace";
        contents.emplace_back("XrColorSpaceFB", colorspace_prefix, std::to_string(value->colorSpace));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVector4sFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string x_prefix = prefix;
        x_prefix += "x";
        contents.emplace_back("int16_t", x_prefix, std::to_string(value->x));
        std::string y_prefix = prefix;
        y_prefix += "y";
        contents.emplace_back("int16_t", y_prefix, std::to_string(value->y));
        std::string z_prefix = prefix;
        z_prefix += "z";
        contents.emplace_back("int16_t", z_prefix, std::to_string(value->z));
        std::string w_prefix = prefix;
        w_prefix += "w";
        contents.emplace_back("int16_t", w_prefix, std::to_string(value->w));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandTrackingMeshFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string jointcapacityinput_prefix = prefix;
        jointcapacityinput_prefix += "jointCapacityInput";
        std::ostringstream oss_jointCapacityInput;
        oss_jointCapacityInput << "0x" << std::hex << (value->jointCapacityInput);
        contents.emplace_back("uint32_t", jointcapacityinput_prefix, oss_jointCapacityInput.str());
        std::string jointcountoutput_prefix = prefix;
        jointcountoutput_prefix += "jointCountOutput";
        std::ostringstream oss_jointCountOutput;
        oss_jointCountOutput << "0x" << std::hex << (value->jointCountOutput);
        contents.emplace_back("uint32_t", jointcountoutput_prefix, oss_jointCountOutput.str());
        std::string jointbindposes_prefix = prefix;
        jointbindposes_prefix += "jointBindPoses";
        std::ostringstream oss_jointBindPoses;
        oss_jointBindPoses << std::hex << reinterpret_cast<const void*>(value->jointBindPoses);
        contents.emplace_back("XrPosef*", jointbindposes_prefix, oss_jointBindPoses.str());
        std::string jointradii_prefix = prefix;
        jointradii_prefix += "jointRadii";
        std::ostringstream oss_jointRadii;
        oss_jointRadii << std::setprecision(32) << (value->jointRadii);
        contents.emplace_back("float*", jointradii_prefix, oss_jointRadii.str());
        std::string jointparents_prefix = prefix;
        jointparents_prefix += "jointParents";
        std::ostringstream oss_jointParents;
        oss_jointParents << std::hex << reinterpret_cast<const void*>(value->jointParents);
        contents.emplace_back("XrHandJointEXT*", jointparents_prefix, oss_jointParents.str());
        std::string vertexcapacityinput_prefix = prefix;
        vertexcapacityinput_prefix += "vertexCapacityInput";
        std::ostringstream oss_vertexCapacityInput;
        oss_vertexCapacityInput << "0x" << std::hex << (value->vertexCapacityInput);
        contents.emplace_back("uint32_t", vertexcapacityinput_prefix, oss_vertexCapacityInput.str());
        std::string vertexcountoutput_prefix = prefix;
        vertexcountoutput_prefix += "vertexCountOutput";
        std::ostringstream oss_vertexCountOutput;
        oss_vertexCountOutput << "0x" << std::hex << (value->vertexCountOutput);
        contents.emplace_back("uint32_t", vertexcountoutput_prefix, oss_vertexCountOutput.str());
        std::string vertexpositions_prefix = prefix;
        vertexpositions_prefix += "vertexPositions";
        std::ostringstream oss_vertexPositions;
        oss_vertexPositions << std::hex << reinterpret_cast<const void*>(value->vertexPositions);
        contents.emplace_back("XrVector3f*", vertexpositions_prefix, oss_vertexPositions.str());
        std::string vertexnormals_prefix = prefix;
        vertexnormals_prefix += "vertexNormals";
        std::ostringstream oss_vertexNormals;
        oss_vertexNormals << std::hex << reinterpret_cast<const void*>(value->vertexNormals);
        contents.emplace_back("XrVector3f*", vertexnormals_prefix, oss_vertexNormals.str());
        std::string vertexuvs_prefix = prefix;
        vertexuvs_prefix += "vertexUVs";
        std::ostringstream oss_vertexUVs;
        oss_vertexUVs << std::hex << reinterpret_cast<const void*>(value->vertexUVs);
        contents.emplace_back("XrVector2f*", vertexuvs_prefix, oss_vertexUVs.str());
        std::string vertexblendindices_prefix = prefix;
        vertexblendindices_prefix += "vertexBlendIndices";
        std::ostringstream oss_vertexBlendIndices;
        oss_vertexBlendIndices << std::hex << reinterpret_cast<const void*>(value->vertexBlendIndices);
        contents.emplace_back("XrVector4sFB*", vertexblendindices_prefix, oss_vertexBlendIndices.str());
        std::string vertexblendweights_prefix = prefix;
        vertexblendweights_prefix += "vertexBlendWeights";
        std::ostringstream oss_vertexBlendWeights;
        oss_vertexBlendWeights << std::hex << reinterpret_cast<const void*>(value->vertexBlendWeights);
        contents.emplace_back("XrVector4f*", vertexblendweights_prefix, oss_vertexBlendWeights.str());
        std::string indexcapacityinput_prefix = prefix;
        indexcapacityinput_prefix += "indexCapacityInput";
        std::ostringstream oss_indexCapacityInput;
        oss_indexCapacityInput << "0x" << std::hex << (value->indexCapacityInput);
        contents.emplace_back("uint32_t", indexcapacityinput_prefix, oss_indexCapacityInput.str());
        std::string indexcountoutput_prefix = prefix;
        indexcountoutput_prefix += "indexCountOutput";
        std::ostringstream oss_indexCountOutput;
        oss_indexCountOutput << "0x" << std::hex << (value->indexCountOutput);
        contents.emplace_back("uint32_t", indexcountoutput_prefix, oss_indexCountOutput.str());
        std::string indices_prefix = prefix;
        indices_prefix += "indices";
        std::ostringstream oss_indices;
        oss_indices << std::hex << reinterpret_cast<const void*>(value->indices);
        contents.emplace_back("int16_t*", indices_prefix, oss_indices.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandTrackingScaleFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string sensoroutput_prefix = prefix;
        sensoroutput_prefix += "sensorOutput";
        std::ostringstream oss_sensorOutput;
        oss_sensorOutput << std::setprecision(32) << (value->sensorOutput);
        contents.emplace_back("float", sensoroutput_prefix, oss_sensorOutput.str());
        std::string currentoutput_prefix = prefix;
        currentoutput_prefix += "currentOutput";
        std::ostringstream oss_currentOutput;
        oss_currentOutput << std::setprecision(32) << (value->currentOutput);
        contents.emplace_back("float", currentoutput_prefix, oss_currentOutput.str());
        std::string overridehandscale_prefix = prefix;
        overridehandscale_prefix += "overrideHandScale";
        std::ostringstream oss_overrideHandScale;
        oss_overrideHandScale << "0x" << std::hex << (value->overrideHandScale);
        contents.emplace_back("XrBool32", overridehandscale_prefix, oss_overrideHandScale.str());
        std::string overridevalueinput_prefix = prefix;
        overridevalueinput_prefix += "overrideValueInput";
        std::ostringstream oss_overrideValueInput;
        oss_overrideValueInput << std::setprecision(32) << (value->overrideValueInput);
        contents.emplace_back("float", overridevalueinput_prefix, oss_overrideValueInput.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandTrackingAimStateFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string status_prefix = prefix;
        status_prefix += "status";
        contents.emplace_back("XrHandTrackingAimFlagsFB", status_prefix, std::to_string(value->status));
        std::string aimpose_prefix = prefix;
        aimpose_prefix += "aimPose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->aimPose, aimpose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string pinchstrengthindex_prefix = prefix;
        pinchstrengthindex_prefix += "pinchStrengthIndex";
        std::ostringstream oss_pinchStrengthIndex;
        oss_pinchStrengthIndex << std::setprecision(32) << (value->pinchStrengthIndex);
        contents.emplace_back("float", pinchstrengthindex_prefix, oss_pinchStrengthIndex.str());
        std::string pinchstrengthmiddle_prefix = prefix;
        pinchstrengthmiddle_prefix += "pinchStrengthMiddle";
        std::ostringstream oss_pinchStrengthMiddle;
        oss_pinchStrengthMiddle << std::setprecision(32) << (value->pinchStrengthMiddle);
        contents.emplace_back("float", pinchstrengthmiddle_prefix, oss_pinchStrengthMiddle.str());
        std::string pinchstrengthring_prefix = prefix;
        pinchstrengthring_prefix += "pinchStrengthRing";
        std::ostringstream oss_pinchStrengthRing;
        oss_pinchStrengthRing << std::setprecision(32) << (value->pinchStrengthRing);
        contents.emplace_back("float", pinchstrengthring_prefix, oss_pinchStrengthRing.str());
        std::string pinchstrengthlittle_prefix = prefix;
        pinchstrengthlittle_prefix += "pinchStrengthLittle";
        std::ostringstream oss_pinchStrengthLittle;
        oss_pinchStrengthLittle << std::setprecision(32) << (value->pinchStrengthLittle);
        contents.emplace_back("float", pinchstrengthlittle_prefix, oss_pinchStrengthLittle.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandCapsuleFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string points_prefix = prefix;
        points_prefix += "points";
        std::ostringstream oss_points_array;
        oss_points_array << std::hex << reinterpret_cast<const void*>(value->points);
        contents.emplace_back("XrVector3f*", points_prefix, oss_points_array.str());
        for (uint32_t value_points_inc = 0; value_points_inc < XR_HAND_TRACKING_CAPSULE_POINT_COUNT_FB; ++value_points_inc) {
            std::string points_array_prefix = points_prefix;
            points_array_prefix += "[";
            points_array_prefix += std::to_string(value_points_inc);
            points_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->points[value_points_inc], points_array_prefix, "XrVector3f", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        std::string radius_prefix = prefix;
        radius_prefix += "radius";
        std::ostringstream oss_radius;
        oss_radius << std::setprecision(32) << (value->radius);
        contents.emplace_back("float", radius_prefix, oss_radius.str());
        std::string joint_prefix = prefix;
        joint_prefix += "joint";
        contents.emplace_back("XrHandJointEXT", joint_prefix, std::to_string(value->joint));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandTrackingCapsulesStateFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string capsules_prefix = prefix;
        capsules_prefix += "capsules";
        std::ostringstream oss_capsules;
        oss_capsules << std::hex << reinterpret_cast<const void*>(value->capsules);
        contents.emplace_back("XrHandCapsuleFB*", capsules_prefix, oss_capsules.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemSpatialEntityPropertiesFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsspatialentity_prefix = prefix;
        supportsspatialentity_prefix += "supportsSpatialEntity";
        std::ostringstream oss_supportsSpatialEntity;
        oss_supportsSpatialEntity << "0x" << std::hex << (value->supportsSpatialEntity);
        contents.emplace_back("XrBool32", supportsspatialentity_prefix, oss_supportsSpatialEntity.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorCreateInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string poseinspace_prefix = prefix;
        poseinspace_prefix += "poseInSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInSpace, poseinspace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceComponentStatusSetInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string componenttype_prefix = prefix;
        componenttype_prefix += "componentType";
        contents.emplace_back("XrSpaceComponentTypeFB", componenttype_prefix, std::to_string(value->componentType));
        std::string enabled_prefix = prefix;
        enabled_prefix += "enabled";
        std::ostringstream oss_enabled;
        oss_enabled << "0x" << std::hex << (value->enabled);
        contents.emplace_back("XrBool32", enabled_prefix, oss_enabled.str());
        std::string timeout_prefix = prefix;
        timeout_prefix += "timeout";
        contents.emplace_back("XrDuration", timeout_prefix, std::to_string(value->timeout));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceComponentStatusFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string enabled_prefix = prefix;
        enabled_prefix += "enabled";
        std::ostringstream oss_enabled;
        oss_enabled << "0x" << std::hex << (value->enabled);
        contents.emplace_back("XrBool32", enabled_prefix, oss_enabled.str());
        std::string changepending_prefix = prefix;
        changepending_prefix += "changePending";
        std::ostringstream oss_changePending;
        oss_changePending << "0x" << std::hex << (value->changePending);
        contents.emplace_back("XrBool32", changepending_prefix, oss_changePending.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataSpatialAnchorCreateCompleteFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestid_prefix = prefix;
        requestid_prefix += "requestId";
        contents.emplace_back("XrAsyncRequestIdFB", requestid_prefix, std::to_string(value->requestId));
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string uuid_prefix = prefix;
        uuid_prefix += "uuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuid, uuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataSpaceSetStatusCompleteFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestid_prefix = prefix;
        requestid_prefix += "requestId";
        contents.emplace_back("XrAsyncRequestIdFB", requestid_prefix, std::to_string(value->requestId));
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string uuid_prefix = prefix;
        uuid_prefix += "uuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuid, uuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string componenttype_prefix = prefix;
        componenttype_prefix += "componentType";
        contents.emplace_back("XrSpaceComponentTypeFB", componenttype_prefix, std::to_string(value->componentType));
        std::string enabled_prefix = prefix;
        enabled_prefix += "enabled";
        std::ostringstream oss_enabled;
        oss_enabled << "0x" << std::hex << (value->enabled);
        contents.emplace_back("XrBool32", enabled_prefix, oss_enabled.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFoveationProfileCreateInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainCreateInfoFoveationFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrSwapchainCreateFoveationFlagsFB", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainStateFoveationFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrSwapchainStateFoveationFlagsFB", flags_prefix, std::to_string(value->flags));
        std::string profile_prefix = prefix;
        profile_prefix += "profile";
        std::ostringstream oss_profile;
        oss_profile << std::hex << reinterpret_cast<const void*>(value->profile);
        contents.emplace_back("XrFoveationProfileFB", profile_prefix, oss_profile.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFoveationLevelProfileCreateInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string level_prefix = prefix;
        level_prefix += "level";
        contents.emplace_back("XrFoveationLevelFB", level_prefix, std::to_string(value->level));
        std::string verticaloffset_prefix = prefix;
        verticaloffset_prefix += "verticalOffset";
        std::ostringstream oss_verticalOffset;
        oss_verticalOffset << std::setprecision(32) << (value->verticalOffset);
        contents.emplace_back("float", verticaloffset_prefix, oss_verticalOffset.str());
        std::string dynamic_prefix = prefix;
        dynamic_prefix += "dynamic";
        contents.emplace_back("XrFoveationDynamicFB", dynamic_prefix, std::to_string(value->dynamic));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemKeyboardTrackingPropertiesFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportskeyboardtracking_prefix = prefix;
        supportskeyboardtracking_prefix += "supportsKeyboardTracking";
        std::ostringstream oss_supportsKeyboardTracking;
        oss_supportsKeyboardTracking << "0x" << std::hex << (value->supportsKeyboardTracking);
        contents.emplace_back("XrBool32", supportskeyboardtracking_prefix, oss_supportsKeyboardTracking.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrKeyboardTrackingDescriptionFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string trackedkeyboardid_prefix = prefix;
        trackedkeyboardid_prefix += "trackedKeyboardId";
        std::ostringstream oss_trackedKeyboardId;
        oss_trackedKeyboardId << "0x" << std::hex << (value->trackedKeyboardId);
        contents.emplace_back("uint64_t", trackedkeyboardid_prefix, oss_trackedKeyboardId.str());
        std::string size_prefix = prefix;
        size_prefix += "size";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->size, size_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrKeyboardTrackingFlagsFB", flags_prefix, std::to_string(value->flags));
        std::string name_prefix = prefix;
        name_prefix += "name";
        contents.emplace_back("char*", name_prefix, value->name);
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrKeyboardSpaceCreateInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string trackedkeyboardid_prefix = prefix;
        trackedkeyboardid_prefix += "trackedKeyboardId";
        std::ostringstream oss_trackedKeyboardId;
        oss_trackedKeyboardId << "0x" << std::hex << (value->trackedKeyboardId);
        contents.emplace_back("uint64_t", trackedkeyboardid_prefix, oss_trackedKeyboardId.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrKeyboardTrackingQueryFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrKeyboardTrackingQueryFlagsFB", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrTriangleMeshCreateInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrTriangleMeshFlagsFB", flags_prefix, std::to_string(value->flags));
        std::string windingorder_prefix = prefix;
        windingorder_prefix += "windingOrder";
        contents.emplace_back("XrWindingOrderFB", windingorder_prefix, std::to_string(value->windingOrder));
        std::string vertexcount_prefix = prefix;
        vertexcount_prefix += "vertexCount";
        std::ostringstream oss_vertexCount;
        oss_vertexCount << "0x" << std::hex << (value->vertexCount);
        contents.emplace_back("uint32_t", vertexcount_prefix, oss_vertexCount.str());
        std::string vertexbuffer_prefix = prefix;
        vertexbuffer_prefix += "vertexBuffer";
        if (nullptr == value->vertexBuffer) {
            std::ostringstream oss_vertexBuffer;
            oss_vertexBuffer << std::hex << reinterpret_cast<const void*>(value->vertexBuffer);
            contents.emplace_back("const XrVector3f*", vertexbuffer_prefix, oss_vertexBuffer.str());
        } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, value->vertexBuffer, vertexbuffer_prefix, "const XrVector3f*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string trianglecount_prefix = prefix;
        trianglecount_prefix += "triangleCount";
        std::ostringstream oss_triangleCount;
        oss_triangleCount << "0x" << std::hex << (value->triangleCount);
        contents.emplace_back("uint32_t", trianglecount_prefix, oss_triangleCount.str());
        std::string indexbuffer_prefix = prefix;
        indexbuffer_prefix += "indexBuffer";
        if (nullptr == value->indexBuffer) {
            std::ostringstream oss_indexBuffer;
            oss_indexBuffer << std::hex << (value->indexBuffer);
            contents.emplace_back("const uint32_t*", indexbuffer_prefix, oss_indexBuffer.str());
        } else {
            std::ostringstream oss_indexBuffer;
            oss_indexBuffer << std::hex << (*value->indexBuffer);
            contents.emplace_back("const uint32_t*", indexbuffer_prefix, oss_indexBuffer.str());
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemPassthroughPropertiesFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportspassthrough_prefix = prefix;
        supportspassthrough_prefix += "supportsPassthrough";
        std::ostringstream oss_supportsPassthrough;
        oss_supportsPassthrough << "0x" << std::hex << (value->supportsPassthrough);
        contents.emplace_back("XrBool32", supportspassthrough_prefix, oss_supportsPassthrough.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemPassthroughProperties2FB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string capabilities_prefix = prefix;
        capabilities_prefix += "capabilities";
        contents.emplace_back("XrPassthroughCapabilityFlagsFB", capabilities_prefix, std::to_string(value->capabilities));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughCreateInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrPassthroughFlagsFB", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughLayerCreateInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string passthrough_prefix = prefix;
        passthrough_prefix += "passthrough";
        std::ostringstream oss_passthrough;
        oss_passthrough << std::hex << reinterpret_cast<const void*>(value->passthrough);
        contents.emplace_back("XrPassthroughFB", passthrough_prefix, oss_passthrough.str());
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrPassthroughFlagsFB", flags_prefix, std::to_string(value->flags));
        std::string purpose_prefix = prefix;
        purpose_prefix += "purpose";
        contents.emplace_back("XrPassthroughLayerPurposeFB", purpose_prefix, std::to_string(value->purpose));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerPassthroughFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrCompositionLayerFlags", flags_prefix, std::to_string(value->flags));
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string layerhandle_prefix = prefix;
        layerhandle_prefix += "layerHandle";
        std::ostringstream oss_layerHandle;
        oss_layerHandle << std::hex << reinterpret_cast<const void*>(value->layerHandle);
        contents.emplace_back("XrPassthroughLayerFB", layerhandle_prefix, oss_layerHandle.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGeometryInstanceCreateInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string layer_prefix = prefix;
        layer_prefix += "layer";
        std::ostringstream oss_layer;
        oss_layer << std::hex << reinterpret_cast<const void*>(value->layer);
        contents.emplace_back("XrPassthroughLayerFB", layer_prefix, oss_layer.str());
        std::string mesh_prefix = prefix;
        mesh_prefix += "mesh";
        std::ostringstream oss_mesh;
        oss_mesh << std::hex << reinterpret_cast<const void*>(value->mesh);
        contents.emplace_back("XrTriangleMeshFB", mesh_prefix, oss_mesh.str());
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string scale_prefix = prefix;
        scale_prefix += "scale";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->scale, scale_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGeometryInstanceTransformFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string scale_prefix = prefix;
        scale_prefix += "scale";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->scale, scale_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughStyleFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string textureopacityfactor_prefix = prefix;
        textureopacityfactor_prefix += "textureOpacityFactor";
        std::ostringstream oss_textureOpacityFactor;
        oss_textureOpacityFactor << std::setprecision(32) << (value->textureOpacityFactor);
        contents.emplace_back("float", textureopacityfactor_prefix, oss_textureOpacityFactor.str());
        std::string edgecolor_prefix = prefix;
        edgecolor_prefix += "edgeColor";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->edgeColor, edgecolor_prefix, "XrColor4f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughColorMapMonoToRgbaFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string texturecolormap_prefix = prefix;
        texturecolormap_prefix += "textureColorMap";
        std::ostringstream oss_textureColorMap_array;
        oss_textureColorMap_array << std::hex << reinterpret_cast<const void*>(value->textureColorMap);
        contents.emplace_back("XrColor4f*", texturecolormap_prefix, oss_textureColorMap_array.str());
        for (uint32_t value_texturecolormap_inc = 0; value_texturecolormap_inc < XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB; ++value_texturecolormap_inc) {
            std::string texturecolormap_array_prefix = texturecolormap_prefix;
            texturecolormap_array_prefix += "[";
            texturecolormap_array_prefix += std::to_string(value_texturecolormap_inc);
            texturecolormap_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->textureColorMap[value_texturecolormap_inc], texturecolormap_array_prefix, "XrColor4f", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughColorMapMonoToMonoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string texturecolormap_prefix = prefix;
        texturecolormap_prefix += "textureColorMap";
        std::ostringstream oss_textureColorMap_array;
        oss_textureColorMap_array << "0x" << std::hex << (value->textureColorMap);
        contents.emplace_back("uint8_t*", texturecolormap_prefix, oss_textureColorMap_array.str());
        for (uint32_t value_texturecolormap_inc = 0; value_texturecolormap_inc < XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB; ++value_texturecolormap_inc) {
            std::string texturecolormap_array_prefix = texturecolormap_prefix;
            texturecolormap_array_prefix += "[";
            texturecolormap_array_prefix += std::to_string(value_texturecolormap_inc);
            texturecolormap_array_prefix += "]";
            std::ostringstream oss_textureColorMap;
            oss_textureColorMap << "0x" << std::hex << (value->textureColorMap[value_texturecolormap_inc]);
            contents.emplace_back("uint8_t", texturecolormap_array_prefix, oss_textureColorMap.str());
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughBrightnessContrastSaturationFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string brightness_prefix = prefix;
        brightness_prefix += "brightness";
        std::ostringstream oss_brightness;
        oss_brightness << std::setprecision(32) << (value->brightness);
        contents.emplace_back("float", brightness_prefix, oss_brightness.str());
        std::string contrast_prefix = prefix;
        contrast_prefix += "contrast";
        std::ostringstream oss_contrast;
        oss_contrast << std::setprecision(32) << (value->contrast);
        contents.emplace_back("float", contrast_prefix, oss_contrast.str());
        std::string saturation_prefix = prefix;
        saturation_prefix += "saturation";
        std::ostringstream oss_saturation;
        oss_saturation << std::setprecision(32) << (value->saturation);
        contents.emplace_back("float", saturation_prefix, oss_saturation.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataPassthroughStateChangedFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrPassthroughStateChangedFlagsFB", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrRenderModelPathInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string path_prefix = prefix;
        path_prefix += "path";
        contents.emplace_back("XrPath", path_prefix, std::to_string(value->path));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrRenderModelPropertiesFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string vendorid_prefix = prefix;
        vendorid_prefix += "vendorId";
        std::ostringstream oss_vendorId;
        oss_vendorId << "0x" << std::hex << (value->vendorId);
        contents.emplace_back("uint32_t", vendorid_prefix, oss_vendorId.str());
        std::string modelname_prefix = prefix;
        modelname_prefix += "modelName";
        contents.emplace_back("char*", modelname_prefix, value->modelName);
        std::string modelkey_prefix = prefix;
        modelkey_prefix += "modelKey";
        contents.emplace_back("XrRenderModelKeyFB", modelkey_prefix, std::to_string(value->modelKey));
        std::string modelversion_prefix = prefix;
        modelversion_prefix += "modelVersion";
        std::ostringstream oss_modelVersion;
        oss_modelVersion << "0x" << std::hex << (value->modelVersion);
        contents.emplace_back("uint32_t", modelversion_prefix, oss_modelVersion.str());
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrRenderModelFlagsFB", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrRenderModelBufferFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string buffercapacityinput_prefix = prefix;
        buffercapacityinput_prefix += "bufferCapacityInput";
        std::ostringstream oss_bufferCapacityInput;
        oss_bufferCapacityInput << "0x" << std::hex << (value->bufferCapacityInput);
        contents.emplace_back("uint32_t", buffercapacityinput_prefix, oss_bufferCapacityInput.str());
        std::string buffercountoutput_prefix = prefix;
        buffercountoutput_prefix += "bufferCountOutput";
        std::ostringstream oss_bufferCountOutput;
        oss_bufferCountOutput << "0x" << std::hex << (value->bufferCountOutput);
        contents.emplace_back("uint32_t", buffercountoutput_prefix, oss_bufferCountOutput.str());
        std::string buffer_prefix = prefix;
        buffer_prefix += "buffer";
        std::ostringstream oss_buffer;
        oss_buffer << "0x" << std::hex << (value->buffer);
        contents.emplace_back("uint8_t*", buffer_prefix, oss_buffer.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrRenderModelLoadInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string modelkey_prefix = prefix;
        modelkey_prefix += "modelKey";
        contents.emplace_back("XrRenderModelKeyFB", modelkey_prefix, std::to_string(value->modelKey));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemRenderModelPropertiesFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsrendermodelloading_prefix = prefix;
        supportsrendermodelloading_prefix += "supportsRenderModelLoading";
        std::ostringstream oss_supportsRenderModelLoading;
        oss_supportsRenderModelLoading << "0x" << std::hex << (value->supportsRenderModelLoading);
        contents.emplace_back("XrBool32", supportsrendermodelloading_prefix, oss_supportsRenderModelLoading.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrRenderModelCapabilitiesRequestFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrRenderModelFlagsFB", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrViewLocateFoveatedRenderingVARJO* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string foveatedrenderingactive_prefix = prefix;
        foveatedrenderingactive_prefix += "foveatedRenderingActive";
        std::ostringstream oss_foveatedRenderingActive;
        oss_foveatedRenderingActive << "0x" << std::hex << (value->foveatedRenderingActive);
        contents.emplace_back("XrBool32", foveatedrenderingactive_prefix, oss_foveatedRenderingActive.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFoveatedViewConfigurationViewVARJO* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string foveatedrenderingactive_prefix = prefix;
        foveatedrenderingactive_prefix += "foveatedRenderingActive";
        std::ostringstream oss_foveatedRenderingActive;
        oss_foveatedRenderingActive << "0x" << std::hex << (value->foveatedRenderingActive);
        contents.emplace_back("XrBool32", foveatedrenderingactive_prefix, oss_foveatedRenderingActive.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemFoveatedRenderingPropertiesVARJO* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsfoveatedrendering_prefix = prefix;
        supportsfoveatedrendering_prefix += "supportsFoveatedRendering";
        std::ostringstream oss_supportsFoveatedRendering;
        oss_supportsFoveatedRendering << "0x" << std::hex << (value->supportsFoveatedRendering);
        contents.emplace_back("XrBool32", supportsfoveatedrendering_prefix, oss_supportsFoveatedRendering.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerDepthTestVARJO* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string depthtestrangenearz_prefix = prefix;
        depthtestrangenearz_prefix += "depthTestRangeNearZ";
        std::ostringstream oss_depthTestRangeNearZ;
        oss_depthTestRangeNearZ << std::setprecision(32) << (value->depthTestRangeNearZ);
        contents.emplace_back("float", depthtestrangenearz_prefix, oss_depthTestRangeNearZ.str());
        std::string depthtestrangefarz_prefix = prefix;
        depthtestrangefarz_prefix += "depthTestRangeFarZ";
        std::ostringstream oss_depthTestRangeFarZ;
        oss_depthTestRangeFarZ << std::setprecision(32) << (value->depthTestRangeFarZ);
        contents.emplace_back("float", depthtestrangefarz_prefix, oss_depthTestRangeFarZ.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemMarkerTrackingPropertiesVARJO* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsmarkertracking_prefix = prefix;
        supportsmarkertracking_prefix += "supportsMarkerTracking";
        std::ostringstream oss_supportsMarkerTracking;
        oss_supportsMarkerTracking << "0x" << std::hex << (value->supportsMarkerTracking);
        contents.emplace_back("XrBool32", supportsmarkertracking_prefix, oss_supportsMarkerTracking.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataMarkerTrackingUpdateVARJO* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string markerid_prefix = prefix;
        markerid_prefix += "markerId";
        std::ostringstream oss_markerId;
        oss_markerId << "0x" << std::hex << (value->markerId);
        contents.emplace_back("uint64_t", markerid_prefix, oss_markerId.str());
        std::string isactive_prefix = prefix;
        isactive_prefix += "isActive";
        std::ostringstream oss_isActive;
        oss_isActive << "0x" << std::hex << (value->isActive);
        contents.emplace_back("XrBool32", isactive_prefix, oss_isActive.str());
        std::string ispredicted_prefix = prefix;
        ispredicted_prefix += "isPredicted";
        std::ostringstream oss_isPredicted;
        oss_isPredicted << "0x" << std::hex << (value->isPredicted);
        contents.emplace_back("XrBool32", ispredicted_prefix, oss_isPredicted.str());
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrMarkerSpaceCreateInfoVARJO* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string markerid_prefix = prefix;
        markerid_prefix += "markerId";
        std::ostringstream oss_markerId;
        oss_markerId << "0x" << std::hex << (value->markerId);
        contents.emplace_back("uint64_t", markerid_prefix, oss_markerId.str());
        std::string poseinmarkerspace_prefix = prefix;
        poseinmarkerspace_prefix += "poseInMarkerSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInMarkerSpace, poseinmarkerspace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFrameEndInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string focusdistance_prefix = prefix;
        focusdistance_prefix += "focusDistance";
        std::ostringstream oss_focusDistance;
        oss_focusDistance << std::setprecision(32) << (value->focusDistance);
        contents.emplace_back("float", focusdistance_prefix, oss_focusDistance.str());
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrFrameEndInfoFlagsML", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrGlobalDimmerFrameEndInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string dimmervalue_prefix = prefix;
        dimmervalue_prefix += "dimmerValue";
        std::ostringstream oss_dimmerValue;
        oss_dimmerValue << std::setprecision(32) << (value->dimmerValue);
        contents.emplace_back("float", dimmervalue_prefix, oss_dimmerValue.str());
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrGlobalDimmerFrameEndInfoFlagsML", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

#if defined(XR_USE_PLATFORM_ML)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCoordinateSpaceCreateInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string cfuid_prefix = prefix;
        cfuid_prefix += "cfuid";
        contents.emplace_back("MLCoordinateFrameUID", cfuid_prefix, std::to_string(value->cfuid));
        std::string poseincoordinatespace_prefix = prefix;
        poseincoordinatespace_prefix += "poseInCoordinateSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInCoordinateSpace, poseincoordinatespace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_PLATFORM_ML)

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemMarkerUnderstandingPropertiesML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsmarkerunderstanding_prefix = prefix;
        supportsmarkerunderstanding_prefix += "supportsMarkerUnderstanding";
        std::ostringstream oss_supportsMarkerUnderstanding;
        oss_supportsMarkerUnderstanding << "0x" << std::hex << (value->supportsMarkerUnderstanding);
        contents.emplace_back("XrBool32", supportsmarkerunderstanding_prefix, oss_supportsMarkerUnderstanding.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrMarkerDetectorCreateInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string profile_prefix = prefix;
        profile_prefix += "profile";
        contents.emplace_back("XrMarkerDetectorProfileML", profile_prefix, std::to_string(value->profile));
        std::string markertype_prefix = prefix;
        markertype_prefix += "markerType";
        contents.emplace_back("XrMarkerTypeML", markertype_prefix, std::to_string(value->markerType));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrMarkerDetectorArucoInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string arucodict_prefix = prefix;
        arucodict_prefix += "arucoDict";
        contents.emplace_back("XrMarkerArucoDictML", arucodict_prefix, std::to_string(value->arucoDict));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrMarkerDetectorSizeInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string markerlength_prefix = prefix;
        markerlength_prefix += "markerLength";
        std::ostringstream oss_markerLength;
        oss_markerLength << std::setprecision(32) << (value->markerLength);
        contents.emplace_back("float", markerlength_prefix, oss_markerLength.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrMarkerDetectorAprilTagInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string apriltagdict_prefix = prefix;
        apriltagdict_prefix += "aprilTagDict";
        contents.emplace_back("XrMarkerAprilTagDictML", apriltagdict_prefix, std::to_string(value->aprilTagDict));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrMarkerDetectorCustomProfileInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string fpshint_prefix = prefix;
        fpshint_prefix += "fpsHint";
        contents.emplace_back("XrMarkerDetectorFpsML", fpshint_prefix, std::to_string(value->fpsHint));
        std::string resolutionhint_prefix = prefix;
        resolutionhint_prefix += "resolutionHint";
        contents.emplace_back("XrMarkerDetectorResolutionML", resolutionhint_prefix, std::to_string(value->resolutionHint));
        std::string camerahint_prefix = prefix;
        camerahint_prefix += "cameraHint";
        contents.emplace_back("XrMarkerDetectorCameraML", camerahint_prefix, std::to_string(value->cameraHint));
        std::string cornerrefinemethod_prefix = prefix;
        cornerrefinemethod_prefix += "cornerRefineMethod";
        contents.emplace_back("XrMarkerDetectorCornerRefineMethodML", cornerrefinemethod_prefix, std::to_string(value->cornerRefineMethod));
        std::string useedgerefinement_prefix = prefix;
        useedgerefinement_prefix += "useEdgeRefinement";
        std::ostringstream oss_useEdgeRefinement;
        oss_useEdgeRefinement << "0x" << std::hex << (value->useEdgeRefinement);
        contents.emplace_back("XrBool32", useedgerefinement_prefix, oss_useEdgeRefinement.str());
        std::string fullanalysisintervalhint_prefix = prefix;
        fullanalysisintervalhint_prefix += "fullAnalysisIntervalHint";
        contents.emplace_back("XrMarkerDetectorFullAnalysisIntervalML", fullanalysisintervalhint_prefix, std::to_string(value->fullAnalysisIntervalHint));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrMarkerDetectorSnapshotInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrMarkerDetectorStateML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string state_prefix = prefix;
        state_prefix += "state";
        contents.emplace_back("XrMarkerDetectorStatusML", state_prefix, std::to_string(value->state));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrMarkerSpaceCreateInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string markerdetector_prefix = prefix;
        markerdetector_prefix += "markerDetector";
        std::ostringstream oss_markerDetector;
        oss_markerDetector << std::hex << reinterpret_cast<const void*>(value->markerDetector);
        contents.emplace_back("XrMarkerDetectorML", markerdetector_prefix, oss_markerDetector.str());
        std::string marker_prefix = prefix;
        marker_prefix += "marker";
        contents.emplace_back("XrMarkerML", marker_prefix, std::to_string(value->marker));
        std::string poseinmarkerspace_prefix = prefix;
        poseinmarkerspace_prefix += "poseInMarkerSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInMarkerSpace, poseinmarkerspace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrLocalizationMapML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string name_prefix = prefix;
        name_prefix += "name";
        contents.emplace_back("char*", name_prefix, value->name);
        std::string mapuuid_prefix = prefix;
        mapuuid_prefix += "mapUuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->mapUuid, mapuuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string maptype_prefix = prefix;
        maptype_prefix += "mapType";
        contents.emplace_back("XrLocalizationMapTypeML", maptype_prefix, std::to_string(value->mapType));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataLocalizationChangedML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string session_prefix = prefix;
        session_prefix += "session";
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(value->session);
        contents.emplace_back("XrSession", session_prefix, oss_session.str());
        std::string state_prefix = prefix;
        state_prefix += "state";
        contents.emplace_back("XrLocalizationMapStateML", state_prefix, std::to_string(value->state));
        std::string map_prefix = prefix;
        map_prefix += "map";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->map, map_prefix, "XrLocalizationMapML", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string confidence_prefix = prefix;
        confidence_prefix += "confidence";
        contents.emplace_back("XrLocalizationMapConfidenceML", confidence_prefix, std::to_string(value->confidence));
        std::string errorflags_prefix = prefix;
        errorflags_prefix += "errorFlags";
        contents.emplace_back("XrLocalizationMapErrorFlagsML", errorflags_prefix, std::to_string(value->errorFlags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrLocalizationMapQueryInfoBaseHeaderML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        // Fallback path - Just output generic information about the base struct
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrMapLocalizationRequestInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string mapuuid_prefix = prefix;
        mapuuid_prefix += "mapUuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->mapUuid, mapuuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrLocalizationMapImportInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string size_prefix = prefix;
        size_prefix += "size";
        std::ostringstream oss_size;
        oss_size << "0x" << std::hex << (value->size);
        contents.emplace_back("uint32_t", size_prefix, oss_size.str());
        std::string data_prefix = prefix;
        data_prefix += "data";
        contents.emplace_back("char*", data_prefix, (value->data ? value->data : "(nullptr)"));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrLocalizationEnableEventsInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string enabled_prefix = prefix;
        enabled_prefix += "enabled";
        std::ostringstream oss_enabled;
        oss_enabled << "0x" << std::hex << (value->enabled);
        contents.emplace_back("XrBool32", enabled_prefix, oss_enabled.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsCreateInfoBaseHeaderML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        if (value->type == XR_TYPE_SPATIAL_ANCHORS_CREATE_INFO_FROM_POSE_ML) {
            const XrSpatialAnchorsCreateInfoFromPoseML* new_value = reinterpret_cast<const XrSpatialAnchorsCreateInfoFromPoseML*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_SPATIAL_ANCHORS_CREATE_INFO_FROM_UUIDS_ML) {
            const XrSpatialAnchorsCreateInfoFromUuidsML* new_value = reinterpret_cast<const XrSpatialAnchorsCreateInfoFromUuidsML*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        // Fallback path - Just output generic information about the base struct
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsCreateInfoFromPoseML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        std::string poseinbasespace_prefix = prefix;
        poseinbasespace_prefix += "poseInBaseSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInBaseSpace, poseinbasespace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCreateSpatialAnchorsCompletionML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string futureresult_prefix = prefix;
        futureresult_prefix += "futureResult";
        if (nullptr != gen_dispatch_table) {
            char futureResult_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->futureResult, futureResult_string);
            contents.emplace_back("XrResult", futureresult_prefix, futureResult_string);
        } else {
                        contents.emplace_back("XrResult", futureresult_prefix, std::to_string(value->futureResult));
        }
        std::string spacecount_prefix = prefix;
        spacecount_prefix += "spaceCount";
        std::ostringstream oss_spaceCount;
        oss_spaceCount << "0x" << std::hex << (value->spaceCount);
        contents.emplace_back("uint32_t", spacecount_prefix, oss_spaceCount.str());
        std::string spaces_prefix = prefix;
        spaces_prefix += "spaces";
        std::ostringstream oss_spaces;
        oss_spaces << std::hex << reinterpret_cast<const void*>(value->spaces);
        contents.emplace_back("XrSpace*", spaces_prefix, oss_spaces.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorStateML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string confidence_prefix = prefix;
        confidence_prefix += "confidence";
        contents.emplace_back("XrSpatialAnchorConfidenceML", confidence_prefix, std::to_string(value->confidence));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsCreateStorageInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsQueryInfoBaseHeaderML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        if (value->type == XR_TYPE_SPATIAL_ANCHORS_QUERY_INFO_RADIUS_ML) {
            const XrSpatialAnchorsQueryInfoRadiusML* new_value = reinterpret_cast<const XrSpatialAnchorsQueryInfoRadiusML*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        // Fallback path - Just output generic information about the base struct
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsQueryInfoRadiusML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        std::string center_prefix = prefix;
        center_prefix += "center";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->center, center_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        std::string radius_prefix = prefix;
        radius_prefix += "radius";
        std::ostringstream oss_radius;
        oss_radius << std::setprecision(32) << (value->radius);
        contents.emplace_back("float", radius_prefix, oss_radius.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsQueryCompletionML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string futureresult_prefix = prefix;
        futureresult_prefix += "futureResult";
        if (nullptr != gen_dispatch_table) {
            char futureResult_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->futureResult, futureResult_string);
            contents.emplace_back("XrResult", futureresult_prefix, futureResult_string);
        } else {
                        contents.emplace_back("XrResult", futureresult_prefix, std::to_string(value->futureResult));
        }
        std::string uuidcapacityinput_prefix = prefix;
        uuidcapacityinput_prefix += "uuidCapacityInput";
        std::ostringstream oss_uuidCapacityInput;
        oss_uuidCapacityInput << "0x" << std::hex << (value->uuidCapacityInput);
        contents.emplace_back("uint32_t", uuidcapacityinput_prefix, oss_uuidCapacityInput.str());
        std::string uuidcountoutput_prefix = prefix;
        uuidcountoutput_prefix += "uuidCountOutput";
        std::ostringstream oss_uuidCountOutput;
        oss_uuidCountOutput << "0x" << std::hex << (value->uuidCountOutput);
        contents.emplace_back("uint32_t", uuidcountoutput_prefix, oss_uuidCountOutput.str());
        std::string uuids_prefix = prefix;
        uuids_prefix += "uuids";
        std::ostringstream oss_uuids;
        oss_uuids << std::hex << reinterpret_cast<const void*>(value->uuids);
        contents.emplace_back("XrUuidEXT*", uuids_prefix, oss_uuids.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsCreateInfoFromUuidsML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string storage_prefix = prefix;
        storage_prefix += "storage";
        std::ostringstream oss_storage;
        oss_storage << std::hex << reinterpret_cast<const void*>(value->storage);
        contents.emplace_back("XrSpatialAnchorsStorageML", storage_prefix, oss_storage.str());
        std::string uuidcount_prefix = prefix;
        uuidcount_prefix += "uuidCount";
        std::ostringstream oss_uuidCount;
        oss_uuidCount << "0x" << std::hex << (value->uuidCount);
        contents.emplace_back("uint32_t", uuidcount_prefix, oss_uuidCount.str());
        std::string uuids_prefix = prefix;
        uuids_prefix += "uuids";
        std::ostringstream oss_uuids_array;
        oss_uuids_array << std::hex << reinterpret_cast<const void*>(value->uuids);
        contents.emplace_back("const XrUuidEXT*", uuids_prefix, oss_uuids_array.str());
        for (uint32_t value_uuids_inc = 0; value_uuids_inc < value->uuidCount; ++value_uuids_inc) {
            std::string uuids_array_prefix = uuids_prefix;
            uuids_array_prefix += "[";
            uuids_array_prefix += std::to_string(value_uuids_inc);
            uuids_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuids[value_uuids_inc], uuids_array_prefix, "const XrUuidEXT*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsPublishInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string anchorcount_prefix = prefix;
        anchorcount_prefix += "anchorCount";
        std::ostringstream oss_anchorCount;
        oss_anchorCount << "0x" << std::hex << (value->anchorCount);
        contents.emplace_back("uint32_t", anchorcount_prefix, oss_anchorCount.str());
        std::string anchors_prefix = prefix;
        anchors_prefix += "anchors";
        std::ostringstream oss_anchors_array;
        oss_anchors_array << std::hex << reinterpret_cast<const void*>(value->anchors);
        contents.emplace_back("const XrSpace*", anchors_prefix, oss_anchors_array.str());
        for (uint32_t value_anchors_inc = 0; value_anchors_inc < value->anchorCount; ++value_anchors_inc) {
            std::string anchors_array_prefix = anchors_prefix;
            anchors_array_prefix += "[";
            anchors_array_prefix += std::to_string(value_anchors_inc);
            anchors_array_prefix += "]";
            std::ostringstream oss_anchors;
            oss_anchors << std::hex << reinterpret_cast<const void*>(value->anchors[value_anchors_inc]);
            contents.emplace_back("const XrSpace*", anchors_array_prefix, oss_anchors.str());
        }
        std::string expiration_prefix = prefix;
        expiration_prefix += "expiration";
        std::ostringstream oss_expiration;
        oss_expiration << "0x" << std::hex << (value->expiration);
        contents.emplace_back("uint64_t", expiration_prefix, oss_expiration.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsPublishCompletionML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string futureresult_prefix = prefix;
        futureresult_prefix += "futureResult";
        if (nullptr != gen_dispatch_table) {
            char futureResult_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->futureResult, futureResult_string);
            contents.emplace_back("XrResult", futureresult_prefix, futureResult_string);
        } else {
                        contents.emplace_back("XrResult", futureresult_prefix, std::to_string(value->futureResult));
        }
        std::string uuidcount_prefix = prefix;
        uuidcount_prefix += "uuidCount";
        std::ostringstream oss_uuidCount;
        oss_uuidCount << "0x" << std::hex << (value->uuidCount);
        contents.emplace_back("uint32_t", uuidcount_prefix, oss_uuidCount.str());
        std::string uuids_prefix = prefix;
        uuids_prefix += "uuids";
        std::ostringstream oss_uuids;
        oss_uuids << std::hex << reinterpret_cast<const void*>(value->uuids);
        contents.emplace_back("XrUuidEXT*", uuids_prefix, oss_uuids.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsDeleteInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string uuidcount_prefix = prefix;
        uuidcount_prefix += "uuidCount";
        std::ostringstream oss_uuidCount;
        oss_uuidCount << "0x" << std::hex << (value->uuidCount);
        contents.emplace_back("uint32_t", uuidcount_prefix, oss_uuidCount.str());
        std::string uuids_prefix = prefix;
        uuids_prefix += "uuids";
        std::ostringstream oss_uuids_array;
        oss_uuids_array << std::hex << reinterpret_cast<const void*>(value->uuids);
        contents.emplace_back("const XrUuidEXT*", uuids_prefix, oss_uuids_array.str());
        for (uint32_t value_uuids_inc = 0; value_uuids_inc < value->uuidCount; ++value_uuids_inc) {
            std::string uuids_array_prefix = uuids_prefix;
            uuids_array_prefix += "[";
            uuids_array_prefix += std::to_string(value_uuids_inc);
            uuids_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuids[value_uuids_inc], uuids_array_prefix, "const XrUuidEXT*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsDeleteCompletionML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string futureresult_prefix = prefix;
        futureresult_prefix += "futureResult";
        if (nullptr != gen_dispatch_table) {
            char futureResult_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->futureResult, futureResult_string);
            contents.emplace_back("XrResult", futureresult_prefix, futureResult_string);
        } else {
                        contents.emplace_back("XrResult", futureresult_prefix, std::to_string(value->futureResult));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsUpdateExpirationInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string uuidcount_prefix = prefix;
        uuidcount_prefix += "uuidCount";
        std::ostringstream oss_uuidCount;
        oss_uuidCount << "0x" << std::hex << (value->uuidCount);
        contents.emplace_back("uint32_t", uuidcount_prefix, oss_uuidCount.str());
        std::string uuids_prefix = prefix;
        uuids_prefix += "uuids";
        std::ostringstream oss_uuids_array;
        oss_uuids_array << std::hex << reinterpret_cast<const void*>(value->uuids);
        contents.emplace_back("const XrUuidEXT*", uuids_prefix, oss_uuids_array.str());
        for (uint32_t value_uuids_inc = 0; value_uuids_inc < value->uuidCount; ++value_uuids_inc) {
            std::string uuids_array_prefix = uuids_prefix;
            uuids_array_prefix += "[";
            uuids_array_prefix += std::to_string(value_uuids_inc);
            uuids_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuids[value_uuids_inc], uuids_array_prefix, "const XrUuidEXT*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        std::string expiration_prefix = prefix;
        expiration_prefix += "expiration";
        std::ostringstream oss_expiration;
        oss_expiration << "0x" << std::hex << (value->expiration);
        contents.emplace_back("uint64_t", expiration_prefix, oss_expiration.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsUpdateExpirationCompletionML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string futureresult_prefix = prefix;
        futureresult_prefix += "futureResult";
        if (nullptr != gen_dispatch_table) {
            char futureResult_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->futureResult, futureResult_string);
            contents.emplace_back("XrResult", futureresult_prefix, futureResult_string);
        } else {
                        contents.emplace_back("XrResult", futureresult_prefix, std::to_string(value->futureResult));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorCompletionResultML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string uuid_prefix = prefix;
        uuid_prefix += "uuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuid, uuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsPublishCompletionDetailsML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string resultcount_prefix = prefix;
        resultcount_prefix += "resultCount";
        std::ostringstream oss_resultCount;
        oss_resultCount << "0x" << std::hex << (value->resultCount);
        contents.emplace_back("uint32_t", resultcount_prefix, oss_resultCount.str());
        std::string results_prefix = prefix;
        results_prefix += "results";
        std::ostringstream oss_results;
        oss_results << std::hex << reinterpret_cast<const void*>(value->results);
        contents.emplace_back("XrSpatialAnchorCompletionResultML*", results_prefix, oss_results.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsDeleteCompletionDetailsML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string resultcount_prefix = prefix;
        resultcount_prefix += "resultCount";
        std::ostringstream oss_resultCount;
        oss_resultCount << "0x" << std::hex << (value->resultCount);
        contents.emplace_back("uint32_t", resultcount_prefix, oss_resultCount.str());
        std::string results_prefix = prefix;
        results_prefix += "results";
        std::ostringstream oss_results;
        oss_results << std::hex << reinterpret_cast<const void*>(value->results);
        contents.emplace_back("XrSpatialAnchorCompletionResultML*", results_prefix, oss_results.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorsUpdateExpirationCompletionDetailsML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string resultcount_prefix = prefix;
        resultcount_prefix += "resultCount";
        std::ostringstream oss_resultCount;
        oss_resultCount << "0x" << std::hex << (value->resultCount);
        contents.emplace_back("uint32_t", resultcount_prefix, oss_resultCount.str());
        std::string results_prefix = prefix;
        results_prefix += "results";
        std::ostringstream oss_results;
        oss_results << std::hex << reinterpret_cast<const void*>(value->results);
        contents.emplace_back("XrSpatialAnchorCompletionResultML*", results_prefix, oss_results.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorPersistenceNameMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string name_prefix = prefix;
        name_prefix += "name";
        contents.emplace_back("char*", name_prefix, value->name);
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorPersistenceInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string spatialanchorpersistencename_prefix = prefix;
        spatialanchorpersistencename_prefix += "spatialAnchorPersistenceName";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->spatialAnchorPersistenceName, spatialanchorpersistencename_prefix, "XrSpatialAnchorPersistenceNameMSFT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string spatialanchor_prefix = prefix;
        spatialanchor_prefix += "spatialAnchor";
        std::ostringstream oss_spatialAnchor;
        oss_spatialAnchor << std::hex << reinterpret_cast<const void*>(value->spatialAnchor);
        contents.emplace_back("XrSpatialAnchorMSFT", spatialanchor_prefix, oss_spatialAnchor.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string spatialanchorstore_prefix = prefix;
        spatialanchorstore_prefix += "spatialAnchorStore";
        std::ostringstream oss_spatialAnchorStore;
        oss_spatialAnchorStore << std::hex << reinterpret_cast<const void*>(value->spatialAnchorStore);
        contents.emplace_back("XrSpatialAnchorStoreConnectionMSFT", spatialanchorstore_prefix, oss_spatialAnchorStore.str());
        std::string spatialanchorpersistencename_prefix = prefix;
        spatialanchorpersistencename_prefix += "spatialAnchorPersistenceName";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->spatialAnchorPersistenceName, spatialanchorpersistencename_prefix, "XrSpatialAnchorPersistenceNameMSFT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneMarkerMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string markertype_prefix = prefix;
        markertype_prefix += "markerType";
        contents.emplace_back("XrSceneMarkerTypeMSFT", markertype_prefix, std::to_string(value->markerType));
        std::string lastseentime_prefix = prefix;
        lastseentime_prefix += "lastSeenTime";
        contents.emplace_back("XrTime", lastseentime_prefix, std::to_string(value->lastSeenTime));
        std::string center_prefix = prefix;
        center_prefix += "center";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->center, center_prefix, "XrOffset2Df", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string size_prefix = prefix;
        size_prefix += "size";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->size, size_prefix, "XrExtent2Df", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneMarkersMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string scenemarkercapacityinput_prefix = prefix;
        scenemarkercapacityinput_prefix += "sceneMarkerCapacityInput";
        std::ostringstream oss_sceneMarkerCapacityInput;
        oss_sceneMarkerCapacityInput << "0x" << std::hex << (value->sceneMarkerCapacityInput);
        contents.emplace_back("uint32_t", scenemarkercapacityinput_prefix, oss_sceneMarkerCapacityInput.str());
        std::string scenemarkers_prefix = prefix;
        scenemarkers_prefix += "sceneMarkers";
        std::ostringstream oss_sceneMarkers;
        oss_sceneMarkers << std::hex << reinterpret_cast<const void*>(value->sceneMarkers);
        contents.emplace_back("XrSceneMarkerMSFT*", scenemarkers_prefix, oss_sceneMarkers.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneMarkerTypeFilterMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string markertypecount_prefix = prefix;
        markertypecount_prefix += "markerTypeCount";
        std::ostringstream oss_markerTypeCount;
        oss_markerTypeCount << "0x" << std::hex << (value->markerTypeCount);
        contents.emplace_back("uint32_t", markertypecount_prefix, oss_markerTypeCount.str());
        std::string markertypes_prefix = prefix;
        markertypes_prefix += "markerTypes";
        std::ostringstream oss_markerTypes;
        oss_markerTypes << std::hex << reinterpret_cast<const void*>(value->markerTypes);
        contents.emplace_back("XrSceneMarkerTypeMSFT*", markertypes_prefix, oss_markerTypes.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneMarkerQRCodeMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string symboltype_prefix = prefix;
        symboltype_prefix += "symbolType";
        contents.emplace_back("XrSceneMarkerQRCodeSymbolTypeMSFT", symboltype_prefix, std::to_string(value->symbolType));
        std::string version_prefix = prefix;
        version_prefix += "version";
        std::ostringstream oss_version;
        oss_version << "0x" << std::hex << (value->version);
        contents.emplace_back("uint8_t", version_prefix, oss_version.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneMarkerQRCodesMSFT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string qrcodecapacityinput_prefix = prefix;
        qrcodecapacityinput_prefix += "qrCodeCapacityInput";
        std::ostringstream oss_qrCodeCapacityInput;
        oss_qrCodeCapacityInput << "0x" << std::hex << (value->qrCodeCapacityInput);
        contents.emplace_back("uint32_t", qrcodecapacityinput_prefix, oss_qrCodeCapacityInput.str());
        std::string qrcodes_prefix = prefix;
        qrcodes_prefix += "qrCodes";
        std::ostringstream oss_qrCodes;
        oss_qrCodes << std::hex << reinterpret_cast<const void*>(value->qrCodes);
        contents.emplace_back("XrSceneMarkerQRCodeMSFT*", qrcodes_prefix, oss_qrCodes.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceQueryInfoBaseHeaderFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        if (value->type == XR_TYPE_SPACE_QUERY_INFO_FB) {
            const XrSpaceQueryInfoFB* new_value = reinterpret_cast<const XrSpaceQueryInfoFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        // Fallback path - Just output generic information about the base struct
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceFilterInfoBaseHeaderFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        if (value->type == XR_TYPE_SPACE_UUID_FILTER_INFO_FB) {
            const XrSpaceUuidFilterInfoFB* new_value = reinterpret_cast<const XrSpaceUuidFilterInfoFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB) {
            const XrSpaceComponentFilterInfoFB* new_value = reinterpret_cast<const XrSpaceComponentFilterInfoFB*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        // Fallback path - Just output generic information about the base struct
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceQueryInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string queryaction_prefix = prefix;
        queryaction_prefix += "queryAction";
        contents.emplace_back("XrSpaceQueryActionFB", queryaction_prefix, std::to_string(value->queryAction));
        std::string maxresultcount_prefix = prefix;
        maxresultcount_prefix += "maxResultCount";
        std::ostringstream oss_maxResultCount;
        oss_maxResultCount << "0x" << std::hex << (value->maxResultCount);
        contents.emplace_back("uint32_t", maxresultcount_prefix, oss_maxResultCount.str());
        std::string timeout_prefix = prefix;
        timeout_prefix += "timeout";
        contents.emplace_back("XrDuration", timeout_prefix, std::to_string(value->timeout));
        std::string filter_prefix = prefix;
        filter_prefix += "filter";
        if (nullptr == value->filter) {
            std::ostringstream oss_filter;
            oss_filter << std::hex << reinterpret_cast<const void*>(value->filter);
            contents.emplace_back("const XrSpaceFilterInfoBaseHeaderFB*", filter_prefix, oss_filter.str());
        } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, value->filter, filter_prefix, "const XrSpaceFilterInfoBaseHeaderFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string excludefilter_prefix = prefix;
        excludefilter_prefix += "excludeFilter";
        if (nullptr == value->excludeFilter) {
            std::ostringstream oss_excludeFilter;
            oss_excludeFilter << std::hex << reinterpret_cast<const void*>(value->excludeFilter);
            contents.emplace_back("const XrSpaceFilterInfoBaseHeaderFB*", excludefilter_prefix, oss_excludeFilter.str());
        } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, value->excludeFilter, excludefilter_prefix, "const XrSpaceFilterInfoBaseHeaderFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceStorageLocationFilterInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string location_prefix = prefix;
        location_prefix += "location";
        contents.emplace_back("XrSpaceStorageLocationFB", location_prefix, std::to_string(value->location));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceUuidFilterInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string uuidcount_prefix = prefix;
        uuidcount_prefix += "uuidCount";
        std::ostringstream oss_uuidCount;
        oss_uuidCount << "0x" << std::hex << (value->uuidCount);
        contents.emplace_back("uint32_t", uuidcount_prefix, oss_uuidCount.str());
        std::string uuids_prefix = prefix;
        uuids_prefix += "uuids";
        std::ostringstream oss_uuids;
        oss_uuids << std::hex << reinterpret_cast<const void*>(value->uuids);
        contents.emplace_back("XrUuidEXT*", uuids_prefix, oss_uuids.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceComponentFilterInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string componenttype_prefix = prefix;
        componenttype_prefix += "componentType";
        contents.emplace_back("XrSpaceComponentTypeFB", componenttype_prefix, std::to_string(value->componentType));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceQueryResultFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string uuid_prefix = prefix;
        uuid_prefix += "uuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuid, uuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceQueryResultsFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string resultcapacityinput_prefix = prefix;
        resultcapacityinput_prefix += "resultCapacityInput";
        std::ostringstream oss_resultCapacityInput;
        oss_resultCapacityInput << "0x" << std::hex << (value->resultCapacityInput);
        contents.emplace_back("uint32_t", resultcapacityinput_prefix, oss_resultCapacityInput.str());
        std::string resultcountoutput_prefix = prefix;
        resultcountoutput_prefix += "resultCountOutput";
        std::ostringstream oss_resultCountOutput;
        oss_resultCountOutput << "0x" << std::hex << (value->resultCountOutput);
        contents.emplace_back("uint32_t", resultcountoutput_prefix, oss_resultCountOutput.str());
        std::string results_prefix = prefix;
        results_prefix += "results";
        std::ostringstream oss_results;
        oss_results << std::hex << reinterpret_cast<const void*>(value->results);
        contents.emplace_back("XrSpaceQueryResultFB*", results_prefix, oss_results.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataSpaceQueryResultsAvailableFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestid_prefix = prefix;
        requestid_prefix += "requestId";
        contents.emplace_back("XrAsyncRequestIdFB", requestid_prefix, std::to_string(value->requestId));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataSpaceQueryCompleteFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestid_prefix = prefix;
        requestid_prefix += "requestId";
        contents.emplace_back("XrAsyncRequestIdFB", requestid_prefix, std::to_string(value->requestId));
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceSaveInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string location_prefix = prefix;
        location_prefix += "location";
        contents.emplace_back("XrSpaceStorageLocationFB", location_prefix, std::to_string(value->location));
        std::string persistencemode_prefix = prefix;
        persistencemode_prefix += "persistenceMode";
        contents.emplace_back("XrSpacePersistenceModeFB", persistencemode_prefix, std::to_string(value->persistenceMode));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceEraseInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string location_prefix = prefix;
        location_prefix += "location";
        contents.emplace_back("XrSpaceStorageLocationFB", location_prefix, std::to_string(value->location));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataSpaceSaveCompleteFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestid_prefix = prefix;
        requestid_prefix += "requestId";
        contents.emplace_back("XrAsyncRequestIdFB", requestid_prefix, std::to_string(value->requestId));
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string uuid_prefix = prefix;
        uuid_prefix += "uuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuid, uuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string location_prefix = prefix;
        location_prefix += "location";
        contents.emplace_back("XrSpaceStorageLocationFB", location_prefix, std::to_string(value->location));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataSpaceEraseCompleteFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestid_prefix = prefix;
        requestid_prefix += "requestId";
        contents.emplace_back("XrAsyncRequestIdFB", requestid_prefix, std::to_string(value->requestId));
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string uuid_prefix = prefix;
        uuid_prefix += "uuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuid, uuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string location_prefix = prefix;
        location_prefix += "location";
        contents.emplace_back("XrSpaceStorageLocationFB", location_prefix, std::to_string(value->location));
        return true;
    } catch(...) {
    }
    return false;
}

#if defined(XR_USE_GRAPHICS_API_VULKAN)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainImageFoveationVulkanFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string image_prefix = prefix;
        image_prefix += "image";
        std::ostringstream oss_image;
        oss_image << std::hex << reinterpret_cast<const void*>(value->image);
        contents.emplace_back("VkImage", image_prefix, oss_image.str());
        std::string width_prefix = prefix;
        width_prefix += "width";
        std::ostringstream oss_width;
        oss_width << "0x" << std::hex << (value->width);
        contents.emplace_back("uint32_t", width_prefix, oss_width.str());
        std::string height_prefix = prefix;
        height_prefix += "height";
        std::ostringstream oss_height;
        oss_height << "0x" << std::hex << (value->height);
        contents.emplace_back("uint32_t", height_prefix, oss_height.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainStateAndroidSurfaceDimensionsFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string width_prefix = prefix;
        width_prefix += "width";
        std::ostringstream oss_width;
        oss_width << "0x" << std::hex << (value->width);
        contents.emplace_back("uint32_t", width_prefix, oss_width.str());
        std::string height_prefix = prefix;
        height_prefix += "height";
        std::ostringstream oss_height;
        oss_height << "0x" << std::hex << (value->height);
        contents.emplace_back("uint32_t", height_prefix, oss_height.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)

#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainStateSamplerOpenGLESFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string minfilter_prefix = prefix;
        minfilter_prefix += "minFilter";
        std::ostringstream oss_minFilter;
        oss_minFilter << std::hex << reinterpret_cast<const void*>(value->minFilter);
        contents.emplace_back("EGLenum", minfilter_prefix, oss_minFilter.str());
        std::string magfilter_prefix = prefix;
        magfilter_prefix += "magFilter";
        std::ostringstream oss_magFilter;
        oss_magFilter << std::hex << reinterpret_cast<const void*>(value->magFilter);
        contents.emplace_back("EGLenum", magfilter_prefix, oss_magFilter.str());
        std::string wrapmodes_prefix = prefix;
        wrapmodes_prefix += "wrapModeS";
        std::ostringstream oss_wrapModeS;
        oss_wrapModeS << std::hex << reinterpret_cast<const void*>(value->wrapModeS);
        contents.emplace_back("EGLenum", wrapmodes_prefix, oss_wrapModeS.str());
        std::string wrapmodet_prefix = prefix;
        wrapmodet_prefix += "wrapModeT";
        std::ostringstream oss_wrapModeT;
        oss_wrapModeT << std::hex << reinterpret_cast<const void*>(value->wrapModeT);
        contents.emplace_back("EGLenum", wrapmodet_prefix, oss_wrapModeT.str());
        std::string swizzlered_prefix = prefix;
        swizzlered_prefix += "swizzleRed";
        std::ostringstream oss_swizzleRed;
        oss_swizzleRed << std::hex << reinterpret_cast<const void*>(value->swizzleRed);
        contents.emplace_back("EGLenum", swizzlered_prefix, oss_swizzleRed.str());
        std::string swizzlegreen_prefix = prefix;
        swizzlegreen_prefix += "swizzleGreen";
        std::ostringstream oss_swizzleGreen;
        oss_swizzleGreen << std::hex << reinterpret_cast<const void*>(value->swizzleGreen);
        contents.emplace_back("EGLenum", swizzlegreen_prefix, oss_swizzleGreen.str());
        std::string swizzleblue_prefix = prefix;
        swizzleblue_prefix += "swizzleBlue";
        std::ostringstream oss_swizzleBlue;
        oss_swizzleBlue << std::hex << reinterpret_cast<const void*>(value->swizzleBlue);
        contents.emplace_back("EGLenum", swizzleblue_prefix, oss_swizzleBlue.str());
        std::string swizzlealpha_prefix = prefix;
        swizzlealpha_prefix += "swizzleAlpha";
        std::ostringstream oss_swizzleAlpha;
        oss_swizzleAlpha << std::hex << reinterpret_cast<const void*>(value->swizzleAlpha);
        contents.emplace_back("EGLenum", swizzlealpha_prefix, oss_swizzleAlpha.str());
        std::string maxanisotropy_prefix = prefix;
        maxanisotropy_prefix += "maxAnisotropy";
        std::ostringstream oss_maxAnisotropy;
        oss_maxAnisotropy << std::setprecision(32) << (value->maxAnisotropy);
        contents.emplace_back("float", maxanisotropy_prefix, oss_maxAnisotropy.str());
        std::string bordercolor_prefix = prefix;
        bordercolor_prefix += "borderColor";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->borderColor, bordercolor_prefix, "XrColor4f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)

#if defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSwapchainStateSamplerVulkanFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string minfilter_prefix = prefix;
        minfilter_prefix += "minFilter";
        std::ostringstream oss_minFilter;
        oss_minFilter << std::hex << reinterpret_cast<const void*>(value->minFilter);
        contents.emplace_back("VkFilter", minfilter_prefix, oss_minFilter.str());
        std::string magfilter_prefix = prefix;
        magfilter_prefix += "magFilter";
        std::ostringstream oss_magFilter;
        oss_magFilter << std::hex << reinterpret_cast<const void*>(value->magFilter);
        contents.emplace_back("VkFilter", magfilter_prefix, oss_magFilter.str());
        std::string mipmapmode_prefix = prefix;
        mipmapmode_prefix += "mipmapMode";
        std::ostringstream oss_mipmapMode;
        oss_mipmapMode << std::hex << reinterpret_cast<const void*>(value->mipmapMode);
        contents.emplace_back("VkSamplerMipmapMode", mipmapmode_prefix, oss_mipmapMode.str());
        std::string wrapmodes_prefix = prefix;
        wrapmodes_prefix += "wrapModeS";
        std::ostringstream oss_wrapModeS;
        oss_wrapModeS << std::hex << reinterpret_cast<const void*>(value->wrapModeS);
        contents.emplace_back("VkSamplerAddressMode", wrapmodes_prefix, oss_wrapModeS.str());
        std::string wrapmodet_prefix = prefix;
        wrapmodet_prefix += "wrapModeT";
        std::ostringstream oss_wrapModeT;
        oss_wrapModeT << std::hex << reinterpret_cast<const void*>(value->wrapModeT);
        contents.emplace_back("VkSamplerAddressMode", wrapmodet_prefix, oss_wrapModeT.str());
        std::string swizzlered_prefix = prefix;
        swizzlered_prefix += "swizzleRed";
        std::ostringstream oss_swizzleRed;
        oss_swizzleRed << std::hex << reinterpret_cast<const void*>(value->swizzleRed);
        contents.emplace_back("VkComponentSwizzle", swizzlered_prefix, oss_swizzleRed.str());
        std::string swizzlegreen_prefix = prefix;
        swizzlegreen_prefix += "swizzleGreen";
        std::ostringstream oss_swizzleGreen;
        oss_swizzleGreen << std::hex << reinterpret_cast<const void*>(value->swizzleGreen);
        contents.emplace_back("VkComponentSwizzle", swizzlegreen_prefix, oss_swizzleGreen.str());
        std::string swizzleblue_prefix = prefix;
        swizzleblue_prefix += "swizzleBlue";
        std::ostringstream oss_swizzleBlue;
        oss_swizzleBlue << std::hex << reinterpret_cast<const void*>(value->swizzleBlue);
        contents.emplace_back("VkComponentSwizzle", swizzleblue_prefix, oss_swizzleBlue.str());
        std::string swizzlealpha_prefix = prefix;
        swizzlealpha_prefix += "swizzleAlpha";
        std::ostringstream oss_swizzleAlpha;
        oss_swizzleAlpha << std::hex << reinterpret_cast<const void*>(value->swizzleAlpha);
        contents.emplace_back("VkComponentSwizzle", swizzlealpha_prefix, oss_swizzleAlpha.str());
        std::string maxanisotropy_prefix = prefix;
        maxanisotropy_prefix += "maxAnisotropy";
        std::ostringstream oss_maxAnisotropy;
        oss_maxAnisotropy << std::setprecision(32) << (value->maxAnisotropy);
        contents.emplace_back("float", maxanisotropy_prefix, oss_maxAnisotropy.str());
        std::string bordercolor_prefix = prefix;
        bordercolor_prefix += "borderColor";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->borderColor, bordercolor_prefix, "XrColor4f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceShareInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string spacecount_prefix = prefix;
        spacecount_prefix += "spaceCount";
        std::ostringstream oss_spaceCount;
        oss_spaceCount << "0x" << std::hex << (value->spaceCount);
        contents.emplace_back("uint32_t", spacecount_prefix, oss_spaceCount.str());
        std::string spaces_prefix = prefix;
        spaces_prefix += "spaces";
        std::ostringstream oss_spaces;
        oss_spaces << std::hex << reinterpret_cast<const void*>(value->spaces);
        contents.emplace_back("XrSpace*", spaces_prefix, oss_spaces.str());
        std::string usercount_prefix = prefix;
        usercount_prefix += "userCount";
        std::ostringstream oss_userCount;
        oss_userCount << "0x" << std::hex << (value->userCount);
        contents.emplace_back("uint32_t", usercount_prefix, oss_userCount.str());
        std::string users_prefix = prefix;
        users_prefix += "users";
        std::ostringstream oss_users;
        oss_users << std::hex << reinterpret_cast<const void*>(value->users);
        contents.emplace_back("XrSpaceUserFB*", users_prefix, oss_users.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataSpaceShareCompleteFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestid_prefix = prefix;
        requestid_prefix += "requestId";
        contents.emplace_back("XrAsyncRequestIdFB", requestid_prefix, std::to_string(value->requestId));
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerSpaceWarpInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string layerflags_prefix = prefix;
        layerflags_prefix += "layerFlags";
        contents.emplace_back("XrCompositionLayerSpaceWarpInfoFlagsFB", layerflags_prefix, std::to_string(value->layerFlags));
        std::string motionvectorsubimage_prefix = prefix;
        motionvectorsubimage_prefix += "motionVectorSubImage";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->motionVectorSubImage, motionvectorsubimage_prefix, "XrSwapchainSubImage", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string appspacedeltapose_prefix = prefix;
        appspacedeltapose_prefix += "appSpaceDeltaPose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->appSpaceDeltaPose, appspacedeltapose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string depthsubimage_prefix = prefix;
        depthsubimage_prefix += "depthSubImage";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->depthSubImage, depthsubimage_prefix, "XrSwapchainSubImage", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string mindepth_prefix = prefix;
        mindepth_prefix += "minDepth";
        std::ostringstream oss_minDepth;
        oss_minDepth << std::setprecision(32) << (value->minDepth);
        contents.emplace_back("float", mindepth_prefix, oss_minDepth.str());
        std::string maxdepth_prefix = prefix;
        maxdepth_prefix += "maxDepth";
        std::ostringstream oss_maxDepth;
        oss_maxDepth << std::setprecision(32) << (value->maxDepth);
        contents.emplace_back("float", maxdepth_prefix, oss_maxDepth.str());
        std::string nearz_prefix = prefix;
        nearz_prefix += "nearZ";
        std::ostringstream oss_nearZ;
        oss_nearZ << std::setprecision(32) << (value->nearZ);
        contents.emplace_back("float", nearz_prefix, oss_nearZ.str());
        std::string farz_prefix = prefix;
        farz_prefix += "farZ";
        std::ostringstream oss_farZ;
        oss_farZ << std::setprecision(32) << (value->farZ);
        contents.emplace_back("float", farz_prefix, oss_farZ.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemSpaceWarpPropertiesFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string recommendedmotionvectorimagerectwidth_prefix = prefix;
        recommendedmotionvectorimagerectwidth_prefix += "recommendedMotionVectorImageRectWidth";
        std::ostringstream oss_recommendedMotionVectorImageRectWidth;
        oss_recommendedMotionVectorImageRectWidth << "0x" << std::hex << (value->recommendedMotionVectorImageRectWidth);
        contents.emplace_back("uint32_t", recommendedmotionvectorimagerectwidth_prefix, oss_recommendedMotionVectorImageRectWidth.str());
        std::string recommendedmotionvectorimagerectheight_prefix = prefix;
        recommendedmotionvectorimagerectheight_prefix += "recommendedMotionVectorImageRectHeight";
        std::ostringstream oss_recommendedMotionVectorImageRectHeight;
        oss_recommendedMotionVectorImageRectHeight << "0x" << std::hex << (value->recommendedMotionVectorImageRectHeight);
        contents.emplace_back("uint32_t", recommendedmotionvectorimagerectheight_prefix, oss_recommendedMotionVectorImageRectHeight.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHapticAmplitudeEnvelopeVibrationFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string duration_prefix = prefix;
        duration_prefix += "duration";
        contents.emplace_back("XrDuration", duration_prefix, std::to_string(value->duration));
        std::string amplitudecount_prefix = prefix;
        amplitudecount_prefix += "amplitudeCount";
        std::ostringstream oss_amplitudeCount;
        oss_amplitudeCount << "0x" << std::hex << (value->amplitudeCount);
        contents.emplace_back("uint32_t", amplitudecount_prefix, oss_amplitudeCount.str());
        std::string amplitudes_prefix = prefix;
        amplitudes_prefix += "amplitudes";
        std::ostringstream oss_amplitudes_array;
        oss_amplitudes_array << std::setprecision(32) << (value->amplitudes);
        contents.emplace_back("const float*", amplitudes_prefix, oss_amplitudes_array.str());
        for (uint32_t value_amplitudes_inc = 0; value_amplitudes_inc < value->amplitudeCount; ++value_amplitudes_inc) {
            std::string amplitudes_array_prefix = amplitudes_prefix;
            amplitudes_array_prefix += "[";
            amplitudes_array_prefix += std::to_string(value_amplitudes_inc);
            amplitudes_array_prefix += "]";
            std::ostringstream oss_amplitudes;
            oss_amplitudes << std::setprecision(32) << (value->amplitudes[value_amplitudes_inc]);
            contents.emplace_back("const float*", amplitudes_array_prefix, oss_amplitudes.str());
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrOffset3DfFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string x_prefix = prefix;
        x_prefix += "x";
        std::ostringstream oss_x;
        oss_x << std::setprecision(32) << (value->x);
        contents.emplace_back("float", x_prefix, oss_x.str());
        std::string y_prefix = prefix;
        y_prefix += "y";
        std::ostringstream oss_y;
        oss_y << std::setprecision(32) << (value->y);
        contents.emplace_back("float", y_prefix, oss_y.str());
        std::string z_prefix = prefix;
        z_prefix += "z";
        std::ostringstream oss_z;
        oss_z << std::setprecision(32) << (value->z);
        contents.emplace_back("float", z_prefix, oss_z.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrRect3DfFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string offset_prefix = prefix;
        offset_prefix += "offset";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->offset, offset_prefix, "XrOffset3DfFB", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string extent_prefix = prefix;
        extent_prefix += "extent";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->extent, extent_prefix, "XrExtent3DfFB", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSemanticLabelsFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string buffercapacityinput_prefix = prefix;
        buffercapacityinput_prefix += "bufferCapacityInput";
        std::ostringstream oss_bufferCapacityInput;
        oss_bufferCapacityInput << "0x" << std::hex << (value->bufferCapacityInput);
        contents.emplace_back("uint32_t", buffercapacityinput_prefix, oss_bufferCapacityInput.str());
        std::string buffercountoutput_prefix = prefix;
        buffercountoutput_prefix += "bufferCountOutput";
        std::ostringstream oss_bufferCountOutput;
        oss_bufferCountOutput << "0x" << std::hex << (value->bufferCountOutput);
        contents.emplace_back("uint32_t", buffercountoutput_prefix, oss_bufferCountOutput.str());
        std::string buffer_prefix = prefix;
        buffer_prefix += "buffer";
        contents.emplace_back("char*", buffer_prefix, (value->buffer ? value->buffer : "(nullptr)"));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrRoomLayoutFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flooruuid_prefix = prefix;
        flooruuid_prefix += "floorUuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->floorUuid, flooruuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string ceilinguuid_prefix = prefix;
        ceilinguuid_prefix += "ceilingUuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->ceilingUuid, ceilinguuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string walluuidcapacityinput_prefix = prefix;
        walluuidcapacityinput_prefix += "wallUuidCapacityInput";
        std::ostringstream oss_wallUuidCapacityInput;
        oss_wallUuidCapacityInput << "0x" << std::hex << (value->wallUuidCapacityInput);
        contents.emplace_back("uint32_t", walluuidcapacityinput_prefix, oss_wallUuidCapacityInput.str());
        std::string walluuidcountoutput_prefix = prefix;
        walluuidcountoutput_prefix += "wallUuidCountOutput";
        std::ostringstream oss_wallUuidCountOutput;
        oss_wallUuidCountOutput << "0x" << std::hex << (value->wallUuidCountOutput);
        contents.emplace_back("uint32_t", walluuidcountoutput_prefix, oss_wallUuidCountOutput.str());
        std::string walluuids_prefix = prefix;
        walluuids_prefix += "wallUuids";
        std::ostringstream oss_wallUuids;
        oss_wallUuids << std::hex << reinterpret_cast<const void*>(value->wallUuids);
        contents.emplace_back("XrUuidEXT*", walluuids_prefix, oss_wallUuids.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBoundary2DFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string vertexcapacityinput_prefix = prefix;
        vertexcapacityinput_prefix += "vertexCapacityInput";
        std::ostringstream oss_vertexCapacityInput;
        oss_vertexCapacityInput << "0x" << std::hex << (value->vertexCapacityInput);
        contents.emplace_back("uint32_t", vertexcapacityinput_prefix, oss_vertexCapacityInput.str());
        std::string vertexcountoutput_prefix = prefix;
        vertexcountoutput_prefix += "vertexCountOutput";
        std::ostringstream oss_vertexCountOutput;
        oss_vertexCountOutput << "0x" << std::hex << (value->vertexCountOutput);
        contents.emplace_back("uint32_t", vertexcountoutput_prefix, oss_vertexCountOutput.str());
        std::string vertices_prefix = prefix;
        vertices_prefix += "vertices";
        std::ostringstream oss_vertices;
        oss_vertices << std::hex << reinterpret_cast<const void*>(value->vertices);
        contents.emplace_back("XrVector2f*", vertices_prefix, oss_vertices.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSemanticLabelsSupportInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrSemanticLabelsSupportFlagsFB", flags_prefix, std::to_string(value->flags));
        std::string recognizedlabels_prefix = prefix;
        recognizedlabels_prefix += "recognizedLabels";
        std::ostringstream oss_recognizedLabels;
        oss_recognizedLabels << std::hex << reinterpret_cast<const void*>(*value->recognizedLabels);
        contents.emplace_back("const char*", recognizedlabels_prefix, oss_recognizedLabels.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrDigitalLensControlALMALENCE* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrDigitalLensControlFlagsALMALENCE", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataSceneCaptureCompleteFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestid_prefix = prefix;
        requestid_prefix += "requestId";
        contents.emplace_back("XrAsyncRequestIdFB", requestid_prefix, std::to_string(value->requestId));
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneCaptureRequestInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestbytecount_prefix = prefix;
        requestbytecount_prefix += "requestByteCount";
        std::ostringstream oss_requestByteCount;
        oss_requestByteCount << "0x" << std::hex << (value->requestByteCount);
        contents.emplace_back("uint32_t", requestbytecount_prefix, oss_requestByteCount.str());
        std::string request_prefix = prefix;
        request_prefix += "request";
        if (nullptr == value->request) {
            std::ostringstream oss_request_array;
            oss_request_array << std::hex << reinterpret_cast<const void*>(value->request);
            contents.emplace_back("const char*", request_prefix, oss_request_array.str());
        } else {
            contents.emplace_back("const char*", request_prefix, value->request);
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceContainerFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string uuidcapacityinput_prefix = prefix;
        uuidcapacityinput_prefix += "uuidCapacityInput";
        std::ostringstream oss_uuidCapacityInput;
        oss_uuidCapacityInput << "0x" << std::hex << (value->uuidCapacityInput);
        contents.emplace_back("uint32_t", uuidcapacityinput_prefix, oss_uuidCapacityInput.str());
        std::string uuidcountoutput_prefix = prefix;
        uuidcountoutput_prefix += "uuidCountOutput";
        std::ostringstream oss_uuidCountOutput;
        oss_uuidCountOutput << "0x" << std::hex << (value->uuidCountOutput);
        contents.emplace_back("uint32_t", uuidcountoutput_prefix, oss_uuidCountOutput.str());
        std::string uuids_prefix = prefix;
        uuids_prefix += "uuids";
        std::ostringstream oss_uuids;
        oss_uuids << std::hex << reinterpret_cast<const void*>(value->uuids);
        contents.emplace_back("XrUuidEXT*", uuids_prefix, oss_uuids.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFoveationEyeTrackedProfileCreateInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrFoveationEyeTrackedProfileCreateFlagsMETA", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFoveationEyeTrackedStateMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string foveationcenter_prefix = prefix;
        foveationcenter_prefix += "foveationCenter";
        std::ostringstream oss_foveationCenter_array;
        oss_foveationCenter_array << std::hex << reinterpret_cast<const void*>(value->foveationCenter);
        contents.emplace_back("XrVector2f*", foveationcenter_prefix, oss_foveationCenter_array.str());
        for (uint32_t value_foveationcenter_inc = 0; value_foveationcenter_inc < XR_FOVEATION_CENTER_SIZE_META; ++value_foveationcenter_inc) {
            std::string foveationcenter_array_prefix = foveationcenter_prefix;
            foveationcenter_array_prefix += "[";
            foveationcenter_array_prefix += std::to_string(value_foveationcenter_inc);
            foveationcenter_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->foveationCenter[value_foveationcenter_inc], foveationcenter_array_prefix, "XrVector2f", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrFoveationEyeTrackedStateFlagsMETA", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemFoveationEyeTrackedPropertiesMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsfoveationeyetracked_prefix = prefix;
        supportsfoveationeyetracked_prefix += "supportsFoveationEyeTracked";
        std::ostringstream oss_supportsFoveationEyeTracked;
        oss_supportsFoveationEyeTracked << "0x" << std::hex << (value->supportsFoveationEyeTracked);
        contents.emplace_back("XrBool32", supportsfoveationeyetracked_prefix, oss_supportsFoveationEyeTracked.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemFaceTrackingPropertiesFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsfacetracking_prefix = prefix;
        supportsfacetracking_prefix += "supportsFaceTracking";
        std::ostringstream oss_supportsFaceTracking;
        oss_supportsFaceTracking << "0x" << std::hex << (value->supportsFaceTracking);
        contents.emplace_back("XrBool32", supportsfacetracking_prefix, oss_supportsFaceTracking.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFaceTrackerCreateInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string faceexpressionset_prefix = prefix;
        faceexpressionset_prefix += "faceExpressionSet";
        contents.emplace_back("XrFaceExpressionSetFB", faceexpressionset_prefix, std::to_string(value->faceExpressionSet));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFaceExpressionInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFaceExpressionStatusFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string isvalid_prefix = prefix;
        isvalid_prefix += "isValid";
        std::ostringstream oss_isValid;
        oss_isValid << "0x" << std::hex << (value->isValid);
        contents.emplace_back("XrBool32", isvalid_prefix, oss_isValid.str());
        std::string iseyefollowingblendshapesvalid_prefix = prefix;
        iseyefollowingblendshapesvalid_prefix += "isEyeFollowingBlendshapesValid";
        std::ostringstream oss_isEyeFollowingBlendshapesValid;
        oss_isEyeFollowingBlendshapesValid << "0x" << std::hex << (value->isEyeFollowingBlendshapesValid);
        contents.emplace_back("XrBool32", iseyefollowingblendshapesvalid_prefix, oss_isEyeFollowingBlendshapesValid.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFaceExpressionWeightsFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string weightcount_prefix = prefix;
        weightcount_prefix += "weightCount";
        std::ostringstream oss_weightCount;
        oss_weightCount << "0x" << std::hex << (value->weightCount);
        contents.emplace_back("uint32_t", weightcount_prefix, oss_weightCount.str());
        std::string weights_prefix = prefix;
        weights_prefix += "weights";
        std::ostringstream oss_weights;
        oss_weights << std::setprecision(32) << (value->weights);
        contents.emplace_back("float*", weights_prefix, oss_weights.str());
        std::string confidencecount_prefix = prefix;
        confidencecount_prefix += "confidenceCount";
        std::ostringstream oss_confidenceCount;
        oss_confidenceCount << "0x" << std::hex << (value->confidenceCount);
        contents.emplace_back("uint32_t", confidencecount_prefix, oss_confidenceCount.str());
        std::string confidences_prefix = prefix;
        confidences_prefix += "confidences";
        std::ostringstream oss_confidences;
        oss_confidences << std::setprecision(32) << (value->confidences);
        contents.emplace_back("float*", confidences_prefix, oss_confidences.str());
        std::string status_prefix = prefix;
        status_prefix += "status";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->status, status_prefix, "XrFaceExpressionStatusFB", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEyeGazeFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string isvalid_prefix = prefix;
        isvalid_prefix += "isValid";
        std::ostringstream oss_isValid;
        oss_isValid << "0x" << std::hex << (value->isValid);
        contents.emplace_back("XrBool32", isvalid_prefix, oss_isValid.str());
        std::string gazepose_prefix = prefix;
        gazepose_prefix += "gazePose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->gazePose, gazepose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string gazeconfidence_prefix = prefix;
        gazeconfidence_prefix += "gazeConfidence";
        std::ostringstream oss_gazeConfidence;
        oss_gazeConfidence << std::setprecision(32) << (value->gazeConfidence);
        contents.emplace_back("float", gazeconfidence_prefix, oss_gazeConfidence.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEyeTrackerCreateInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEyeGazesInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemEyeTrackingPropertiesFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportseyetracking_prefix = prefix;
        supportseyetracking_prefix += "supportsEyeTracking";
        std::ostringstream oss_supportsEyeTracking;
        oss_supportsEyeTracking << "0x" << std::hex << (value->supportsEyeTracking);
        contents.emplace_back("XrBool32", supportseyetracking_prefix, oss_supportsEyeTracking.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEyeGazesFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string gaze_prefix = prefix;
        gaze_prefix += "gaze";
        std::ostringstream oss_gaze_array;
        oss_gaze_array << std::hex << reinterpret_cast<const void*>(value->gaze);
        contents.emplace_back("XrEyeGazeFB*", gaze_prefix, oss_gaze_array.str());
        for (uint32_t value_gaze_inc = 0; value_gaze_inc < XR_EYE_POSITION_COUNT_FB; ++value_gaze_inc) {
            std::string gaze_array_prefix = gaze_prefix;
            gaze_array_prefix += "[";
            gaze_array_prefix += std::to_string(value_gaze_inc);
            gaze_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->gaze[value_gaze_inc], gaze_array_prefix, "XrEyeGazeFB", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughKeyboardHandsIntensityFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string lefthandintensity_prefix = prefix;
        lefthandintensity_prefix += "leftHandIntensity";
        std::ostringstream oss_leftHandIntensity;
        oss_leftHandIntensity << std::setprecision(32) << (value->leftHandIntensity);
        contents.emplace_back("float", lefthandintensity_prefix, oss_leftHandIntensity.str());
        std::string righthandintensity_prefix = prefix;
        righthandintensity_prefix += "rightHandIntensity";
        std::ostringstream oss_rightHandIntensity;
        oss_rightHandIntensity << std::setprecision(32) << (value->rightHandIntensity);
        contents.emplace_back("float", righthandintensity_prefix, oss_rightHandIntensity.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerSettingsFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string layerflags_prefix = prefix;
        layerflags_prefix += "layerFlags";
        contents.emplace_back("XrCompositionLayerSettingsFlagsFB", layerflags_prefix, std::to_string(value->layerFlags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHapticPcmVibrationFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string buffersize_prefix = prefix;
        buffersize_prefix += "bufferSize";
        std::ostringstream oss_bufferSize;
        oss_bufferSize << "0x" << std::hex << (value->bufferSize);
        contents.emplace_back("uint32_t", buffersize_prefix, oss_bufferSize.str());
        std::string buffer_prefix = prefix;
        buffer_prefix += "buffer";
        std::ostringstream oss_buffer_array;
        oss_buffer_array << std::setprecision(32) << (value->buffer);
        contents.emplace_back("const float*", buffer_prefix, oss_buffer_array.str());
        for (uint32_t value_buffer_inc = 0; value_buffer_inc < value->bufferSize; ++value_buffer_inc) {
            std::string buffer_array_prefix = buffer_prefix;
            buffer_array_prefix += "[";
            buffer_array_prefix += std::to_string(value_buffer_inc);
            buffer_array_prefix += "]";
            std::ostringstream oss_buffer;
            oss_buffer << std::setprecision(32) << (value->buffer[value_buffer_inc]);
            contents.emplace_back("const float*", buffer_array_prefix, oss_buffer.str());
        }
        std::string samplerate_prefix = prefix;
        samplerate_prefix += "sampleRate";
        std::ostringstream oss_sampleRate;
        oss_sampleRate << std::setprecision(32) << (value->sampleRate);
        contents.emplace_back("float", samplerate_prefix, oss_sampleRate.str());
        std::string append_prefix = prefix;
        append_prefix += "append";
        std::ostringstream oss_append;
        oss_append << "0x" << std::hex << (value->append);
        contents.emplace_back("XrBool32", append_prefix, oss_append.str());
        std::string samplesconsumed_prefix = prefix;
        samplesconsumed_prefix += "samplesConsumed";
        std::ostringstream oss_samplesConsumed;
        oss_samplesConsumed << std::hex << (value->samplesConsumed);
        contents.emplace_back("uint32_t*", samplesconsumed_prefix, oss_samplesConsumed.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrDevicePcmSampleRateStateFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string samplerate_prefix = prefix;
        samplerate_prefix += "sampleRate";
        std::ostringstream oss_sampleRate;
        oss_sampleRate << std::setprecision(32) << (value->sampleRate);
        contents.emplace_back("float", samplerate_prefix, oss_sampleRate.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFrameSynthesisInfoEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string layerflags_prefix = prefix;
        layerflags_prefix += "layerFlags";
        contents.emplace_back("XrFrameSynthesisInfoFlagsEXT", layerflags_prefix, std::to_string(value->layerFlags));
        std::string motionvectorsubimage_prefix = prefix;
        motionvectorsubimage_prefix += "motionVectorSubImage";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->motionVectorSubImage, motionvectorsubimage_prefix, "XrSwapchainSubImage", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string motionvectorscale_prefix = prefix;
        motionvectorscale_prefix += "motionVectorScale";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->motionVectorScale, motionvectorscale_prefix, "XrVector4f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string motionvectoroffset_prefix = prefix;
        motionvectoroffset_prefix += "motionVectorOffset";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->motionVectorOffset, motionvectoroffset_prefix, "XrVector4f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string appspacedeltapose_prefix = prefix;
        appspacedeltapose_prefix += "appSpaceDeltaPose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->appSpaceDeltaPose, appspacedeltapose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string depthsubimage_prefix = prefix;
        depthsubimage_prefix += "depthSubImage";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->depthSubImage, depthsubimage_prefix, "XrSwapchainSubImage", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string mindepth_prefix = prefix;
        mindepth_prefix += "minDepth";
        std::ostringstream oss_minDepth;
        oss_minDepth << std::setprecision(32) << (value->minDepth);
        contents.emplace_back("float", mindepth_prefix, oss_minDepth.str());
        std::string maxdepth_prefix = prefix;
        maxdepth_prefix += "maxDepth";
        std::ostringstream oss_maxDepth;
        oss_maxDepth << std::setprecision(32) << (value->maxDepth);
        contents.emplace_back("float", maxdepth_prefix, oss_maxDepth.str());
        std::string nearz_prefix = prefix;
        nearz_prefix += "nearZ";
        std::ostringstream oss_nearZ;
        oss_nearZ << std::setprecision(32) << (value->nearZ);
        contents.emplace_back("float", nearz_prefix, oss_nearZ.str());
        std::string farz_prefix = prefix;
        farz_prefix += "farZ";
        std::ostringstream oss_farZ;
        oss_farZ << std::setprecision(32) << (value->farZ);
        contents.emplace_back("float", farz_prefix, oss_farZ.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFrameSynthesisConfigViewEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string recommendedmotionvectorimagerectwidth_prefix = prefix;
        recommendedmotionvectorimagerectwidth_prefix += "recommendedMotionVectorImageRectWidth";
        std::ostringstream oss_recommendedMotionVectorImageRectWidth;
        oss_recommendedMotionVectorImageRectWidth << "0x" << std::hex << (value->recommendedMotionVectorImageRectWidth);
        contents.emplace_back("uint32_t", recommendedmotionvectorimagerectwidth_prefix, oss_recommendedMotionVectorImageRectWidth.str());
        std::string recommendedmotionvectorimagerectheight_prefix = prefix;
        recommendedmotionvectorimagerectheight_prefix += "recommendedMotionVectorImageRectHeight";
        std::ostringstream oss_recommendedMotionVectorImageRectHeight;
        oss_recommendedMotionVectorImageRectHeight << "0x" << std::hex << (value->recommendedMotionVectorImageRectHeight);
        contents.emplace_back("uint32_t", recommendedmotionvectorimagerectheight_prefix, oss_recommendedMotionVectorImageRectHeight.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerDepthTestFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string depthmask_prefix = prefix;
        depthmask_prefix += "depthMask";
        std::ostringstream oss_depthMask;
        oss_depthMask << "0x" << std::hex << (value->depthMask);
        contents.emplace_back("XrBool32", depthmask_prefix, oss_depthMask.str());
        std::string compareop_prefix = prefix;
        compareop_prefix += "compareOp";
        contents.emplace_back("XrCompareOpFB", compareop_prefix, std::to_string(value->compareOp));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrLocalDimmingFrameEndInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string localdimmingmode_prefix = prefix;
        localdimmingmode_prefix += "localDimmingMode";
        contents.emplace_back("XrLocalDimmingModeMETA", localdimmingmode_prefix, std::to_string(value->localDimmingMode));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughPreferencesMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrPassthroughPreferenceFlagsMETA", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemVirtualKeyboardPropertiesMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsvirtualkeyboard_prefix = prefix;
        supportsvirtualkeyboard_prefix += "supportsVirtualKeyboard";
        std::ostringstream oss_supportsVirtualKeyboard;
        oss_supportsVirtualKeyboard << "0x" << std::hex << (value->supportsVirtualKeyboard);
        contents.emplace_back("XrBool32", supportsvirtualkeyboard_prefix, oss_supportsVirtualKeyboard.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVirtualKeyboardCreateInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVirtualKeyboardSpaceCreateInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string locationtype_prefix = prefix;
        locationtype_prefix += "locationType";
        contents.emplace_back("XrVirtualKeyboardLocationTypeMETA", locationtype_prefix, std::to_string(value->locationType));
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string poseinspace_prefix = prefix;
        poseinspace_prefix += "poseInSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInSpace, poseinspace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVirtualKeyboardLocationInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string locationtype_prefix = prefix;
        locationtype_prefix += "locationType";
        contents.emplace_back("XrVirtualKeyboardLocationTypeMETA", locationtype_prefix, std::to_string(value->locationType));
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string poseinspace_prefix = prefix;
        poseinspace_prefix += "poseInSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInSpace, poseinspace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string scale_prefix = prefix;
        scale_prefix += "scale";
        std::ostringstream oss_scale;
        oss_scale << std::setprecision(32) << (value->scale);
        contents.emplace_back("float", scale_prefix, oss_scale.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVirtualKeyboardModelVisibilitySetInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string visible_prefix = prefix;
        visible_prefix += "visible";
        std::ostringstream oss_visible;
        oss_visible << "0x" << std::hex << (value->visible);
        contents.emplace_back("XrBool32", visible_prefix, oss_visible.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVirtualKeyboardAnimationStateMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string animationindex_prefix = prefix;
        animationindex_prefix += "animationIndex";
        contents.emplace_back("int32_t", animationindex_prefix, std::to_string(value->animationIndex));
        std::string fraction_prefix = prefix;
        fraction_prefix += "fraction";
        std::ostringstream oss_fraction;
        oss_fraction << std::setprecision(32) << (value->fraction);
        contents.emplace_back("float", fraction_prefix, oss_fraction.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVirtualKeyboardModelAnimationStatesMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string statecapacityinput_prefix = prefix;
        statecapacityinput_prefix += "stateCapacityInput";
        std::ostringstream oss_stateCapacityInput;
        oss_stateCapacityInput << "0x" << std::hex << (value->stateCapacityInput);
        contents.emplace_back("uint32_t", statecapacityinput_prefix, oss_stateCapacityInput.str());
        std::string statecountoutput_prefix = prefix;
        statecountoutput_prefix += "stateCountOutput";
        std::ostringstream oss_stateCountOutput;
        oss_stateCountOutput << "0x" << std::hex << (value->stateCountOutput);
        contents.emplace_back("uint32_t", statecountoutput_prefix, oss_stateCountOutput.str());
        std::string states_prefix = prefix;
        states_prefix += "states";
        std::ostringstream oss_states;
        oss_states << std::hex << reinterpret_cast<const void*>(value->states);
        contents.emplace_back("XrVirtualKeyboardAnimationStateMETA*", states_prefix, oss_states.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVirtualKeyboardTextureDataMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string texturewidth_prefix = prefix;
        texturewidth_prefix += "textureWidth";
        std::ostringstream oss_textureWidth;
        oss_textureWidth << "0x" << std::hex << (value->textureWidth);
        contents.emplace_back("uint32_t", texturewidth_prefix, oss_textureWidth.str());
        std::string textureheight_prefix = prefix;
        textureheight_prefix += "textureHeight";
        std::ostringstream oss_textureHeight;
        oss_textureHeight << "0x" << std::hex << (value->textureHeight);
        contents.emplace_back("uint32_t", textureheight_prefix, oss_textureHeight.str());
        std::string buffercapacityinput_prefix = prefix;
        buffercapacityinput_prefix += "bufferCapacityInput";
        std::ostringstream oss_bufferCapacityInput;
        oss_bufferCapacityInput << "0x" << std::hex << (value->bufferCapacityInput);
        contents.emplace_back("uint32_t", buffercapacityinput_prefix, oss_bufferCapacityInput.str());
        std::string buffercountoutput_prefix = prefix;
        buffercountoutput_prefix += "bufferCountOutput";
        std::ostringstream oss_bufferCountOutput;
        oss_bufferCountOutput << "0x" << std::hex << (value->bufferCountOutput);
        contents.emplace_back("uint32_t", buffercountoutput_prefix, oss_bufferCountOutput.str());
        std::string buffer_prefix = prefix;
        buffer_prefix += "buffer";
        std::ostringstream oss_buffer;
        oss_buffer << "0x" << std::hex << (value->buffer);
        contents.emplace_back("uint8_t*", buffer_prefix, oss_buffer.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVirtualKeyboardInputInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string inputsource_prefix = prefix;
        inputsource_prefix += "inputSource";
        contents.emplace_back("XrVirtualKeyboardInputSourceMETA", inputsource_prefix, std::to_string(value->inputSource));
        std::string inputspace_prefix = prefix;
        inputspace_prefix += "inputSpace";
        std::ostringstream oss_inputSpace;
        oss_inputSpace << std::hex << reinterpret_cast<const void*>(value->inputSpace);
        contents.emplace_back("XrSpace", inputspace_prefix, oss_inputSpace.str());
        std::string inputposeinspace_prefix = prefix;
        inputposeinspace_prefix += "inputPoseInSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->inputPoseInSpace, inputposeinspace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string inputstate_prefix = prefix;
        inputstate_prefix += "inputState";
        contents.emplace_back("XrVirtualKeyboardInputStateFlagsMETA", inputstate_prefix, std::to_string(value->inputState));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVirtualKeyboardTextContextChangeInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string textcontext_prefix = prefix;
        textcontext_prefix += "textContext";
        std::ostringstream oss_textContext;
        oss_textContext << std::hex << reinterpret_cast<const void*>(*value->textContext);
        contents.emplace_back("const char*", textcontext_prefix, oss_textContext.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataVirtualKeyboardCommitTextMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string keyboard_prefix = prefix;
        keyboard_prefix += "keyboard";
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(value->keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA", keyboard_prefix, oss_keyboard.str());
        std::string text_prefix = prefix;
        text_prefix += "text";
        contents.emplace_back("char*", text_prefix, value->text);
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataVirtualKeyboardBackspaceMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string keyboard_prefix = prefix;
        keyboard_prefix += "keyboard";
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(value->keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA", keyboard_prefix, oss_keyboard.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataVirtualKeyboardEnterMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string keyboard_prefix = prefix;
        keyboard_prefix += "keyboard";
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(value->keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA", keyboard_prefix, oss_keyboard.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataVirtualKeyboardShownMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string keyboard_prefix = prefix;
        keyboard_prefix += "keyboard";
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(value->keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA", keyboard_prefix, oss_keyboard.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataVirtualKeyboardHiddenMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string keyboard_prefix = prefix;
        keyboard_prefix += "keyboard";
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(value->keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA", keyboard_prefix, oss_keyboard.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrExternalCameraIntrinsicsOCULUS* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string lastchangetime_prefix = prefix;
        lastchangetime_prefix += "lastChangeTime";
        contents.emplace_back("XrTime", lastchangetime_prefix, std::to_string(value->lastChangeTime));
        std::string fov_prefix = prefix;
        fov_prefix += "fov";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->fov, fov_prefix, "XrFovf", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string virtualnearplanedistance_prefix = prefix;
        virtualnearplanedistance_prefix += "virtualNearPlaneDistance";
        std::ostringstream oss_virtualNearPlaneDistance;
        oss_virtualNearPlaneDistance << std::setprecision(32) << (value->virtualNearPlaneDistance);
        contents.emplace_back("float", virtualnearplanedistance_prefix, oss_virtualNearPlaneDistance.str());
        std::string virtualfarplanedistance_prefix = prefix;
        virtualfarplanedistance_prefix += "virtualFarPlaneDistance";
        std::ostringstream oss_virtualFarPlaneDistance;
        oss_virtualFarPlaneDistance << std::setprecision(32) << (value->virtualFarPlaneDistance);
        contents.emplace_back("float", virtualfarplanedistance_prefix, oss_virtualFarPlaneDistance.str());
        std::string imagesensorpixelresolution_prefix = prefix;
        imagesensorpixelresolution_prefix += "imageSensorPixelResolution";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->imageSensorPixelResolution, imagesensorpixelresolution_prefix, "XrExtent2Di", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrExternalCameraExtrinsicsOCULUS* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string lastchangetime_prefix = prefix;
        lastchangetime_prefix += "lastChangeTime";
        contents.emplace_back("XrTime", lastchangetime_prefix, std::to_string(value->lastChangeTime));
        std::string camerastatusflags_prefix = prefix;
        camerastatusflags_prefix += "cameraStatusFlags";
        contents.emplace_back("XrExternalCameraStatusFlagsOCULUS", camerastatusflags_prefix, std::to_string(value->cameraStatusFlags));
        std::string attachedtodevice_prefix = prefix;
        attachedtodevice_prefix += "attachedToDevice";
        contents.emplace_back("XrExternalCameraAttachedToDeviceOCULUS", attachedtodevice_prefix, std::to_string(value->attachedToDevice));
        std::string relativepose_prefix = prefix;
        relativepose_prefix += "relativePose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->relativePose, relativepose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrExternalCameraOCULUS* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string name_prefix = prefix;
        name_prefix += "name";
        contents.emplace_back("char*", name_prefix, value->name);
        std::string intrinsics_prefix = prefix;
        intrinsics_prefix += "intrinsics";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->intrinsics, intrinsics_prefix, "XrExternalCameraIntrinsicsOCULUS", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string extrinsics_prefix = prefix;
        extrinsics_prefix += "extrinsics";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->extrinsics, extrinsics_prefix, "XrExternalCameraExtrinsicsOCULUS", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

#if defined(XR_USE_GRAPHICS_API_VULKAN)
bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrVulkanSwapchainCreateInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string additionalcreateflags_prefix = prefix;
        additionalcreateflags_prefix += "additionalCreateFlags";
        std::ostringstream oss_additionalCreateFlags;
        oss_additionalCreateFlags << std::hex << reinterpret_cast<const void*>(value->additionalCreateFlags);
        contents.emplace_back("VkImageCreateFlags", additionalcreateflags_prefix, oss_additionalCreateFlags.str());
        std::string additionalusageflags_prefix = prefix;
        additionalusageflags_prefix += "additionalUsageFlags";
        std::ostringstream oss_additionalUsageFlags;
        oss_additionalUsageFlags << std::hex << reinterpret_cast<const void*>(value->additionalUsageFlags);
        contents.emplace_back("VkImageUsageFlags", additionalusageflags_prefix, oss_additionalUsageFlags.str());
        return true;
    } catch(...) {
    }
    return false;
}
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPerformanceMetricsStateMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string enabled_prefix = prefix;
        enabled_prefix += "enabled";
        std::ostringstream oss_enabled;
        oss_enabled << "0x" << std::hex << (value->enabled);
        contents.emplace_back("XrBool32", enabled_prefix, oss_enabled.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPerformanceMetricsCounterMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string counterflags_prefix = prefix;
        counterflags_prefix += "counterFlags";
        contents.emplace_back("XrPerformanceMetricsCounterFlagsMETA", counterflags_prefix, std::to_string(value->counterFlags));
        std::string counterunit_prefix = prefix;
        counterunit_prefix += "counterUnit";
        contents.emplace_back("XrPerformanceMetricsCounterUnitMETA", counterunit_prefix, std::to_string(value->counterUnit));
        std::string uintvalue_prefix = prefix;
        uintvalue_prefix += "uintValue";
        std::ostringstream oss_uintValue;
        oss_uintValue << "0x" << std::hex << (value->uintValue);
        contents.emplace_back("uint32_t", uintvalue_prefix, oss_uintValue.str());
        std::string floatvalue_prefix = prefix;
        floatvalue_prefix += "floatValue";
        std::ostringstream oss_floatValue;
        oss_floatValue << std::setprecision(32) << (value->floatValue);
        contents.emplace_back("float", floatvalue_prefix, oss_floatValue.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceListSaveInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string spacecount_prefix = prefix;
        spacecount_prefix += "spaceCount";
        std::ostringstream oss_spaceCount;
        oss_spaceCount << "0x" << std::hex << (value->spaceCount);
        contents.emplace_back("uint32_t", spacecount_prefix, oss_spaceCount.str());
        std::string spaces_prefix = prefix;
        spaces_prefix += "spaces";
        std::ostringstream oss_spaces;
        oss_spaces << std::hex << reinterpret_cast<const void*>(value->spaces);
        contents.emplace_back("XrSpace*", spaces_prefix, oss_spaces.str());
        std::string location_prefix = prefix;
        location_prefix += "location";
        contents.emplace_back("XrSpaceStorageLocationFB", location_prefix, std::to_string(value->location));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataSpaceListSaveCompleteFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestid_prefix = prefix;
        requestid_prefix += "requestId";
        contents.emplace_back("XrAsyncRequestIdFB", requestid_prefix, std::to_string(value->requestId));
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceUserCreateInfoFB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string userid_prefix = prefix;
        userid_prefix += "userId";
        std::ostringstream oss_userId;
        oss_userId << "0x" << std::hex << (value->userId);
        contents.emplace_back("XrSpaceUserIdFB", userid_prefix, oss_userId.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemHeadsetIdPropertiesMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string id_prefix = prefix;
        id_prefix += "id";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->id, id_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrRecommendedLayerResolutionMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string recommendedimagedimensions_prefix = prefix;
        recommendedimagedimensions_prefix += "recommendedImageDimensions";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->recommendedImageDimensions, recommendedimagedimensions_prefix, "XrExtent2Di", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string isvalid_prefix = prefix;
        isvalid_prefix += "isValid";
        std::ostringstream oss_isValid;
        oss_isValid << "0x" << std::hex << (value->isValid);
        contents.emplace_back("XrBool32", isvalid_prefix, oss_isValid.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrRecommendedLayerResolutionGetInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string layer_prefix = prefix;
        layer_prefix += "layer";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, value->layer, layer_prefix, "const XrCompositionLayerBaseHeader*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string predicteddisplaytime_prefix = prefix;
        predicteddisplaytime_prefix += "predictedDisplayTime";
        contents.emplace_back("XrTime", predicteddisplaytime_prefix, std::to_string(value->predictedDisplayTime));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughColorLutDataMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string buffersize_prefix = prefix;
        buffersize_prefix += "bufferSize";
        std::ostringstream oss_bufferSize;
        oss_bufferSize << "0x" << std::hex << (value->bufferSize);
        contents.emplace_back("uint32_t", buffersize_prefix, oss_bufferSize.str());
        std::string buffer_prefix = prefix;
        buffer_prefix += "buffer";
        std::ostringstream oss_buffer_array;
        oss_buffer_array << std::hex << (value->buffer);
        contents.emplace_back("const uint8_t*", buffer_prefix, oss_buffer_array.str());
        for (uint32_t value_buffer_inc = 0; value_buffer_inc < value->bufferSize; ++value_buffer_inc) {
            std::string buffer_array_prefix = buffer_prefix;
            buffer_array_prefix += "[";
            buffer_array_prefix += std::to_string(value_buffer_inc);
            buffer_array_prefix += "]";
            std::ostringstream oss_buffer;
            oss_buffer << "0x" << std::hex << (value->buffer[value_buffer_inc]);
            contents.emplace_back("const uint8_t*", buffer_array_prefix, oss_buffer.str());
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughColorLutCreateInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string channels_prefix = prefix;
        channels_prefix += "channels";
        contents.emplace_back("XrPassthroughColorLutChannelsMETA", channels_prefix, std::to_string(value->channels));
        std::string resolution_prefix = prefix;
        resolution_prefix += "resolution";
        std::ostringstream oss_resolution;
        oss_resolution << "0x" << std::hex << (value->resolution);
        contents.emplace_back("uint32_t", resolution_prefix, oss_resolution.str());
        std::string data_prefix = prefix;
        data_prefix += "data";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->data, data_prefix, "XrPassthroughColorLutDataMETA", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughColorLutUpdateInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string data_prefix = prefix;
        data_prefix += "data";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->data, data_prefix, "XrPassthroughColorLutDataMETA", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughColorMapLutMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string colorlut_prefix = prefix;
        colorlut_prefix += "colorLut";
        std::ostringstream oss_colorLut;
        oss_colorLut << std::hex << reinterpret_cast<const void*>(value->colorLut);
        contents.emplace_back("XrPassthroughColorLutMETA", colorlut_prefix, oss_colorLut.str());
        std::string weight_prefix = prefix;
        weight_prefix += "weight";
        std::ostringstream oss_weight;
        oss_weight << std::setprecision(32) << (value->weight);
        contents.emplace_back("float", weight_prefix, oss_weight.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughColorMapInterpolatedLutMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string sourcecolorlut_prefix = prefix;
        sourcecolorlut_prefix += "sourceColorLut";
        std::ostringstream oss_sourceColorLut;
        oss_sourceColorLut << std::hex << reinterpret_cast<const void*>(value->sourceColorLut);
        contents.emplace_back("XrPassthroughColorLutMETA", sourcecolorlut_prefix, oss_sourceColorLut.str());
        std::string targetcolorlut_prefix = prefix;
        targetcolorlut_prefix += "targetColorLut";
        std::ostringstream oss_targetColorLut;
        oss_targetColorLut << std::hex << reinterpret_cast<const void*>(value->targetColorLut);
        contents.emplace_back("XrPassthroughColorLutMETA", targetcolorlut_prefix, oss_targetColorLut.str());
        std::string weight_prefix = prefix;
        weight_prefix += "weight";
        std::ostringstream oss_weight;
        oss_weight << std::setprecision(32) << (value->weight);
        contents.emplace_back("float", weight_prefix, oss_weight.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemPassthroughColorLutPropertiesMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string maxcolorlutresolution_prefix = prefix;
        maxcolorlutresolution_prefix += "maxColorLutResolution";
        std::ostringstream oss_maxColorLutResolution;
        oss_maxColorLutResolution << "0x" << std::hex << (value->maxColorLutResolution);
        contents.emplace_back("uint32_t", maxcolorlutresolution_prefix, oss_maxColorLutResolution.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceTriangleMeshGetInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceTriangleMeshMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string vertexcapacityinput_prefix = prefix;
        vertexcapacityinput_prefix += "vertexCapacityInput";
        std::ostringstream oss_vertexCapacityInput;
        oss_vertexCapacityInput << "0x" << std::hex << (value->vertexCapacityInput);
        contents.emplace_back("uint32_t", vertexcapacityinput_prefix, oss_vertexCapacityInput.str());
        std::string vertexcountoutput_prefix = prefix;
        vertexcountoutput_prefix += "vertexCountOutput";
        std::ostringstream oss_vertexCountOutput;
        oss_vertexCountOutput << "0x" << std::hex << (value->vertexCountOutput);
        contents.emplace_back("uint32_t", vertexcountoutput_prefix, oss_vertexCountOutput.str());
        std::string vertices_prefix = prefix;
        vertices_prefix += "vertices";
        std::ostringstream oss_vertices;
        oss_vertices << std::hex << reinterpret_cast<const void*>(value->vertices);
        contents.emplace_back("XrVector3f*", vertices_prefix, oss_vertices.str());
        std::string indexcapacityinput_prefix = prefix;
        indexcapacityinput_prefix += "indexCapacityInput";
        std::ostringstream oss_indexCapacityInput;
        oss_indexCapacityInput << "0x" << std::hex << (value->indexCapacityInput);
        contents.emplace_back("uint32_t", indexcapacityinput_prefix, oss_indexCapacityInput.str());
        std::string indexcountoutput_prefix = prefix;
        indexcountoutput_prefix += "indexCountOutput";
        std::ostringstream oss_indexCountOutput;
        oss_indexCountOutput << "0x" << std::hex << (value->indexCountOutput);
        contents.emplace_back("uint32_t", indexcountoutput_prefix, oss_indexCountOutput.str());
        std::string indices_prefix = prefix;
        indices_prefix += "indices";
        std::ostringstream oss_indices;
        oss_indices << "0x" << std::hex << (value->indices);
        contents.emplace_back("uint32_t*", indices_prefix, oss_indices.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataPassthroughLayerResumedMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string layer_prefix = prefix;
        layer_prefix += "layer";
        std::ostringstream oss_layer;
        oss_layer << std::hex << reinterpret_cast<const void*>(value->layer);
        contents.emplace_back("XrPassthroughLayerFB", layer_prefix, oss_layer.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemFaceTrackingProperties2FB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsvisualfacetracking_prefix = prefix;
        supportsvisualfacetracking_prefix += "supportsVisualFaceTracking";
        std::ostringstream oss_supportsVisualFaceTracking;
        oss_supportsVisualFaceTracking << "0x" << std::hex << (value->supportsVisualFaceTracking);
        contents.emplace_back("XrBool32", supportsvisualfacetracking_prefix, oss_supportsVisualFaceTracking.str());
        std::string supportsaudiofacetracking_prefix = prefix;
        supportsaudiofacetracking_prefix += "supportsAudioFaceTracking";
        std::ostringstream oss_supportsAudioFaceTracking;
        oss_supportsAudioFaceTracking << "0x" << std::hex << (value->supportsAudioFaceTracking);
        contents.emplace_back("XrBool32", supportsaudiofacetracking_prefix, oss_supportsAudioFaceTracking.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFaceTrackerCreateInfo2FB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string faceexpressionset_prefix = prefix;
        faceexpressionset_prefix += "faceExpressionSet";
        contents.emplace_back("XrFaceExpressionSet2FB", faceexpressionset_prefix, std::to_string(value->faceExpressionSet));
        std::string requesteddatasourcecount_prefix = prefix;
        requesteddatasourcecount_prefix += "requestedDataSourceCount";
        std::ostringstream oss_requestedDataSourceCount;
        oss_requestedDataSourceCount << "0x" << std::hex << (value->requestedDataSourceCount);
        contents.emplace_back("uint32_t", requesteddatasourcecount_prefix, oss_requestedDataSourceCount.str());
        std::string requesteddatasources_prefix = prefix;
        requesteddatasources_prefix += "requestedDataSources";
        std::ostringstream oss_requestedDataSources;
        oss_requestedDataSources << std::hex << reinterpret_cast<const void*>(value->requestedDataSources);
        contents.emplace_back("XrFaceTrackingDataSource2FB*", requesteddatasources_prefix, oss_requestedDataSources.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFaceExpressionInfo2FB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFaceExpressionWeights2FB* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string weightcount_prefix = prefix;
        weightcount_prefix += "weightCount";
        std::ostringstream oss_weightCount;
        oss_weightCount << "0x" << std::hex << (value->weightCount);
        contents.emplace_back("uint32_t", weightcount_prefix, oss_weightCount.str());
        std::string weights_prefix = prefix;
        weights_prefix += "weights";
        std::ostringstream oss_weights;
        oss_weights << std::setprecision(32) << (value->weights);
        contents.emplace_back("float*", weights_prefix, oss_weights.str());
        std::string confidencecount_prefix = prefix;
        confidencecount_prefix += "confidenceCount";
        std::ostringstream oss_confidenceCount;
        oss_confidenceCount << "0x" << std::hex << (value->confidenceCount);
        contents.emplace_back("uint32_t", confidencecount_prefix, oss_confidenceCount.str());
        std::string confidences_prefix = prefix;
        confidences_prefix += "confidences";
        std::ostringstream oss_confidences;
        oss_confidences << std::setprecision(32) << (value->confidences);
        contents.emplace_back("float*", confidences_prefix, oss_confidences.str());
        std::string isvalid_prefix = prefix;
        isvalid_prefix += "isValid";
        std::ostringstream oss_isValid;
        oss_isValid << "0x" << std::hex << (value->isValid);
        contents.emplace_back("XrBool32", isvalid_prefix, oss_isValid.str());
        std::string iseyefollowingblendshapesvalid_prefix = prefix;
        iseyefollowingblendshapesvalid_prefix += "isEyeFollowingBlendshapesValid";
        std::ostringstream oss_isEyeFollowingBlendshapesValid;
        oss_isEyeFollowingBlendshapesValid << "0x" << std::hex << (value->isEyeFollowingBlendshapesValid);
        contents.emplace_back("XrBool32", iseyefollowingblendshapesvalid_prefix, oss_isEyeFollowingBlendshapesValid.str());
        std::string datasource_prefix = prefix;
        datasource_prefix += "dataSource";
        contents.emplace_back("XrFaceTrackingDataSource2FB", datasource_prefix, std::to_string(value->dataSource));
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemSpatialEntitySharingPropertiesMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsspatialentitysharing_prefix = prefix;
        supportsspatialentitysharing_prefix += "supportsSpatialEntitySharing";
        std::ostringstream oss_supportsSpatialEntitySharing;
        oss_supportsSpatialEntitySharing << "0x" << std::hex << (value->supportsSpatialEntitySharing);
        contents.emplace_back("XrBool32", supportsspatialentitysharing_prefix, oss_supportsSpatialEntitySharing.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrShareSpacesRecipientBaseHeaderMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        if (value->type == XR_TYPE_SHARE_SPACES_RECIPIENT_GROUPS_META) {
            const XrShareSpacesRecipientGroupsMETA* new_value = reinterpret_cast<const XrShareSpacesRecipientGroupsMETA*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        // Fallback path - Just output generic information about the base struct
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrShareSpacesInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string spacecount_prefix = prefix;
        spacecount_prefix += "spaceCount";
        std::ostringstream oss_spaceCount;
        oss_spaceCount << "0x" << std::hex << (value->spaceCount);
        contents.emplace_back("uint32_t", spacecount_prefix, oss_spaceCount.str());
        std::string spaces_prefix = prefix;
        spaces_prefix += "spaces";
        std::ostringstream oss_spaces;
        oss_spaces << std::hex << reinterpret_cast<const void*>(value->spaces);
        contents.emplace_back("XrSpace*", spaces_prefix, oss_spaces.str());
        std::string recipientinfo_prefix = prefix;
        recipientinfo_prefix += "recipientInfo";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, value->recipientInfo, recipientinfo_prefix, "const XrShareSpacesRecipientBaseHeaderMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataShareSpacesCompleteMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestid_prefix = prefix;
        requestid_prefix += "requestId";
        contents.emplace_back("XrAsyncRequestIdFB", requestid_prefix, std::to_string(value->requestId));
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEnvironmentDepthProviderCreateInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string createflags_prefix = prefix;
        createflags_prefix += "createFlags";
        contents.emplace_back("XrEnvironmentDepthProviderCreateFlagsMETA", createflags_prefix, std::to_string(value->createFlags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEnvironmentDepthSwapchainCreateInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string createflags_prefix = prefix;
        createflags_prefix += "createFlags";
        contents.emplace_back("XrEnvironmentDepthSwapchainCreateFlagsMETA", createflags_prefix, std::to_string(value->createFlags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEnvironmentDepthSwapchainStateMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string width_prefix = prefix;
        width_prefix += "width";
        std::ostringstream oss_width;
        oss_width << "0x" << std::hex << (value->width);
        contents.emplace_back("uint32_t", width_prefix, oss_width.str());
        std::string height_prefix = prefix;
        height_prefix += "height";
        std::ostringstream oss_height;
        oss_height << "0x" << std::hex << (value->height);
        contents.emplace_back("uint32_t", height_prefix, oss_height.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEnvironmentDepthImageAcquireInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string displaytime_prefix = prefix;
        displaytime_prefix += "displayTime";
        contents.emplace_back("XrTime", displaytime_prefix, std::to_string(value->displayTime));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEnvironmentDepthImageViewMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string fov_prefix = prefix;
        fov_prefix += "fov";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->fov, fov_prefix, "XrFovf", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEnvironmentDepthImageMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string swapchainindex_prefix = prefix;
        swapchainindex_prefix += "swapchainIndex";
        std::ostringstream oss_swapchainIndex;
        oss_swapchainIndex << "0x" << std::hex << (value->swapchainIndex);
        contents.emplace_back("uint32_t", swapchainindex_prefix, oss_swapchainIndex.str());
        std::string nearz_prefix = prefix;
        nearz_prefix += "nearZ";
        std::ostringstream oss_nearZ;
        oss_nearZ << std::setprecision(32) << (value->nearZ);
        contents.emplace_back("float", nearz_prefix, oss_nearZ.str());
        std::string farz_prefix = prefix;
        farz_prefix += "farZ";
        std::ostringstream oss_farZ;
        oss_farZ << std::setprecision(32) << (value->farZ);
        contents.emplace_back("float", farz_prefix, oss_farZ.str());
        std::string views_prefix = prefix;
        views_prefix += "views";
        std::ostringstream oss_views_array;
        oss_views_array << std::hex << reinterpret_cast<const void*>(value->views);
        contents.emplace_back("XrEnvironmentDepthImageViewMETA*", views_prefix, oss_views_array.str());
        for (uint32_t value_views_inc = 0; value_views_inc < 2; ++value_views_inc) {
            std::string views_array_prefix = views_prefix;
            views_array_prefix += "[";
            views_array_prefix += std::to_string(value_views_inc);
            views_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->views[value_views_inc], views_array_prefix, "XrEnvironmentDepthImageViewMETA", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEnvironmentDepthHandRemovalSetInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string enabled_prefix = prefix;
        enabled_prefix += "enabled";
        std::ostringstream oss_enabled;
        oss_enabled << "0x" << std::hex << (value->enabled);
        contents.emplace_back("XrBool32", enabled_prefix, oss_enabled.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemEnvironmentDepthPropertiesMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsenvironmentdepth_prefix = prefix;
        supportsenvironmentdepth_prefix += "supportsEnvironmentDepth";
        std::ostringstream oss_supportsEnvironmentDepth;
        oss_supportsEnvironmentDepth << "0x" << std::hex << (value->supportsEnvironmentDepth);
        contents.emplace_back("XrBool32", supportsenvironmentdepth_prefix, oss_supportsEnvironmentDepth.str());
        std::string supportshandremoval_prefix = prefix;
        supportshandremoval_prefix += "supportsHandRemoval";
        std::ostringstream oss_supportsHandRemoval;
        oss_supportsHandRemoval << "0x" << std::hex << (value->supportsHandRemoval);
        contents.emplace_back("XrBool32", supportshandremoval_prefix, oss_supportsHandRemoval.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughCreateInfoHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string form_prefix = prefix;
        form_prefix += "form";
        contents.emplace_back("XrPassthroughFormHTC", form_prefix, std::to_string(value->form));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughColorHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string alpha_prefix = prefix;
        alpha_prefix += "alpha";
        std::ostringstream oss_alpha;
        oss_alpha << std::setprecision(32) << (value->alpha);
        contents.emplace_back("float", alpha_prefix, oss_alpha.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPassthroughMeshTransformInfoHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string vertexcount_prefix = prefix;
        vertexcount_prefix += "vertexCount";
        std::ostringstream oss_vertexCount;
        oss_vertexCount << "0x" << std::hex << (value->vertexCount);
        contents.emplace_back("uint32_t", vertexcount_prefix, oss_vertexCount.str());
        std::string vertices_prefix = prefix;
        vertices_prefix += "vertices";
        std::ostringstream oss_vertices_array;
        oss_vertices_array << std::hex << reinterpret_cast<const void*>(value->vertices);
        contents.emplace_back("const XrVector3f*", vertices_prefix, oss_vertices_array.str());
        for (uint32_t value_vertices_inc = 0; value_vertices_inc < value->vertexCount; ++value_vertices_inc) {
            std::string vertices_array_prefix = vertices_prefix;
            vertices_array_prefix += "[";
            vertices_array_prefix += std::to_string(value_vertices_inc);
            vertices_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->vertices[value_vertices_inc], vertices_array_prefix, "const XrVector3f*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        std::string indexcount_prefix = prefix;
        indexcount_prefix += "indexCount";
        std::ostringstream oss_indexCount;
        oss_indexCount << "0x" << std::hex << (value->indexCount);
        contents.emplace_back("uint32_t", indexcount_prefix, oss_indexCount.str());
        std::string indices_prefix = prefix;
        indices_prefix += "indices";
        std::ostringstream oss_indices_array;
        oss_indices_array << std::hex << (value->indices);
        contents.emplace_back("const uint32_t*", indices_prefix, oss_indices_array.str());
        for (uint32_t value_indices_inc = 0; value_indices_inc < value->indexCount; ++value_indices_inc) {
            std::string indices_array_prefix = indices_prefix;
            indices_array_prefix += "[";
            indices_array_prefix += std::to_string(value_indices_inc);
            indices_array_prefix += "]";
            std::ostringstream oss_indices;
            oss_indices << "0x" << std::hex << (value->indices[value_indices_inc]);
            contents.emplace_back("const uint32_t*", indices_array_prefix, oss_indices.str());
        }
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string scale_prefix = prefix;
        scale_prefix += "scale";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->scale, scale_prefix, "XrVector3f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrCompositionLayerPassthroughHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string layerflags_prefix = prefix;
        layerflags_prefix += "layerFlags";
        contents.emplace_back("XrCompositionLayerFlags", layerflags_prefix, std::to_string(value->layerFlags));
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string passthrough_prefix = prefix;
        passthrough_prefix += "passthrough";
        std::ostringstream oss_passthrough;
        oss_passthrough << std::hex << reinterpret_cast<const void*>(value->passthrough);
        contents.emplace_back("XrPassthroughHTC", passthrough_prefix, oss_passthrough.str());
        std::string color_prefix = prefix;
        color_prefix += "color";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->color, color_prefix, "XrPassthroughColorHTC", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFoveationApplyInfoHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string mode_prefix = prefix;
        mode_prefix += "mode";
        contents.emplace_back("XrFoveationModeHTC", mode_prefix, std::to_string(value->mode));
        std::string subimagecount_prefix = prefix;
        subimagecount_prefix += "subImageCount";
        std::ostringstream oss_subImageCount;
        oss_subImageCount << "0x" << std::hex << (value->subImageCount);
        contents.emplace_back("uint32_t", subimagecount_prefix, oss_subImageCount.str());
        std::string subimages_prefix = prefix;
        subimages_prefix += "subImages";
        std::ostringstream oss_subImages;
        oss_subImages << std::hex << reinterpret_cast<const void*>(value->subImages);
        contents.emplace_back("XrSwapchainSubImage*", subimages_prefix, oss_subImages.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFoveationConfigurationHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string level_prefix = prefix;
        level_prefix += "level";
        contents.emplace_back("XrFoveationLevelHTC", level_prefix, std::to_string(value->level));
        std::string clearfovdegree_prefix = prefix;
        clearfovdegree_prefix += "clearFovDegree";
        std::ostringstream oss_clearFovDegree;
        oss_clearFovDegree << std::setprecision(32) << (value->clearFovDegree);
        contents.emplace_back("float", clearfovdegree_prefix, oss_clearFovDegree.str());
        std::string focalcenteroffset_prefix = prefix;
        focalcenteroffset_prefix += "focalCenterOffset";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->focalCenterOffset, focalcenteroffset_prefix, "XrVector2f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFoveationDynamicModeInfoHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string dynamicflags_prefix = prefix;
        dynamicflags_prefix += "dynamicFlags";
        contents.emplace_back("XrFoveationDynamicFlagsHTC", dynamicflags_prefix, std::to_string(value->dynamicFlags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFoveationCustomModeInfoHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string configcount_prefix = prefix;
        configcount_prefix += "configCount";
        std::ostringstream oss_configCount;
        oss_configCount << "0x" << std::hex << (value->configCount);
        contents.emplace_back("uint32_t", configcount_prefix, oss_configCount.str());
        std::string configs_prefix = prefix;
        configs_prefix += "configs";
        std::ostringstream oss_configs_array;
        oss_configs_array << std::hex << reinterpret_cast<const void*>(value->configs);
        contents.emplace_back("const XrFoveationConfigurationHTC*", configs_prefix, oss_configs_array.str());
        for (uint32_t value_configs_inc = 0; value_configs_inc < value->configCount; ++value_configs_inc) {
            std::string configs_array_prefix = configs_prefix;
            configs_array_prefix += "[";
            configs_array_prefix += std::to_string(value_configs_inc);
            configs_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->configs[value_configs_inc], configs_array_prefix, "const XrFoveationConfigurationHTC*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemAnchorPropertiesHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsanchor_prefix = prefix;
        supportsanchor_prefix += "supportsAnchor";
        std::ostringstream oss_supportsAnchor;
        oss_supportsAnchor << "0x" << std::hex << (value->supportsAnchor);
        contents.emplace_back("XrBool32", supportsanchor_prefix, oss_supportsAnchor.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorNameHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string name_prefix = prefix;
        name_prefix += "name";
        contents.emplace_back("char*", name_prefix, value->name);
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorCreateInfoHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string poseinspace_prefix = prefix;
        poseinspace_prefix += "poseInSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInSpace, poseinspace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string name_prefix = prefix;
        name_prefix += "name";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->name, name_prefix, "XrSpatialAnchorNameHTC", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemBodyTrackingPropertiesHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsbodytracking_prefix = prefix;
        supportsbodytracking_prefix += "supportsBodyTracking";
        std::ostringstream oss_supportsBodyTracking;
        oss_supportsBodyTracking << "0x" << std::hex << (value->supportsBodyTracking);
        contents.emplace_back("XrBool32", supportsbodytracking_prefix, oss_supportsBodyTracking.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodyTrackerCreateInfoHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string bodyjointset_prefix = prefix;
        bodyjointset_prefix += "bodyJointSet";
        contents.emplace_back("XrBodyJointSetHTC", bodyjointset_prefix, std::to_string(value->bodyJointSet));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodyJointsLocateInfoHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodyJointLocationHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string locationflags_prefix = prefix;
        locationflags_prefix += "locationFlags";
        contents.emplace_back("XrSpaceLocationFlags", locationflags_prefix, std::to_string(value->locationFlags));
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodyJointLocationsHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string combinedlocationflags_prefix = prefix;
        combinedlocationflags_prefix += "combinedLocationFlags";
        contents.emplace_back("XrSpaceLocationFlags", combinedlocationflags_prefix, std::to_string(value->combinedLocationFlags));
        std::string confidencelevel_prefix = prefix;
        confidencelevel_prefix += "confidenceLevel";
        contents.emplace_back("XrBodyJointConfidenceHTC", confidencelevel_prefix, std::to_string(value->confidenceLevel));
        std::string jointlocationcount_prefix = prefix;
        jointlocationcount_prefix += "jointLocationCount";
        std::ostringstream oss_jointLocationCount;
        oss_jointLocationCount << "0x" << std::hex << (value->jointLocationCount);
        contents.emplace_back("uint32_t", jointlocationcount_prefix, oss_jointLocationCount.str());
        std::string jointlocations_prefix = prefix;
        jointlocations_prefix += "jointLocations";
        std::ostringstream oss_jointLocations;
        oss_jointLocations << std::hex << reinterpret_cast<const void*>(value->jointLocations);
        contents.emplace_back("XrBodyJointLocationHTC*", jointlocations_prefix, oss_jointLocations.str());
        std::string skeletongenerationid_prefix = prefix;
        skeletongenerationid_prefix += "skeletonGenerationId";
        std::ostringstream oss_skeletonGenerationId;
        oss_skeletonGenerationId << "0x" << std::hex << (value->skeletonGenerationId);
        contents.emplace_back("uint32_t", skeletongenerationid_prefix, oss_skeletonGenerationId.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodySkeletonJointHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodySkeletonHTC* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string jointcount_prefix = prefix;
        jointcount_prefix += "jointCount";
        std::ostringstream oss_jointCount;
        oss_jointCount << "0x" << std::hex << (value->jointCount);
        contents.emplace_back("uint32_t", jointcount_prefix, oss_jointCount.str());
        std::string joints_prefix = prefix;
        joints_prefix += "joints";
        std::ostringstream oss_joints;
        oss_joints << std::hex << reinterpret_cast<const void*>(value->joints);
        contents.emplace_back("XrBodySkeletonJointHTC*", joints_prefix, oss_joints.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrActiveActionSetPriorityEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string actionset_prefix = prefix;
        actionset_prefix += "actionSet";
        std::ostringstream oss_actionSet;
        oss_actionSet << std::hex << reinterpret_cast<const void*>(value->actionSet);
        contents.emplace_back("XrActionSet", actionset_prefix, oss_actionSet.str());
        std::string priorityoverride_prefix = prefix;
        priorityoverride_prefix += "priorityOverride";
        std::ostringstream oss_priorityOverride;
        oss_priorityOverride << "0x" << std::hex << (value->priorityOverride);
        contents.emplace_back("uint32_t", priorityoverride_prefix, oss_priorityOverride.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrActiveActionSetPrioritiesEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string actionsetprioritycount_prefix = prefix;
        actionsetprioritycount_prefix += "actionSetPriorityCount";
        std::ostringstream oss_actionSetPriorityCount;
        oss_actionSetPriorityCount << "0x" << std::hex << (value->actionSetPriorityCount);
        contents.emplace_back("uint32_t", actionsetprioritycount_prefix, oss_actionSetPriorityCount.str());
        std::string actionsetpriorities_prefix = prefix;
        actionsetpriorities_prefix += "actionSetPriorities";
        std::ostringstream oss_actionSetPriorities_array;
        oss_actionSetPriorities_array << std::hex << reinterpret_cast<const void*>(value->actionSetPriorities);
        contents.emplace_back("const XrActiveActionSetPriorityEXT*", actionsetpriorities_prefix, oss_actionSetPriorities_array.str());
        for (uint32_t value_actionsetpriorities_inc = 0; value_actionsetpriorities_inc < value->actionSetPriorityCount; ++value_actionsetpriorities_inc) {
            std::string actionsetpriorities_array_prefix = actionsetpriorities_prefix;
            actionsetpriorities_array_prefix += "[";
            actionsetpriorities_array_prefix += std::to_string(value_actionsetpriorities_inc);
            actionsetpriorities_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->actionSetPriorities[value_actionsetpriorities_inc], actionsetpriorities_array_prefix, "const XrActiveActionSetPriorityEXT*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemForceFeedbackCurlPropertiesMNDX* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsforcefeedbackcurl_prefix = prefix;
        supportsforcefeedbackcurl_prefix += "supportsForceFeedbackCurl";
        std::ostringstream oss_supportsForceFeedbackCurl;
        oss_supportsForceFeedbackCurl << "0x" << std::hex << (value->supportsForceFeedbackCurl);
        contents.emplace_back("XrBool32", supportsforcefeedbackcurl_prefix, oss_supportsForceFeedbackCurl.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrForceFeedbackCurlApplyLocationMNDX* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string location_prefix = prefix;
        location_prefix += "location";
        contents.emplace_back("XrForceFeedbackCurlLocationMNDX", location_prefix, std::to_string(value->location));
        std::string value_prefix = prefix;
        value_prefix += "value";
        std::ostringstream oss_value;
        oss_value << std::setprecision(32) << (value->value);
        contents.emplace_back("float", value_prefix, oss_value.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrForceFeedbackCurlApplyLocationsMNDX* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string locationcount_prefix = prefix;
        locationcount_prefix += "locationCount";
        std::ostringstream oss_locationCount;
        oss_locationCount << "0x" << std::hex << (value->locationCount);
        contents.emplace_back("uint32_t", locationcount_prefix, oss_locationCount.str());
        std::string locations_prefix = prefix;
        locations_prefix += "locations";
        std::ostringstream oss_locations;
        oss_locations << std::hex << reinterpret_cast<const void*>(value->locations);
        contents.emplace_back("XrForceFeedbackCurlApplyLocationMNDX*", locations_prefix, oss_locations.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemBodyTrackingPropertiesBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsbodytracking_prefix = prefix;
        supportsbodytracking_prefix += "supportsBodyTracking";
        std::ostringstream oss_supportsBodyTracking;
        oss_supportsBodyTracking << "0x" << std::hex << (value->supportsBodyTracking);
        contents.emplace_back("XrBool32", supportsbodytracking_prefix, oss_supportsBodyTracking.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodyTrackerCreateInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string jointset_prefix = prefix;
        jointset_prefix += "jointSet";
        contents.emplace_back("XrBodyJointSetBD", jointset_prefix, std::to_string(value->jointSet));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodyJointsLocateInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodyJointLocationBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string locationflags_prefix = prefix;
        locationflags_prefix += "locationFlags";
        contents.emplace_back("XrSpaceLocationFlags", locationflags_prefix, std::to_string(value->locationFlags));
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrBodyJointLocationsBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string alljointposestracked_prefix = prefix;
        alljointposestracked_prefix += "allJointPosesTracked";
        std::ostringstream oss_allJointPosesTracked;
        oss_allJointPosesTracked << "0x" << std::hex << (value->allJointPosesTracked);
        contents.emplace_back("XrBool32", alljointposestracked_prefix, oss_allJointPosesTracked.str());
        std::string jointlocationcount_prefix = prefix;
        jointlocationcount_prefix += "jointLocationCount";
        std::ostringstream oss_jointLocationCount;
        oss_jointLocationCount << "0x" << std::hex << (value->jointLocationCount);
        contents.emplace_back("uint32_t", jointlocationcount_prefix, oss_jointLocationCount.str());
        std::string jointlocations_prefix = prefix;
        jointlocations_prefix += "jointLocations";
        std::ostringstream oss_jointLocations;
        oss_jointLocations << std::hex << reinterpret_cast<const void*>(value->jointLocations);
        contents.emplace_back("XrBodyJointLocationBD*", jointlocations_prefix, oss_jointLocations.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemSpatialSensingPropertiesBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsspatialsensing_prefix = prefix;
        supportsspatialsensing_prefix += "supportsSpatialSensing";
        std::ostringstream oss_supportsSpatialSensing;
        oss_supportsSpatialSensing << "0x" << std::hex << (value->supportsSpatialSensing);
        contents.emplace_back("XrBool32", supportsspatialsensing_prefix, oss_supportsSpatialSensing.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialEntityComponentGetInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string entityid_prefix = prefix;
        entityid_prefix += "entityId";
        contents.emplace_back("XrSpatialEntityIdBD", entityid_prefix, std::to_string(value->entityId));
        std::string componenttype_prefix = prefix;
        componenttype_prefix += "componentType";
        contents.emplace_back("XrSpatialEntityComponentTypeBD", componenttype_prefix, std::to_string(value->componentType));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialEntityComponentDataBaseHeaderBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        // Fallback path - Just output generic information about the base struct
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialEntityLocationGetInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialEntityComponentDataLocationBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string location_prefix = prefix;
        location_prefix += "location";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->location, location_prefix, "XrSpaceLocation", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialEntityComponentDataSemanticBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string labelcapacityinput_prefix = prefix;
        labelcapacityinput_prefix += "labelCapacityInput";
        std::ostringstream oss_labelCapacityInput;
        oss_labelCapacityInput << "0x" << std::hex << (value->labelCapacityInput);
        contents.emplace_back("uint32_t", labelcapacityinput_prefix, oss_labelCapacityInput.str());
        std::string labelcountoutput_prefix = prefix;
        labelcountoutput_prefix += "labelCountOutput";
        std::ostringstream oss_labelCountOutput;
        oss_labelCountOutput << "0x" << std::hex << (value->labelCountOutput);
        contents.emplace_back("uint32_t", labelcountoutput_prefix, oss_labelCountOutput.str());
        std::string labels_prefix = prefix;
        labels_prefix += "labels";
        std::ostringstream oss_labels;
        oss_labels << std::hex << reinterpret_cast<const void*>(value->labels);
        contents.emplace_back("XrSemanticLabelBD*", labels_prefix, oss_labels.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialEntityComponentDataBoundingBox2DBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string boundingbox2d_prefix = prefix;
        boundingbox2d_prefix += "boundingBox2D";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->boundingBox2D, boundingbox2d_prefix, "XrRect2Df", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialEntityComponentDataPolygonBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string vertexcapacityinput_prefix = prefix;
        vertexcapacityinput_prefix += "vertexCapacityInput";
        std::ostringstream oss_vertexCapacityInput;
        oss_vertexCapacityInput << "0x" << std::hex << (value->vertexCapacityInput);
        contents.emplace_back("uint32_t", vertexcapacityinput_prefix, oss_vertexCapacityInput.str());
        std::string vertexcountoutput_prefix = prefix;
        vertexcountoutput_prefix += "vertexCountOutput";
        std::ostringstream oss_vertexCountOutput;
        oss_vertexCountOutput << "0x" << std::hex << (value->vertexCountOutput);
        contents.emplace_back("uint32_t", vertexcountoutput_prefix, oss_vertexCountOutput.str());
        std::string vertices_prefix = prefix;
        vertices_prefix += "vertices";
        std::ostringstream oss_vertices;
        oss_vertices << std::hex << reinterpret_cast<const void*>(value->vertices);
        contents.emplace_back("XrVector2f*", vertices_prefix, oss_vertices.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialEntityComponentDataBoundingBox3DBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string boundingbox3d_prefix = prefix;
        boundingbox3d_prefix += "boundingBox3D";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->boundingBox3D, boundingbox3d_prefix, "XrBoxf", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialEntityComponentDataTriangleMeshBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string vertexcapacityinput_prefix = prefix;
        vertexcapacityinput_prefix += "vertexCapacityInput";
        std::ostringstream oss_vertexCapacityInput;
        oss_vertexCapacityInput << "0x" << std::hex << (value->vertexCapacityInput);
        contents.emplace_back("uint32_t", vertexcapacityinput_prefix, oss_vertexCapacityInput.str());
        std::string vertexcountoutput_prefix = prefix;
        vertexcountoutput_prefix += "vertexCountOutput";
        std::ostringstream oss_vertexCountOutput;
        oss_vertexCountOutput << "0x" << std::hex << (value->vertexCountOutput);
        contents.emplace_back("uint32_t", vertexcountoutput_prefix, oss_vertexCountOutput.str());
        std::string vertices_prefix = prefix;
        vertices_prefix += "vertices";
        std::ostringstream oss_vertices;
        oss_vertices << std::hex << reinterpret_cast<const void*>(value->vertices);
        contents.emplace_back("XrVector3f*", vertices_prefix, oss_vertices.str());
        std::string indexcapacityinput_prefix = prefix;
        indexcapacityinput_prefix += "indexCapacityInput";
        std::ostringstream oss_indexCapacityInput;
        oss_indexCapacityInput << "0x" << std::hex << (value->indexCapacityInput);
        contents.emplace_back("uint32_t", indexcapacityinput_prefix, oss_indexCapacityInput.str());
        std::string indexcountoutput_prefix = prefix;
        indexcountoutput_prefix += "indexCountOutput";
        std::ostringstream oss_indexCountOutput;
        oss_indexCountOutput << "0x" << std::hex << (value->indexCountOutput);
        contents.emplace_back("uint32_t", indexcountoutput_prefix, oss_indexCountOutput.str());
        std::string indices_prefix = prefix;
        indices_prefix += "indices";
        std::ostringstream oss_indices;
        oss_indices << "0x" << std::hex << (value->indices);
        contents.emplace_back("uint16_t*", indices_prefix, oss_indices.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSenseDataProviderCreateInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string providertype_prefix = prefix;
        providertype_prefix += "providerType";
        contents.emplace_back("XrSenseDataProviderTypeBD", providertype_prefix, std::to_string(value->providerType));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSenseDataProviderStartInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataSenseDataProviderStateChangedBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string provider_prefix = prefix;
        provider_prefix += "provider";
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(value->provider);
        contents.emplace_back("XrSenseDataProviderBD", provider_prefix, oss_provider.str());
        std::string newstate_prefix = prefix;
        newstate_prefix += "newState";
        contents.emplace_back("XrSenseDataProviderStateBD", newstate_prefix, std::to_string(value->newState));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataSenseDataUpdatedBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string provider_prefix = prefix;
        provider_prefix += "provider";
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(value->provider);
        contents.emplace_back("XrSenseDataProviderBD", provider_prefix, oss_provider.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSenseDataQueryInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSenseDataQueryCompletionBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string futureresult_prefix = prefix;
        futureresult_prefix += "futureResult";
        if (nullptr != gen_dispatch_table) {
            char futureResult_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->futureResult, futureResult_string);
            contents.emplace_back("XrResult", futureresult_prefix, futureResult_string);
        } else {
                        contents.emplace_back("XrResult", futureresult_prefix, std::to_string(value->futureResult));
        }
        std::string snapshot_prefix = prefix;
        snapshot_prefix += "snapshot";
        std::ostringstream oss_snapshot;
        oss_snapshot << std::hex << reinterpret_cast<const void*>(value->snapshot);
        contents.emplace_back("XrSenseDataSnapshotBD", snapshot_prefix, oss_snapshot.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrQueriedSenseDataGetInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialEntityStateBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string entityid_prefix = prefix;
        entityid_prefix += "entityId";
        contents.emplace_back("XrSpatialEntityIdBD", entityid_prefix, std::to_string(value->entityId));
        std::string lastupdatetime_prefix = prefix;
        lastupdatetime_prefix += "lastUpdateTime";
        contents.emplace_back("XrTime", lastupdatetime_prefix, std::to_string(value->lastUpdateTime));
        std::string uuid_prefix = prefix;
        uuid_prefix += "uuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuid, uuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrQueriedSenseDataBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string statecapacityinput_prefix = prefix;
        statecapacityinput_prefix += "stateCapacityInput";
        std::ostringstream oss_stateCapacityInput;
        oss_stateCapacityInput << "0x" << std::hex << (value->stateCapacityInput);
        contents.emplace_back("uint32_t", statecapacityinput_prefix, oss_stateCapacityInput.str());
        std::string statecountoutput_prefix = prefix;
        statecountoutput_prefix += "stateCountOutput";
        std::ostringstream oss_stateCountOutput;
        oss_stateCountOutput << "0x" << std::hex << (value->stateCountOutput);
        contents.emplace_back("uint32_t", statecountoutput_prefix, oss_stateCountOutput.str());
        std::string states_prefix = prefix;
        states_prefix += "states";
        std::ostringstream oss_states;
        oss_states << std::hex << reinterpret_cast<const void*>(value->states);
        contents.emplace_back("XrSpatialEntityStateBD*", states_prefix, oss_states.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSenseDataFilterUuidBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string uuidcount_prefix = prefix;
        uuidcount_prefix += "uuidCount";
        std::ostringstream oss_uuidCount;
        oss_uuidCount << "0x" << std::hex << (value->uuidCount);
        contents.emplace_back("uint32_t", uuidcount_prefix, oss_uuidCount.str());
        std::string uuids_prefix = prefix;
        uuids_prefix += "uuids";
        std::ostringstream oss_uuids_array;
        oss_uuids_array << std::hex << reinterpret_cast<const void*>(value->uuids);
        contents.emplace_back("const XrUuidEXT*", uuids_prefix, oss_uuids_array.str());
        for (uint32_t value_uuids_inc = 0; value_uuids_inc < value->uuidCount; ++value_uuids_inc) {
            std::string uuids_array_prefix = uuids_prefix;
            uuids_array_prefix += "[";
            uuids_array_prefix += std::to_string(value_uuids_inc);
            uuids_array_prefix += "]";
            if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuids[value_uuids_inc], uuids_array_prefix, "const XrUuidEXT*", false, contents)) {
                throw std::invalid_argument("Invalid Operation");
            }
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSenseDataFilterSemanticBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string labelcount_prefix = prefix;
        labelcount_prefix += "labelCount";
        std::ostringstream oss_labelCount;
        oss_labelCount << "0x" << std::hex << (value->labelCount);
        contents.emplace_back("uint32_t", labelcount_prefix, oss_labelCount.str());
        std::string labels_prefix = prefix;
        labels_prefix += "labels";
        std::ostringstream oss_labels_array;
        oss_labels_array << std::hex << reinterpret_cast<const void*>(value->labels);
        contents.emplace_back("const XrSemanticLabelBD*", labels_prefix, oss_labels_array.str());
        for (uint32_t value_labels_inc = 0; value_labels_inc < value->labelCount; ++value_labels_inc) {
            std::string labels_array_prefix = labels_prefix;
            labels_array_prefix += "[";
            labels_array_prefix += std::to_string(value_labels_inc);
            labels_array_prefix += "]";
            contents.emplace_back("const XrSemanticLabelBD*", labels_array_prefix, std::to_string(value->labels[value_labels_inc]));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialEntityAnchorCreateInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string snapshot_prefix = prefix;
        snapshot_prefix += "snapshot";
        std::ostringstream oss_snapshot;
        oss_snapshot << std::hex << reinterpret_cast<const void*>(value->snapshot);
        contents.emplace_back("XrSenseDataSnapshotBD", snapshot_prefix, oss_snapshot.str());
        std::string entityid_prefix = prefix;
        entityid_prefix += "entityId";
        contents.emplace_back("XrSpatialEntityIdBD", entityid_prefix, std::to_string(value->entityId));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrAnchorSpaceCreateInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string anchor_prefix = prefix;
        anchor_prefix += "anchor";
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(value->anchor);
        contents.emplace_back("XrAnchorBD", anchor_prefix, oss_anchor.str());
        std::string poseinanchorspace_prefix = prefix;
        poseinanchorspace_prefix += "poseInAnchorSpace";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->poseInAnchorSpace, poseinanchorspace_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFutureCompletionEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string futureresult_prefix = prefix;
        futureresult_prefix += "futureResult";
        if (nullptr != gen_dispatch_table) {
            char futureResult_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->futureResult, futureResult_string);
            contents.emplace_back("XrResult", futureresult_prefix, futureResult_string);
        } else {
                        contents.emplace_back("XrResult", futureresult_prefix, std::to_string(value->futureResult));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemSpatialAnchorPropertiesBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsspatialanchor_prefix = prefix;
        supportsspatialanchor_prefix += "supportsSpatialAnchor";
        std::ostringstream oss_supportsSpatialAnchor;
        oss_supportsSpatialAnchor << "0x" << std::hex << (value->supportsSpatialAnchor);
        contents.emplace_back("XrBool32", supportsspatialanchor_prefix, oss_supportsSpatialAnchor.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorCreateInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string space_prefix = prefix;
        space_prefix += "space";
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(value->space);
        contents.emplace_back("XrSpace", space_prefix, oss_space.str());
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorCreateCompletionBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string futureresult_prefix = prefix;
        futureresult_prefix += "futureResult";
        if (nullptr != gen_dispatch_table) {
            char futureResult_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->futureResult, futureResult_string);
            contents.emplace_back("XrResult", futureresult_prefix, futureResult_string);
        } else {
                        contents.emplace_back("XrResult", futureresult_prefix, std::to_string(value->futureResult));
        }
        std::string anchor_prefix = prefix;
        anchor_prefix += "anchor";
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(value->anchor);
        contents.emplace_back("XrAnchorBD", anchor_prefix, oss_anchor.str());
        std::string uuid_prefix = prefix;
        uuid_prefix += "uuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuid, uuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorPersistInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string location_prefix = prefix;
        location_prefix += "location";
        contents.emplace_back("XrPersistenceLocationBD", location_prefix, std::to_string(value->location));
        std::string anchor_prefix = prefix;
        anchor_prefix += "anchor";
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(value->anchor);
        contents.emplace_back("XrAnchorBD", anchor_prefix, oss_anchor.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorUnpersistInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string location_prefix = prefix;
        location_prefix += "location";
        contents.emplace_back("XrPersistenceLocationBD", location_prefix, std::to_string(value->location));
        std::string anchor_prefix = prefix;
        anchor_prefix += "anchor";
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(value->anchor);
        contents.emplace_back("XrAnchorBD", anchor_prefix, oss_anchor.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemSpatialAnchorSharingPropertiesBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsspatialanchorsharing_prefix = prefix;
        supportsspatialanchorsharing_prefix += "supportsSpatialAnchorSharing";
        std::ostringstream oss_supportsSpatialAnchorSharing;
        oss_supportsSpatialAnchorSharing << "0x" << std::hex << (value->supportsSpatialAnchorSharing);
        contents.emplace_back("XrBool32", supportsspatialanchorsharing_prefix, oss_supportsSpatialAnchorSharing.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpatialAnchorShareInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string anchor_prefix = prefix;
        anchor_prefix += "anchor";
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(value->anchor);
        contents.emplace_back("XrAnchorBD", anchor_prefix, oss_anchor.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSharedSpatialAnchorDownloadInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string uuid_prefix = prefix;
        uuid_prefix += "uuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuid, uuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemSpatialScenePropertiesBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsspatialscene_prefix = prefix;
        supportsspatialscene_prefix += "supportsSpatialScene";
        std::ostringstream oss_supportsSpatialScene;
        oss_supportsSpatialScene << "0x" << std::hex << (value->supportsSpatialScene);
        contents.emplace_back("XrBool32", supportsspatialscene_prefix, oss_supportsSpatialScene.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSceneCaptureInfoBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemSpatialMeshPropertiesBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsspatialmesh_prefix = prefix;
        supportsspatialmesh_prefix += "supportsSpatialMesh";
        std::ostringstream oss_supportsSpatialMesh;
        oss_supportsSpatialMesh << "0x" << std::hex << (value->supportsSpatialMesh);
        contents.emplace_back("XrBool32", supportsspatialmesh_prefix, oss_supportsSpatialMesh.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSenseDataProviderCreateInfoSpatialMeshBD* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string configflags_prefix = prefix;
        configflags_prefix += "configFlags";
        contents.emplace_back("XrSpatialMeshConfigFlagsBD", configflags_prefix, std::to_string(value->configFlags));
        std::string lod_prefix = prefix;
        lod_prefix += "lod";
        contents.emplace_back("XrSpatialMeshLodBD", lod_prefix, std::to_string(value->lod));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandTrackingDataSourceInfoEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requesteddatasourcecount_prefix = prefix;
        requesteddatasourcecount_prefix += "requestedDataSourceCount";
        std::ostringstream oss_requestedDataSourceCount;
        oss_requestedDataSourceCount << "0x" << std::hex << (value->requestedDataSourceCount);
        contents.emplace_back("uint32_t", requesteddatasourcecount_prefix, oss_requestedDataSourceCount.str());
        std::string requesteddatasources_prefix = prefix;
        requesteddatasources_prefix += "requestedDataSources";
        std::ostringstream oss_requestedDataSources;
        oss_requestedDataSources << std::hex << reinterpret_cast<const void*>(value->requestedDataSources);
        contents.emplace_back("XrHandTrackingDataSourceEXT*", requesteddatasources_prefix, oss_requestedDataSources.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrHandTrackingDataSourceStateEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string isactive_prefix = prefix;
        isactive_prefix += "isActive";
        std::ostringstream oss_isActive;
        oss_isActive << "0x" << std::hex << (value->isActive);
        contents.emplace_back("XrBool32", isactive_prefix, oss_isActive.str());
        std::string datasource_prefix = prefix;
        datasource_prefix += "dataSource";
        contents.emplace_back("XrHandTrackingDataSourceEXT", datasource_prefix, std::to_string(value->dataSource));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemPlaneDetectionPropertiesEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportedfeatures_prefix = prefix;
        supportedfeatures_prefix += "supportedFeatures";
        contents.emplace_back("XrPlaneDetectionCapabilityFlagsEXT", supportedfeatures_prefix, std::to_string(value->supportedFeatures));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPlaneDetectorCreateInfoEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrPlaneDetectorFlagsEXT", flags_prefix, std::to_string(value->flags));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPlaneDetectorBeginInfoEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        std::string orientationcount_prefix = prefix;
        orientationcount_prefix += "orientationCount";
        std::ostringstream oss_orientationCount;
        oss_orientationCount << "0x" << std::hex << (value->orientationCount);
        contents.emplace_back("uint32_t", orientationcount_prefix, oss_orientationCount.str());
        std::string orientations_prefix = prefix;
        orientations_prefix += "orientations";
        std::ostringstream oss_orientations_array;
        oss_orientations_array << std::hex << reinterpret_cast<const void*>(value->orientations);
        contents.emplace_back("const XrPlaneDetectorOrientationEXT*", orientations_prefix, oss_orientations_array.str());
        for (uint32_t value_orientations_inc = 0; value_orientations_inc < value->orientationCount; ++value_orientations_inc) {
            std::string orientations_array_prefix = orientations_prefix;
            orientations_array_prefix += "[";
            orientations_array_prefix += std::to_string(value_orientations_inc);
            orientations_array_prefix += "]";
            contents.emplace_back("const XrPlaneDetectorOrientationEXT*", orientations_array_prefix, std::to_string(value->orientations[value_orientations_inc]));
        }
        std::string semantictypecount_prefix = prefix;
        semantictypecount_prefix += "semanticTypeCount";
        std::ostringstream oss_semanticTypeCount;
        oss_semanticTypeCount << "0x" << std::hex << (value->semanticTypeCount);
        contents.emplace_back("uint32_t", semantictypecount_prefix, oss_semanticTypeCount.str());
        std::string semantictypes_prefix = prefix;
        semantictypes_prefix += "semanticTypes";
        std::ostringstream oss_semanticTypes_array;
        oss_semanticTypes_array << std::hex << reinterpret_cast<const void*>(value->semanticTypes);
        contents.emplace_back("const XrPlaneDetectorSemanticTypeEXT*", semantictypes_prefix, oss_semanticTypes_array.str());
        for (uint32_t value_semantictypes_inc = 0; value_semantictypes_inc < value->semanticTypeCount; ++value_semantictypes_inc) {
            std::string semantictypes_array_prefix = semantictypes_prefix;
            semantictypes_array_prefix += "[";
            semantictypes_array_prefix += std::to_string(value_semantictypes_inc);
            semantictypes_array_prefix += "]";
            contents.emplace_back("const XrPlaneDetectorSemanticTypeEXT*", semantictypes_array_prefix, std::to_string(value->semanticTypes[value_semantictypes_inc]));
        }
        std::string maxplanes_prefix = prefix;
        maxplanes_prefix += "maxPlanes";
        std::ostringstream oss_maxPlanes;
        oss_maxPlanes << "0x" << std::hex << (value->maxPlanes);
        contents.emplace_back("uint32_t", maxplanes_prefix, oss_maxPlanes.str());
        std::string minarea_prefix = prefix;
        minarea_prefix += "minArea";
        std::ostringstream oss_minArea;
        oss_minArea << std::setprecision(32) << (value->minArea);
        contents.emplace_back("float", minarea_prefix, oss_minArea.str());
        std::string boundingboxpose_prefix = prefix;
        boundingboxpose_prefix += "boundingBoxPose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->boundingBoxPose, boundingboxpose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string boundingboxextent_prefix = prefix;
        boundingboxextent_prefix += "boundingBoxExtent";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->boundingBoxExtent, boundingboxextent_prefix, "XrExtent3DfEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPlaneDetectorGetInfoEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPlaneDetectorLocationEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string planeid_prefix = prefix;
        planeid_prefix += "planeId";
        std::ostringstream oss_planeId;
        oss_planeId << "0x" << std::hex << (value->planeId);
        contents.emplace_back("uint64_t", planeid_prefix, oss_planeId.str());
        std::string locationflags_prefix = prefix;
        locationflags_prefix += "locationFlags";
        contents.emplace_back("XrSpaceLocationFlags", locationflags_prefix, std::to_string(value->locationFlags));
        std::string pose_prefix = prefix;
        pose_prefix += "pose";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->pose, pose_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string extents_prefix = prefix;
        extents_prefix += "extents";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->extents, extents_prefix, "XrExtent2Df", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string orientation_prefix = prefix;
        orientation_prefix += "orientation";
        contents.emplace_back("XrPlaneDetectorOrientationEXT", orientation_prefix, std::to_string(value->orientation));
        std::string semantictype_prefix = prefix;
        semantictype_prefix += "semanticType";
        contents.emplace_back("XrPlaneDetectorSemanticTypeEXT", semantictype_prefix, std::to_string(value->semanticType));
        std::string polygonbuffercount_prefix = prefix;
        polygonbuffercount_prefix += "polygonBufferCount";
        std::ostringstream oss_polygonBufferCount;
        oss_polygonBufferCount << "0x" << std::hex << (value->polygonBufferCount);
        contents.emplace_back("uint32_t", polygonbuffercount_prefix, oss_polygonBufferCount.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPlaneDetectorLocationsEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string planelocationcapacityinput_prefix = prefix;
        planelocationcapacityinput_prefix += "planeLocationCapacityInput";
        std::ostringstream oss_planeLocationCapacityInput;
        oss_planeLocationCapacityInput << "0x" << std::hex << (value->planeLocationCapacityInput);
        contents.emplace_back("uint32_t", planelocationcapacityinput_prefix, oss_planeLocationCapacityInput.str());
        std::string planelocationcountoutput_prefix = prefix;
        planelocationcountoutput_prefix += "planeLocationCountOutput";
        std::ostringstream oss_planeLocationCountOutput;
        oss_planeLocationCountOutput << "0x" << std::hex << (value->planeLocationCountOutput);
        contents.emplace_back("uint32_t", planelocationcountoutput_prefix, oss_planeLocationCountOutput.str());
        std::string planelocations_prefix = prefix;
        planelocations_prefix += "planeLocations";
        std::ostringstream oss_planeLocations;
        oss_planeLocations << std::hex << reinterpret_cast<const void*>(value->planeLocations);
        contents.emplace_back("XrPlaneDetectorLocationEXT*", planelocations_prefix, oss_planeLocations.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrPlaneDetectorPolygonBufferEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string vertexcapacityinput_prefix = prefix;
        vertexcapacityinput_prefix += "vertexCapacityInput";
        std::ostringstream oss_vertexCapacityInput;
        oss_vertexCapacityInput << "0x" << std::hex << (value->vertexCapacityInput);
        contents.emplace_back("uint32_t", vertexcapacityinput_prefix, oss_vertexCapacityInput.str());
        std::string vertexcountoutput_prefix = prefix;
        vertexcountoutput_prefix += "vertexCountOutput";
        std::ostringstream oss_vertexCountOutput;
        oss_vertexCountOutput << "0x" << std::hex << (value->vertexCountOutput);
        contents.emplace_back("uint32_t", vertexcountoutput_prefix, oss_vertexCountOutput.str());
        std::string vertices_prefix = prefix;
        vertices_prefix += "vertices";
        std::ostringstream oss_vertices;
        oss_vertices << std::hex << reinterpret_cast<const void*>(value->vertices);
        contents.emplace_back("XrVector2f*", vertices_prefix, oss_vertices.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFutureCancelInfoEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string future_prefix = prefix;
        future_prefix += "future";
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(value->future);
        contents.emplace_back("XrFutureEXT", future_prefix, oss_future.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFuturePollInfoEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string future_prefix = prefix;
        future_prefix += "future";
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(value->future);
        contents.emplace_back("XrFutureEXT", future_prefix, oss_future.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFutureCompletionBaseHeaderEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        if (value->type == XR_TYPE_WORLD_MESH_STATE_REQUEST_COMPLETION_ML) {
            const XrWorldMeshStateRequestCompletionML* new_value = reinterpret_cast<const XrWorldMeshStateRequestCompletionML*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        if (value->type == XR_TYPE_WORLD_MESH_REQUEST_COMPLETION_ML) {
            const XrWorldMeshRequestCompletionML* new_value = reinterpret_cast<const XrWorldMeshRequestCompletionML*>(value);
            return ApiDumpOutputXrStruct(gen_dispatch_table, new_value, prefix, type_string, is_pointer, contents);
        }
        // Fallback path - Just output generic information about the base struct
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string futureresult_prefix = prefix;
        futureresult_prefix += "futureResult";
        if (nullptr != gen_dispatch_table) {
            char futureResult_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->futureResult, futureResult_string);
            contents.emplace_back("XrResult", futureresult_prefix, futureResult_string);
        } else {
                        contents.emplace_back("XrResult", futureresult_prefix, std::to_string(value->futureResult));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFuturePollResultEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string state_prefix = prefix;
        state_prefix += "state";
        contents.emplace_back("XrFutureStateEXT", state_prefix, std::to_string(value->state));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataUserPresenceChangedEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string session_prefix = prefix;
        session_prefix += "session";
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(value->session);
        contents.emplace_back("XrSession", session_prefix, oss_session.str());
        std::string isuserpresent_prefix = prefix;
        isuserpresent_prefix += "isUserPresent";
        std::ostringstream oss_isUserPresent;
        oss_isUserPresent << "0x" << std::hex << (value->isUserPresent);
        contents.emplace_back("XrBool32", isuserpresent_prefix, oss_isUserPresent.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemUserPresencePropertiesEXT* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsuserpresence_prefix = prefix;
        supportsuserpresence_prefix += "supportsUserPresence";
        std::ostringstream oss_supportsUserPresence;
        oss_supportsUserPresence << "0x" << std::hex << (value->supportsUserPresence);
        contents.emplace_back("XrBool32", supportsuserpresence_prefix, oss_supportsUserPresence.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataHeadsetFitChangedML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string status_prefix = prefix;
        status_prefix += "status";
        contents.emplace_back("XrHeadsetFitStatusML", status_prefix, std::to_string(value->status));
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataEyeCalibrationChangedML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string status_prefix = prefix;
        status_prefix += "status";
        contents.emplace_back("XrEyeCalibrationStatusML", status_prefix, std::to_string(value->status));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrUserCalibrationEnableEventsInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string enabled_prefix = prefix;
        enabled_prefix += "enabled";
        std::ostringstream oss_enabled;
        oss_enabled << "0x" << std::hex << (value->enabled);
        contents.emplace_back("XrBool32", enabled_prefix, oss_enabled.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemNotificationsSetInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string suppressnotifications_prefix = prefix;
        suppressnotifications_prefix += "suppressNotifications";
        std::ostringstream oss_suppressNotifications;
        oss_suppressNotifications << "0x" << std::hex << (value->suppressNotifications);
        contents.emplace_back("XrBool32", suppressnotifications_prefix, oss_suppressNotifications.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrWorldMeshDetectorCreateInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrWorldMeshBlockStateML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string uuid_prefix = prefix;
        uuid_prefix += "uuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuid, uuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string meshboundingboxcenter_prefix = prefix;
        meshboundingboxcenter_prefix += "meshBoundingBoxCenter";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->meshBoundingBoxCenter, meshboundingboxcenter_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string meshboundingboxextents_prefix = prefix;
        meshboundingboxextents_prefix += "meshBoundingBoxExtents";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->meshBoundingBoxExtents, meshboundingboxextents_prefix, "XrExtent3DfEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string lastupdatetime_prefix = prefix;
        lastupdatetime_prefix += "lastUpdateTime";
        contents.emplace_back("XrTime", lastupdatetime_prefix, std::to_string(value->lastUpdateTime));
        std::string status_prefix = prefix;
        status_prefix += "status";
        contents.emplace_back("XrWorldMeshBlockStatusML", status_prefix, std::to_string(value->status));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrWorldMeshStateRequestInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string basespace_prefix = prefix;
        basespace_prefix += "baseSpace";
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(value->baseSpace);
        contents.emplace_back("XrSpace", basespace_prefix, oss_baseSpace.str());
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        std::string boundingboxcenter_prefix = prefix;
        boundingboxcenter_prefix += "boundingBoxCenter";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->boundingBoxCenter, boundingboxcenter_prefix, "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string boundingboxextents_prefix = prefix;
        boundingboxextents_prefix += "boundingBoxExtents";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->boundingBoxExtents, boundingboxextents_prefix, "XrExtent3DfEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrWorldMeshStateRequestCompletionML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string futureresult_prefix = prefix;
        futureresult_prefix += "futureResult";
        if (nullptr != gen_dispatch_table) {
            char futureResult_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->futureResult, futureResult_string);
            contents.emplace_back("XrResult", futureresult_prefix, futureResult_string);
        } else {
                        contents.emplace_back("XrResult", futureresult_prefix, std::to_string(value->futureResult));
        }
        std::string timestamp_prefix = prefix;
        timestamp_prefix += "timestamp";
        contents.emplace_back("XrTime", timestamp_prefix, std::to_string(value->timestamp));
        std::string meshblockstatecapacityinput_prefix = prefix;
        meshblockstatecapacityinput_prefix += "meshBlockStateCapacityInput";
        std::ostringstream oss_meshBlockStateCapacityInput;
        oss_meshBlockStateCapacityInput << "0x" << std::hex << (value->meshBlockStateCapacityInput);
        contents.emplace_back("uint32_t", meshblockstatecapacityinput_prefix, oss_meshBlockStateCapacityInput.str());
        std::string meshblockstatecountoutput_prefix = prefix;
        meshblockstatecountoutput_prefix += "meshBlockStateCountOutput";
        std::ostringstream oss_meshBlockStateCountOutput;
        oss_meshBlockStateCountOutput << "0x" << std::hex << (value->meshBlockStateCountOutput);
        contents.emplace_back("uint32_t", meshblockstatecountoutput_prefix, oss_meshBlockStateCountOutput.str());
        std::string meshblockstates_prefix = prefix;
        meshblockstates_prefix += "meshBlockStates";
        std::ostringstream oss_meshBlockStates;
        oss_meshBlockStates << std::hex << reinterpret_cast<const void*>(value->meshBlockStates);
        contents.emplace_back("XrWorldMeshBlockStateML*", meshblockstates_prefix, oss_meshBlockStates.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrWorldMeshBufferRecommendedSizeInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string maxblockcount_prefix = prefix;
        maxblockcount_prefix += "maxBlockCount";
        std::ostringstream oss_maxBlockCount;
        oss_maxBlockCount << "0x" << std::hex << (value->maxBlockCount);
        contents.emplace_back("uint32_t", maxblockcount_prefix, oss_maxBlockCount.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrWorldMeshBufferSizeML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string size_prefix = prefix;
        size_prefix += "size";
        std::ostringstream oss_size;
        oss_size << "0x" << std::hex << (value->size);
        contents.emplace_back("uint32_t", size_prefix, oss_size.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrWorldMeshBufferML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string buffersize_prefix = prefix;
        buffersize_prefix += "bufferSize";
        std::ostringstream oss_bufferSize;
        oss_bufferSize << "0x" << std::hex << (value->bufferSize);
        contents.emplace_back("uint32_t", buffersize_prefix, oss_bufferSize.str());
        std::string buffer_prefix = prefix;
        buffer_prefix += "buffer";
        std::ostringstream oss_buffer_array;
        oss_buffer_array << std::hex << reinterpret_cast<const void*>(value->buffer);
        contents.emplace_back("void* XR_MAY_ALIAS", buffer_prefix, oss_buffer_array.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrWorldMeshBlockRequestML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string uuid_prefix = prefix;
        uuid_prefix += "uuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuid, uuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string lod_prefix = prefix;
        lod_prefix += "lod";
        contents.emplace_back("XrWorldMeshDetectorLodML", lod_prefix, std::to_string(value->lod));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrWorldMeshGetInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrWorldMeshDetectorFlagsML", flags_prefix, std::to_string(value->flags));
        std::string fillholelength_prefix = prefix;
        fillholelength_prefix += "fillHoleLength";
        std::ostringstream oss_fillHoleLength;
        oss_fillHoleLength << std::setprecision(32) << (value->fillHoleLength);
        contents.emplace_back("float", fillholelength_prefix, oss_fillHoleLength.str());
        std::string disconnectedcomponentarea_prefix = prefix;
        disconnectedcomponentarea_prefix += "disconnectedComponentArea";
        std::ostringstream oss_disconnectedComponentArea;
        oss_disconnectedComponentArea << std::setprecision(32) << (value->disconnectedComponentArea);
        contents.emplace_back("float", disconnectedcomponentarea_prefix, oss_disconnectedComponentArea.str());
        std::string blockcount_prefix = prefix;
        blockcount_prefix += "blockCount";
        std::ostringstream oss_blockCount;
        oss_blockCount << "0x" << std::hex << (value->blockCount);
        contents.emplace_back("uint32_t", blockcount_prefix, oss_blockCount.str());
        std::string blocks_prefix = prefix;
        blocks_prefix += "blocks";
        std::ostringstream oss_blocks;
        oss_blocks << std::hex << reinterpret_cast<const void*>(value->blocks);
        contents.emplace_back("XrWorldMeshBlockRequestML*", blocks_prefix, oss_blocks.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrWorldMeshBlockML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string uuid_prefix = prefix;
        uuid_prefix += "uuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->uuid, uuid_prefix, "XrUuidEXT", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string blockresult_prefix = prefix;
        blockresult_prefix += "blockResult";
        contents.emplace_back("XrWorldMeshBlockResultML", blockresult_prefix, std::to_string(value->blockResult));
        std::string lod_prefix = prefix;
        lod_prefix += "lod";
        contents.emplace_back("XrWorldMeshDetectorLodML", lod_prefix, std::to_string(value->lod));
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrWorldMeshDetectorFlagsML", flags_prefix, std::to_string(value->flags));
        std::string indexcount_prefix = prefix;
        indexcount_prefix += "indexCount";
        std::ostringstream oss_indexCount;
        oss_indexCount << "0x" << std::hex << (value->indexCount);
        contents.emplace_back("uint32_t", indexcount_prefix, oss_indexCount.str());
        std::string indexbuffer_prefix = prefix;
        indexbuffer_prefix += "indexBuffer";
        std::ostringstream oss_indexBuffer;
        oss_indexBuffer << "0x" << std::hex << (value->indexBuffer);
        contents.emplace_back("uint16_t*", indexbuffer_prefix, oss_indexBuffer.str());
        std::string vertexcount_prefix = prefix;
        vertexcount_prefix += "vertexCount";
        std::ostringstream oss_vertexCount;
        oss_vertexCount << "0x" << std::hex << (value->vertexCount);
        contents.emplace_back("uint32_t", vertexcount_prefix, oss_vertexCount.str());
        std::string vertexbuffer_prefix = prefix;
        vertexbuffer_prefix += "vertexBuffer";
        std::ostringstream oss_vertexBuffer;
        oss_vertexBuffer << std::hex << reinterpret_cast<const void*>(value->vertexBuffer);
        contents.emplace_back("XrVector3f*", vertexbuffer_prefix, oss_vertexBuffer.str());
        std::string normalcount_prefix = prefix;
        normalcount_prefix += "normalCount";
        std::ostringstream oss_normalCount;
        oss_normalCount << "0x" << std::hex << (value->normalCount);
        contents.emplace_back("uint32_t", normalcount_prefix, oss_normalCount.str());
        std::string normalbuffer_prefix = prefix;
        normalbuffer_prefix += "normalBuffer";
        std::ostringstream oss_normalBuffer;
        oss_normalBuffer << std::hex << reinterpret_cast<const void*>(value->normalBuffer);
        contents.emplace_back("XrVector3f*", normalbuffer_prefix, oss_normalBuffer.str());
        std::string confidencecount_prefix = prefix;
        confidencecount_prefix += "confidenceCount";
        std::ostringstream oss_confidenceCount;
        oss_confidenceCount << "0x" << std::hex << (value->confidenceCount);
        contents.emplace_back("uint32_t", confidencecount_prefix, oss_confidenceCount.str());
        std::string confidencebuffer_prefix = prefix;
        confidencebuffer_prefix += "confidenceBuffer";
        std::ostringstream oss_confidenceBuffer;
        oss_confidenceBuffer << std::setprecision(32) << (value->confidenceBuffer);
        contents.emplace_back("float*", confidencebuffer_prefix, oss_confidenceBuffer.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrWorldMeshRequestCompletionInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string meshspace_prefix = prefix;
        meshspace_prefix += "meshSpace";
        std::ostringstream oss_meshSpace;
        oss_meshSpace << std::hex << reinterpret_cast<const void*>(value->meshSpace);
        contents.emplace_back("XrSpace", meshspace_prefix, oss_meshSpace.str());
        std::string meshspacelocatetime_prefix = prefix;
        meshspacelocatetime_prefix += "meshSpaceLocateTime";
        contents.emplace_back("XrTime", meshspacelocatetime_prefix, std::to_string(value->meshSpaceLocateTime));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrWorldMeshRequestCompletionML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string futureresult_prefix = prefix;
        futureresult_prefix += "futureResult";
        if (nullptr != gen_dispatch_table) {
            char futureResult_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->futureResult, futureResult_string);
            contents.emplace_back("XrResult", futureresult_prefix, futureResult_string);
        } else {
                        contents.emplace_back("XrResult", futureresult_prefix, std::to_string(value->futureResult));
        }
        std::string blockcount_prefix = prefix;
        blockcount_prefix += "blockCount";
        std::ostringstream oss_blockCount;
        oss_blockCount << "0x" << std::hex << (value->blockCount);
        contents.emplace_back("uint32_t", blockcount_prefix, oss_blockCount.str());
        std::string blocks_prefix = prefix;
        blocks_prefix += "blocks";
        std::ostringstream oss_blocks;
        oss_blocks << std::hex << reinterpret_cast<const void*>(value->blocks);
        contents.emplace_back("XrWorldMeshBlockML*", blocks_prefix, oss_blocks.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemFacialExpressionPropertiesML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsfacialexpression_prefix = prefix;
        supportsfacialexpression_prefix += "supportsFacialExpression";
        std::ostringstream oss_supportsFacialExpression;
        oss_supportsFacialExpression << "0x" << std::hex << (value->supportsFacialExpression);
        contents.emplace_back("XrBool32", supportsfacialexpression_prefix, oss_supportsFacialExpression.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFacialExpressionClientCreateInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestedcount_prefix = prefix;
        requestedcount_prefix += "requestedCount";
        std::ostringstream oss_requestedCount;
        oss_requestedCount << "0x" << std::hex << (value->requestedCount);
        contents.emplace_back("uint32_t", requestedcount_prefix, oss_requestedCount.str());
        std::string requestedfacialblendshapes_prefix = prefix;
        requestedfacialblendshapes_prefix += "requestedFacialBlendShapes";
        std::ostringstream oss_requestedFacialBlendShapes_array;
        oss_requestedFacialBlendShapes_array << std::hex << reinterpret_cast<const void*>(value->requestedFacialBlendShapes);
        contents.emplace_back("const XrFacialBlendShapeML*", requestedfacialblendshapes_prefix, oss_requestedFacialBlendShapes_array.str());
        for (uint32_t value_requestedfacialblendshapes_inc = 0; value_requestedfacialblendshapes_inc < value->requestedCount; ++value_requestedfacialblendshapes_inc) {
            std::string requestedfacialblendshapes_array_prefix = requestedfacialblendshapes_prefix;
            requestedfacialblendshapes_array_prefix += "[";
            requestedfacialblendshapes_array_prefix += std::to_string(value_requestedfacialblendshapes_inc);
            requestedfacialblendshapes_array_prefix += "]";
            contents.emplace_back("const XrFacialBlendShapeML*", requestedfacialblendshapes_array_prefix, std::to_string(value->requestedFacialBlendShapes[value_requestedfacialblendshapes_inc]));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFacialExpressionBlendShapeGetInfoML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrFacialExpressionBlendShapePropertiesML* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestedfacialblendshape_prefix = prefix;
        requestedfacialblendshape_prefix += "requestedFacialBlendShape";
        contents.emplace_back("XrFacialBlendShapeML", requestedfacialblendshape_prefix, std::to_string(value->requestedFacialBlendShape));
        std::string weight_prefix = prefix;
        weight_prefix += "weight";
        std::ostringstream oss_weight;
        oss_weight << std::setprecision(32) << (value->weight);
        contents.emplace_back("float", weight_prefix, oss_weight.str());
        std::string flags_prefix = prefix;
        flags_prefix += "flags";
        contents.emplace_back("XrFacialExpressionBlendShapePropertiesFlagsML", flags_prefix, std::to_string(value->flags));
        std::string time_prefix = prefix;
        time_prefix += "time";
        contents.emplace_back("XrTime", time_prefix, std::to_string(value->time));
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrColocationDiscoveryStartInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrColocationDiscoveryStopInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrColocationAdvertisementStartInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string buffersize_prefix = prefix;
        buffersize_prefix += "bufferSize";
        std::ostringstream oss_bufferSize;
        oss_bufferSize << "0x" << std::hex << (value->bufferSize);
        contents.emplace_back("uint32_t", buffersize_prefix, oss_bufferSize.str());
        std::string buffer_prefix = prefix;
        buffer_prefix += "buffer";
        std::ostringstream oss_buffer;
        oss_buffer << "0x" << std::hex << (value->buffer);
        contents.emplace_back("uint8_t*", buffer_prefix, oss_buffer.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrColocationAdvertisementStopInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataStartColocationAdvertisementCompleteMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string advertisementrequestid_prefix = prefix;
        advertisementrequestid_prefix += "advertisementRequestId";
        contents.emplace_back("XrAsyncRequestIdFB", advertisementrequestid_prefix, std::to_string(value->advertisementRequestId));
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        std::string advertisementuuid_prefix = prefix;
        advertisementuuid_prefix += "advertisementUuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->advertisementUuid, advertisementuuid_prefix, "XrUuid", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataStopColocationAdvertisementCompleteMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestid_prefix = prefix;
        requestid_prefix += "requestId";
        contents.emplace_back("XrAsyncRequestIdFB", requestid_prefix, std::to_string(value->requestId));
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataColocationAdvertisementCompleteMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string advertisementrequestid_prefix = prefix;
        advertisementrequestid_prefix += "advertisementRequestId";
        contents.emplace_back("XrAsyncRequestIdFB", advertisementrequestid_prefix, std::to_string(value->advertisementRequestId));
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataStartColocationDiscoveryCompleteMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string discoveryrequestid_prefix = prefix;
        discoveryrequestid_prefix += "discoveryRequestId";
        contents.emplace_back("XrAsyncRequestIdFB", discoveryrequestid_prefix, std::to_string(value->discoveryRequestId));
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataColocationDiscoveryResultMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string discoveryrequestid_prefix = prefix;
        discoveryrequestid_prefix += "discoveryRequestId";
        contents.emplace_back("XrAsyncRequestIdFB", discoveryrequestid_prefix, std::to_string(value->discoveryRequestId));
        std::string advertisementuuid_prefix = prefix;
        advertisementuuid_prefix += "advertisementUuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->advertisementUuid, advertisementuuid_prefix, "XrUuid", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string buffersize_prefix = prefix;
        buffersize_prefix += "bufferSize";
        std::ostringstream oss_bufferSize;
        oss_bufferSize << "0x" << std::hex << (value->bufferSize);
        contents.emplace_back("uint32_t", buffersize_prefix, oss_bufferSize.str());
        std::string buffer_prefix = prefix;
        buffer_prefix += "buffer";
        std::ostringstream oss_buffer_array;
        oss_buffer_array << "0x" << std::hex << (value->buffer);
        contents.emplace_back("uint8_t*", buffer_prefix, oss_buffer_array.str());
        for (uint32_t value_buffer_inc = 0; value_buffer_inc < XR_MAX_COLOCATION_DISCOVERY_BUFFER_SIZE_META; ++value_buffer_inc) {
            std::string buffer_array_prefix = buffer_prefix;
            buffer_array_prefix += "[";
            buffer_array_prefix += std::to_string(value_buffer_inc);
            buffer_array_prefix += "]";
            std::ostringstream oss_buffer;
            oss_buffer << "0x" << std::hex << (value->buffer[value_buffer_inc]);
            contents.emplace_back("uint8_t", buffer_array_prefix, oss_buffer.str());
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataColocationDiscoveryCompleteMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string discoveryrequestid_prefix = prefix;
        discoveryrequestid_prefix += "discoveryRequestId";
        contents.emplace_back("XrAsyncRequestIdFB", discoveryrequestid_prefix, std::to_string(value->discoveryRequestId));
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrEventDataStopColocationDiscoveryCompleteMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string requestid_prefix = prefix;
        requestid_prefix += "requestId";
        contents.emplace_back("XrAsyncRequestIdFB", requestid_prefix, std::to_string(value->requestId));
        std::string result_prefix = prefix;
        result_prefix += "result";
        if (nullptr != gen_dispatch_table) {
            char result_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value->result, result_string);
            contents.emplace_back("XrResult", result_prefix, result_string);
        } else {
                        contents.emplace_back("XrResult", result_prefix, std::to_string(value->result));
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemColocationDiscoveryPropertiesMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportscolocationdiscovery_prefix = prefix;
        supportscolocationdiscovery_prefix += "supportsColocationDiscovery";
        std::ostringstream oss_supportsColocationDiscovery;
        oss_supportsColocationDiscovery << "0x" << std::hex << (value->supportsColocationDiscovery);
        contents.emplace_back("XrBool32", supportscolocationdiscovery_prefix, oss_supportsColocationDiscovery.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSystemSpatialEntityGroupSharingPropertiesMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string supportsspatialentitygroupsharing_prefix = prefix;
        supportsspatialentitygroupsharing_prefix += "supportsSpatialEntityGroupSharing";
        std::ostringstream oss_supportsSpatialEntityGroupSharing;
        oss_supportsSpatialEntityGroupSharing << "0x" << std::hex << (value->supportsSpatialEntityGroupSharing);
        contents.emplace_back("XrBool32", supportsspatialentitygroupsharing_prefix, oss_supportsSpatialEntityGroupSharing.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrShareSpacesRecipientGroupsMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string groupcount_prefix = prefix;
        groupcount_prefix += "groupCount";
        std::ostringstream oss_groupCount;
        oss_groupCount << "0x" << std::hex << (value->groupCount);
        contents.emplace_back("uint32_t", groupcount_prefix, oss_groupCount.str());
        std::string groups_prefix = prefix;
        groups_prefix += "groups";
        std::ostringstream oss_groups;
        oss_groups << std::hex << reinterpret_cast<const void*>(value->groups);
        contents.emplace_back("XrUuid*", groups_prefix, oss_groups.str());
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpOutputXrStruct(XrGeneratedDispatchTable* gen_dispatch_table, const XrSpaceGroupUuidFilterInfoMETA* value,
                           std::string prefix, std::string type_string, bool is_pointer,
                           std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back(type_string, prefix, PointerToHexString(value));
        if (is_pointer) {
            prefix += "->";
        } else {
            prefix += ".";
        }
        std::string type_prefix = prefix;
        type_prefix += "type";
        if (nullptr != gen_dispatch_table) {
            char type_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value->type, type_string);
            contents.emplace_back("XrStructureType", type_prefix, type_string);
        } else {
                        contents.emplace_back("XrStructureType", type_prefix, std::to_string(value->type));
        }
        std::string next_prefix = prefix;
        next_prefix += "next";
        // Decode the next chain if it exists
        if (!ApiDumpDecodeNextChain(gen_dispatch_table, value->next, next_prefix, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::string groupuuid_prefix = prefix;
        groupuuid_prefix += "groupUuid";
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &value->groupUuid, groupuuid_prefix, "XrUuid", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        return true;
    } catch(...) {
    }
    return false;
}

bool ApiDumpDecodeNextChain(XrGeneratedDispatchTable* gen_dispatch_table, const void* value, std::string prefix,
                            std::vector<std::tuple<std::string, std::string, std::string>> &contents) {
    (void)gen_dispatch_table;  // silence warning
    try {
        contents.emplace_back("const void *", prefix, PointerToHexString(value));
        if (nullptr == value) {
            return true;
        }
        const XrBaseInStructure* next_header = reinterpret_cast<const XrBaseInStructure*>(value);
        switch (next_header->type) {
            case XR_TYPE_API_LAYER_PROPERTIES:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrApiLayerProperties*>(value), prefix, "const XrApiLayerProperties*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EXTENSION_PROPERTIES:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrExtensionProperties*>(value), prefix, "const XrExtensionProperties*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_INSTANCE_CREATE_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrInstanceCreateInfo*>(value), prefix, "const XrInstanceCreateInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_GET_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemGetInfo*>(value), prefix, "const XrSystemGetInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_PROPERTIES:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemProperties*>(value), prefix, "const XrSystemProperties*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIEW_LOCATE_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrViewLocateInfo*>(value), prefix, "const XrViewLocateInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIEW:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrView*>(value), prefix, "const XrView*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SESSION_CREATE_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSessionCreateInfo*>(value), prefix, "const XrSessionCreateInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SWAPCHAIN_CREATE_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainCreateInfo*>(value), prefix, "const XrSwapchainCreateInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SESSION_BEGIN_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSessionBeginInfo*>(value), prefix, "const XrSessionBeginInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIEW_STATE:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrViewState*>(value), prefix, "const XrViewState*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FRAME_END_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFrameEndInfo*>(value), prefix, "const XrFrameEndInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAPTIC_VIBRATION:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHapticVibration*>(value), prefix, "const XrHapticVibration*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_BUFFER:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataBuffer*>(value), prefix, "const XrEventDataBuffer*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_INSTANCE_LOSS_PENDING:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataInstanceLossPending*>(value), prefix, "const XrEventDataInstanceLossPending*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataSessionStateChanged*>(value), prefix, "const XrEventDataSessionStateChanged*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ACTION_STATE_BOOLEAN:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrActionStateBoolean*>(value), prefix, "const XrActionStateBoolean*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ACTION_STATE_FLOAT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrActionStateFloat*>(value), prefix, "const XrActionStateFloat*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ACTION_STATE_VECTOR2F:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrActionStateVector2f*>(value), prefix, "const XrActionStateVector2f*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ACTION_STATE_POSE:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrActionStatePose*>(value), prefix, "const XrActionStatePose*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ACTION_SET_CREATE_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrActionSetCreateInfo*>(value), prefix, "const XrActionSetCreateInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ACTION_CREATE_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrActionCreateInfo*>(value), prefix, "const XrActionCreateInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_INSTANCE_PROPERTIES:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrInstanceProperties*>(value), prefix, "const XrInstanceProperties*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FRAME_WAIT_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFrameWaitInfo*>(value), prefix, "const XrFrameWaitInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_PROJECTION:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerProjection*>(value), prefix, "const XrCompositionLayerProjection*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_QUAD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerQuad*>(value), prefix, "const XrCompositionLayerQuad*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_REFERENCE_SPACE_CREATE_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrReferenceSpaceCreateInfo*>(value), prefix, "const XrReferenceSpaceCreateInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ACTION_SPACE_CREATE_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrActionSpaceCreateInfo*>(value), prefix, "const XrActionSpaceCreateInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataReferenceSpaceChangePending*>(value), prefix, "const XrEventDataReferenceSpaceChangePending*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIEW_CONFIGURATION_VIEW:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrViewConfigurationView*>(value), prefix, "const XrViewConfigurationView*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_LOCATION:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceLocation*>(value), prefix, "const XrSpaceLocation*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_VELOCITY:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceVelocity*>(value), prefix, "const XrSpaceVelocity*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FRAME_STATE:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFrameState*>(value), prefix, "const XrFrameState*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIEW_CONFIGURATION_PROPERTIES:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrViewConfigurationProperties*>(value), prefix, "const XrViewConfigurationProperties*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FRAME_BEGIN_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFrameBeginInfo*>(value), prefix, "const XrFrameBeginInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerProjectionView*>(value), prefix, "const XrCompositionLayerProjectionView*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_EVENTS_LOST:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataEventsLost*>(value), prefix, "const XrEventDataEventsLost*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_INTERACTION_PROFILE_SUGGESTED_BINDING:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrInteractionProfileSuggestedBinding*>(value), prefix, "const XrInteractionProfileSuggestedBinding*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataInteractionProfileChanged*>(value), prefix, "const XrEventDataInteractionProfileChanged*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_INTERACTION_PROFILE_STATE:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrInteractionProfileState*>(value), prefix, "const XrInteractionProfileState*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainImageAcquireInfo*>(value), prefix, "const XrSwapchainImageAcquireInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainImageWaitInfo*>(value), prefix, "const XrSwapchainImageWaitInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainImageReleaseInfo*>(value), prefix, "const XrSwapchainImageReleaseInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ACTION_STATE_GET_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrActionStateGetInfo*>(value), prefix, "const XrActionStateGetInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAPTIC_ACTION_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHapticActionInfo*>(value), prefix, "const XrHapticActionInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSessionActionSetsAttachInfo*>(value), prefix, "const XrSessionActionSetsAttachInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ACTIONS_SYNC_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrActionsSyncInfo*>(value), prefix, "const XrActionsSyncInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_BOUND_SOURCES_FOR_ACTION_ENUMERATE_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrBoundSourcesForActionEnumerateInfo*>(value), prefix, "const XrBoundSourcesForActionEnumerateInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_INPUT_SOURCE_LOCALIZED_NAME_GET_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrInputSourceLocalizedNameGetInfo*>(value), prefix, "const XrInputSourceLocalizedNameGetInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACES_LOCATE_INFO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpacesLocateInfo*>(value), prefix, "const XrSpacesLocateInfo*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_LOCATIONS:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceLocations*>(value), prefix, "const XrSpaceLocations*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_VELOCITIES:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceVelocities*>(value), prefix, "const XrSpaceVelocities*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_CUBE_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerCubeKHR*>(value), prefix, "const XrCompositionLayerCubeKHR*", true, contents)) {
                    return false;
                }
                return true;
#if defined(XR_USE_PLATFORM_ANDROID)
            case XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrInstanceCreateInfoAndroidKHR*>(value), prefix, "const XrInstanceCreateInfoAndroidKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_PLATFORM_ANDROID)
            case XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerDepthInfoKHR*>(value), prefix, "const XrCompositionLayerDepthInfoKHR*", true, contents)) {
                    return false;
                }
                return true;
#if defined(XR_USE_GRAPHICS_API_VULKAN)
            case XR_TYPE_VULKAN_SWAPCHAIN_FORMAT_LIST_CREATE_INFO_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVulkanSwapchainFormatListCreateInfoKHR*>(value), prefix, "const XrVulkanSwapchainFormatListCreateInfoKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
            case XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataPerfSettingsEXT*>(value), prefix, "const XrEventDataPerfSettingsEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerCylinderKHR*>(value), prefix, "const XrCompositionLayerCylinderKHR*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerEquirectKHR*>(value), prefix, "const XrCompositionLayerEquirectKHR*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrDebugUtilsObjectNameInfoEXT*>(value), prefix, "const XrDebugUtilsObjectNameInfoEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrDebugUtilsMessengerCallbackDataEXT*>(value), prefix, "const XrDebugUtilsMessengerCallbackDataEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrDebugUtilsMessengerCreateInfoEXT*>(value), prefix, "const XrDebugUtilsMessengerCreateInfoEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_DEBUG_UTILS_LABEL_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrDebugUtilsLabelEXT*>(value), prefix, "const XrDebugUtilsLabelEXT*", true, contents)) {
                    return false;
                }
                return true;
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
            case XR_TYPE_GRAPHICS_BINDING_OPENGL_WIN32_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsBindingOpenGLWin32KHR*>(value), prefix, "const XrGraphicsBindingOpenGLWin32KHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
            case XR_TYPE_GRAPHICS_BINDING_OPENGL_XLIB_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsBindingOpenGLXlibKHR*>(value), prefix, "const XrGraphicsBindingOpenGLXlibKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
            case XR_TYPE_GRAPHICS_BINDING_OPENGL_XCB_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsBindingOpenGLXcbKHR*>(value), prefix, "const XrGraphicsBindingOpenGLXcbKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
            case XR_TYPE_GRAPHICS_BINDING_OPENGL_WAYLAND_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsBindingOpenGLWaylandKHR*>(value), prefix, "const XrGraphicsBindingOpenGLWaylandKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
#if defined(XR_USE_GRAPHICS_API_OPENGL)
            case XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainImageOpenGLKHR*>(value), prefix, "const XrSwapchainImageOpenGLKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL)
#if defined(XR_USE_GRAPHICS_API_OPENGL)
            case XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsRequirementsOpenGLKHR*>(value), prefix, "const XrGraphicsRequirementsOpenGLKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
            case XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsBindingOpenGLESAndroidKHR*>(value), prefix, "const XrGraphicsBindingOpenGLESAndroidKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
            case XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainImageOpenGLESKHR*>(value), prefix, "const XrSwapchainImageOpenGLESKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
            case XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_ES_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsRequirementsOpenGLESKHR*>(value), prefix, "const XrGraphicsRequirementsOpenGLESKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
            case XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsBindingVulkanKHR*>(value), prefix, "const XrGraphicsBindingVulkanKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
            case XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainImageVulkanKHR*>(value), prefix, "const XrSwapchainImageVulkanKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
            case XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsRequirementsVulkanKHR*>(value), prefix, "const XrGraphicsRequirementsVulkanKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_D3D11)
            case XR_TYPE_GRAPHICS_BINDING_D3D11_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsBindingD3D11KHR*>(value), prefix, "const XrGraphicsBindingD3D11KHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#if defined(XR_USE_GRAPHICS_API_D3D11)
            case XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainImageD3D11KHR*>(value), prefix, "const XrSwapchainImageD3D11KHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#if defined(XR_USE_GRAPHICS_API_D3D11)
            case XR_TYPE_GRAPHICS_REQUIREMENTS_D3D11_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsRequirementsD3D11KHR*>(value), prefix, "const XrGraphicsRequirementsD3D11KHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#if defined(XR_USE_GRAPHICS_API_D3D12)
            case XR_TYPE_GRAPHICS_BINDING_D3D12_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsBindingD3D12KHR*>(value), prefix, "const XrGraphicsBindingD3D12KHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_D3D12)
#if defined(XR_USE_GRAPHICS_API_D3D12)
            case XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainImageD3D12KHR*>(value), prefix, "const XrSwapchainImageD3D12KHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_D3D12)
#if defined(XR_USE_GRAPHICS_API_D3D12)
            case XR_TYPE_GRAPHICS_REQUIREMENTS_D3D12_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsRequirementsD3D12KHR*>(value), prefix, "const XrGraphicsRequirementsD3D12KHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_D3D12)
#if defined(XR_USE_GRAPHICS_API_METAL)
            case XR_TYPE_GRAPHICS_BINDING_METAL_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsBindingMetalKHR*>(value), prefix, "const XrGraphicsBindingMetalKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_METAL)
#if defined(XR_USE_GRAPHICS_API_METAL)
            case XR_TYPE_SWAPCHAIN_IMAGE_METAL_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainImageMetalKHR*>(value), prefix, "const XrSwapchainImageMetalKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_METAL)
#if defined(XR_USE_GRAPHICS_API_METAL)
            case XR_TYPE_GRAPHICS_REQUIREMENTS_METAL_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsRequirementsMetalKHR*>(value), prefix, "const XrGraphicsRequirementsMetalKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_METAL)
            case XR_TYPE_SYSTEM_EYE_GAZE_INTERACTION_PROPERTIES_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemEyeGazeInteractionPropertiesEXT*>(value), prefix, "const XrSystemEyeGazeInteractionPropertiesEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEyeGazeSampleTimeEXT*>(value), prefix, "const XrEyeGazeSampleTimeEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VISIBILITY_MASK_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVisibilityMaskKHR*>(value), prefix, "const XrVisibilityMaskKHR*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataVisibilityMaskChangedKHR*>(value), prefix, "const XrEventDataVisibilityMaskChangedKHR*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSessionCreateInfoOverlayEXTX*>(value), prefix, "const XrSessionCreateInfoOverlayEXTX*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataMainSessionVisibilityChangedEXTX*>(value), prefix, "const XrEventDataMainSessionVisibilityChangedEXTX*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_COLOR_SCALE_BIAS_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerColorScaleBiasKHR*>(value), prefix, "const XrCompositionLayerColorScaleBiasKHR*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorCreateInfoMSFT*>(value), prefix, "const XrSpatialAnchorCreateInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHOR_SPACE_CREATE_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorSpaceCreateInfoMSFT*>(value), prefix, "const XrSpatialAnchorSpaceCreateInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_IMAGE_LAYOUT_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerImageLayoutFB*>(value), prefix, "const XrCompositionLayerImageLayoutFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_ALPHA_BLEND_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerAlphaBlendFB*>(value), prefix, "const XrCompositionLayerAlphaBlendFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIEW_CONFIGURATION_DEPTH_RANGE_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrViewConfigurationDepthRangeEXT*>(value), prefix, "const XrViewConfigurationDepthRangeEXT*", true, contents)) {
                    return false;
                }
                return true;
#if defined(XR_USE_PLATFORM_EGL)
            case XR_TYPE_GRAPHICS_BINDING_EGL_MNDX:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGraphicsBindingEGLMNDX*>(value), prefix, "const XrGraphicsBindingEGLMNDX*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_PLATFORM_EGL)
            case XR_TYPE_SPATIAL_GRAPH_NODE_SPACE_CREATE_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialGraphNodeSpaceCreateInfoMSFT*>(value), prefix, "const XrSpatialGraphNodeSpaceCreateInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_GRAPH_STATIC_NODE_BINDING_CREATE_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialGraphStaticNodeBindingCreateInfoMSFT*>(value), prefix, "const XrSpatialGraphStaticNodeBindingCreateInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_GET_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT*>(value), prefix, "const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialGraphNodeBindingPropertiesMSFT*>(value), prefix, "const XrSpatialGraphNodeBindingPropertiesMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_HAND_TRACKING_PROPERTIES_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemHandTrackingPropertiesEXT*>(value), prefix, "const XrSystemHandTrackingPropertiesEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAND_TRACKER_CREATE_INFO_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHandTrackerCreateInfoEXT*>(value), prefix, "const XrHandTrackerCreateInfoEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAND_JOINTS_LOCATE_INFO_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHandJointsLocateInfoEXT*>(value), prefix, "const XrHandJointsLocateInfoEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAND_JOINT_LOCATIONS_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHandJointLocationsEXT*>(value), prefix, "const XrHandJointLocationsEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAND_JOINT_VELOCITIES_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHandJointVelocitiesEXT*>(value), prefix, "const XrHandJointVelocitiesEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_HAND_TRACKING_MESH_PROPERTIES_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemHandTrackingMeshPropertiesMSFT*>(value), prefix, "const XrSystemHandTrackingMeshPropertiesMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAND_MESH_SPACE_CREATE_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHandMeshSpaceCreateInfoMSFT*>(value), prefix, "const XrHandMeshSpaceCreateInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAND_MESH_UPDATE_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHandMeshUpdateInfoMSFT*>(value), prefix, "const XrHandMeshUpdateInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAND_MESH_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHandMeshMSFT*>(value), prefix, "const XrHandMeshMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAND_POSE_TYPE_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHandPoseTypeInfoMSFT*>(value), prefix, "const XrHandPoseTypeInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SESSION_BEGIN_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSecondaryViewConfigurationSessionBeginInfoMSFT*>(value), prefix, "const XrSecondaryViewConfigurationSessionBeginInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_STATE_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSecondaryViewConfigurationStateMSFT*>(value), prefix, "const XrSecondaryViewConfigurationStateMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSecondaryViewConfigurationFrameStateMSFT*>(value), prefix, "const XrSecondaryViewConfigurationFrameStateMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_END_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSecondaryViewConfigurationFrameEndInfoMSFT*>(value), prefix, "const XrSecondaryViewConfigurationFrameEndInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_LAYER_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSecondaryViewConfigurationLayerInfoMSFT*>(value), prefix, "const XrSecondaryViewConfigurationLayerInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SWAPCHAIN_CREATE_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT*>(value), prefix, "const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_CONTROLLER_MODEL_KEY_STATE_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrControllerModelKeyStateMSFT*>(value), prefix, "const XrControllerModelKeyStateMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_CONTROLLER_MODEL_NODE_PROPERTIES_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrControllerModelNodePropertiesMSFT*>(value), prefix, "const XrControllerModelNodePropertiesMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_CONTROLLER_MODEL_PROPERTIES_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrControllerModelPropertiesMSFT*>(value), prefix, "const XrControllerModelPropertiesMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_CONTROLLER_MODEL_NODE_STATE_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrControllerModelNodeStateMSFT*>(value), prefix, "const XrControllerModelNodeStateMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_CONTROLLER_MODEL_STATE_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrControllerModelStateMSFT*>(value), prefix, "const XrControllerModelStateMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIEW_CONFIGURATION_VIEW_FOV_EPIC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrViewConfigurationViewFovEPIC*>(value), prefix, "const XrViewConfigurationViewFovEPIC*", true, contents)) {
                    return false;
                }
                return true;
#if defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)
            case XR_TYPE_HOLOGRAPHIC_WINDOW_ATTACHMENT_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHolographicWindowAttachmentMSFT*>(value), prefix, "const XrHolographicWindowAttachmentMSFT*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)
            case XR_TYPE_COMPOSITION_LAYER_REPROJECTION_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerReprojectionInfoMSFT*>(value), prefix, "const XrCompositionLayerReprojectionInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_REPROJECTION_PLANE_OVERRIDE_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerReprojectionPlaneOverrideMSFT*>(value), prefix, "const XrCompositionLayerReprojectionPlaneOverrideMSFT*", true, contents)) {
                    return false;
                }
                return true;
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
            case XR_TYPE_ANDROID_SURFACE_SWAPCHAIN_CREATE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrAndroidSurfaceSwapchainCreateInfoFB*>(value), prefix, "const XrAndroidSurfaceSwapchainCreateInfoFB*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
            case XR_TYPE_COMPOSITION_LAYER_SECURE_CONTENT_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerSecureContentFB*>(value), prefix, "const XrCompositionLayerSecureContentFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_BODY_TRACKER_CREATE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrBodyTrackerCreateInfoFB*>(value), prefix, "const XrBodyTrackerCreateInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_BODY_JOINTS_LOCATE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrBodyJointsLocateInfoFB*>(value), prefix, "const XrBodyJointsLocateInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemBodyTrackingPropertiesFB*>(value), prefix, "const XrSystemBodyTrackingPropertiesFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_BODY_JOINT_LOCATIONS_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrBodyJointLocationsFB*>(value), prefix, "const XrBodyJointLocationsFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_BODY_SKELETON_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrBodySkeletonFB*>(value), prefix, "const XrBodySkeletonFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrInteractionProfileDpadBindingEXT*>(value), prefix, "const XrInteractionProfileDpadBindingEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrInteractionProfileAnalogThresholdVALVE*>(value), prefix, "const XrInteractionProfileAnalogThresholdVALVE*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAND_JOINTS_MOTION_RANGE_INFO_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHandJointsMotionRangeInfoEXT*>(value), prefix, "const XrHandJointsMotionRangeInfoEXT*", true, contents)) {
                    return false;
                }
                return true;
#if defined(XR_USE_PLATFORM_ANDROID)
            case XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrLoaderInitInfoAndroidKHR*>(value), prefix, "const XrLoaderInitInfoAndroidKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
            case XR_TYPE_VULKAN_INSTANCE_CREATE_INFO_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVulkanInstanceCreateInfoKHR*>(value), prefix, "const XrVulkanInstanceCreateInfoKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
            case XR_TYPE_VULKAN_DEVICE_CREATE_INFO_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVulkanDeviceCreateInfoKHR*>(value), prefix, "const XrVulkanDeviceCreateInfoKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
            case XR_TYPE_VULKAN_GRAPHICS_DEVICE_GET_INFO_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVulkanGraphicsDeviceGetInfoKHR*>(value), prefix, "const XrVulkanGraphicsDeviceGetInfoKHR*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
            case XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerEquirect2KHR*>(value), prefix, "const XrCompositionLayerEquirect2KHR*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_OBSERVER_CREATE_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneObserverCreateInfoMSFT*>(value), prefix, "const XrSceneObserverCreateInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_CREATE_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneCreateInfoMSFT*>(value), prefix, "const XrSceneCreateInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_NEW_SCENE_COMPUTE_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrNewSceneComputeInfoMSFT*>(value), prefix, "const XrNewSceneComputeInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VISUAL_MESH_COMPUTE_LOD_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVisualMeshComputeLodInfoMSFT*>(value), prefix, "const XrVisualMeshComputeLodInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_COMPONENTS_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneComponentsMSFT*>(value), prefix, "const XrSceneComponentsMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_COMPONENTS_GET_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneComponentsGetInfoMSFT*>(value), prefix, "const XrSceneComponentsGetInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_COMPONENT_LOCATIONS_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneComponentLocationsMSFT*>(value), prefix, "const XrSceneComponentLocationsMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_COMPONENTS_LOCATE_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneComponentsLocateInfoMSFT*>(value), prefix, "const XrSceneComponentsLocateInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_OBJECTS_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneObjectsMSFT*>(value), prefix, "const XrSceneObjectsMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_COMPONENT_PARENT_FILTER_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneComponentParentFilterInfoMSFT*>(value), prefix, "const XrSceneComponentParentFilterInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_OBJECT_TYPES_FILTER_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneObjectTypesFilterInfoMSFT*>(value), prefix, "const XrSceneObjectTypesFilterInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_PLANES_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrScenePlanesMSFT*>(value), prefix, "const XrScenePlanesMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_PLANE_ALIGNMENT_FILTER_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrScenePlaneAlignmentFilterInfoMSFT*>(value), prefix, "const XrScenePlaneAlignmentFilterInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_MESHES_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneMeshesMSFT*>(value), prefix, "const XrSceneMeshesMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_MESH_BUFFERS_GET_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneMeshBuffersGetInfoMSFT*>(value), prefix, "const XrSceneMeshBuffersGetInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_MESH_BUFFERS_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneMeshBuffersMSFT*>(value), prefix, "const XrSceneMeshBuffersMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_MESH_VERTEX_BUFFER_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneMeshVertexBufferMSFT*>(value), prefix, "const XrSceneMeshVertexBufferMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_MESH_INDICES_UINT32_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneMeshIndicesUint32MSFT*>(value), prefix, "const XrSceneMeshIndicesUint32MSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_MESH_INDICES_UINT16_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneMeshIndicesUint16MSFT*>(value), prefix, "const XrSceneMeshIndicesUint16MSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SERIALIZED_SCENE_FRAGMENT_DATA_GET_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSerializedSceneFragmentDataGetInfoMSFT*>(value), prefix, "const XrSerializedSceneFragmentDataGetInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_DESERIALIZE_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneDeserializeInfoMSFT*>(value), prefix, "const XrSceneDeserializeInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataDisplayRefreshRateChangedFB*>(value), prefix, "const XrEventDataDisplayRefreshRateChangedFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIVE_TRACKER_PATHS_HTCX:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrViveTrackerPathsHTCX*>(value), prefix, "const XrViveTrackerPathsHTCX*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataViveTrackerConnectedHTCX*>(value), prefix, "const XrEventDataViveTrackerConnectedHTCX*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_FACIAL_TRACKING_PROPERTIES_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemFacialTrackingPropertiesHTC*>(value), prefix, "const XrSystemFacialTrackingPropertiesHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FACIAL_TRACKER_CREATE_INFO_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFacialTrackerCreateInfoHTC*>(value), prefix, "const XrFacialTrackerCreateInfoHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FACIAL_EXPRESSIONS_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFacialExpressionsHTC*>(value), prefix, "const XrFacialExpressionsHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_COLOR_SPACE_PROPERTIES_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemColorSpacePropertiesFB*>(value), prefix, "const XrSystemColorSpacePropertiesFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAND_TRACKING_MESH_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHandTrackingMeshFB*>(value), prefix, "const XrHandTrackingMeshFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAND_TRACKING_SCALE_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHandTrackingScaleFB*>(value), prefix, "const XrHandTrackingScaleFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAND_TRACKING_AIM_STATE_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHandTrackingAimStateFB*>(value), prefix, "const XrHandTrackingAimStateFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAND_TRACKING_CAPSULES_STATE_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHandTrackingCapsulesStateFB*>(value), prefix, "const XrHandTrackingCapsulesStateFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_SPATIAL_ENTITY_PROPERTIES_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemSpatialEntityPropertiesFB*>(value), prefix, "const XrSystemSpatialEntityPropertiesFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorCreateInfoFB*>(value), prefix, "const XrSpatialAnchorCreateInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_COMPONENT_STATUS_SET_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceComponentStatusSetInfoFB*>(value), prefix, "const XrSpaceComponentStatusSetInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_COMPONENT_STATUS_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceComponentStatusFB*>(value), prefix, "const XrSpaceComponentStatusFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataSpatialAnchorCreateCompleteFB*>(value), prefix, "const XrEventDataSpatialAnchorCreateCompleteFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataSpaceSetStatusCompleteFB*>(value), prefix, "const XrEventDataSpaceSetStatusCompleteFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FOVEATION_PROFILE_CREATE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFoveationProfileCreateInfoFB*>(value), prefix, "const XrFoveationProfileCreateInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SWAPCHAIN_CREATE_INFO_FOVEATION_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainCreateInfoFoveationFB*>(value), prefix, "const XrSwapchainCreateInfoFoveationFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainStateFoveationFB*>(value), prefix, "const XrSwapchainStateFoveationFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FOVEATION_LEVEL_PROFILE_CREATE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFoveationLevelProfileCreateInfoFB*>(value), prefix, "const XrFoveationLevelProfileCreateInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_KEYBOARD_SPACE_CREATE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrKeyboardSpaceCreateInfoFB*>(value), prefix, "const XrKeyboardSpaceCreateInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_KEYBOARD_TRACKING_QUERY_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrKeyboardTrackingQueryFB*>(value), prefix, "const XrKeyboardTrackingQueryFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_KEYBOARD_TRACKING_PROPERTIES_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemKeyboardTrackingPropertiesFB*>(value), prefix, "const XrSystemKeyboardTrackingPropertiesFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_TRIANGLE_MESH_CREATE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrTriangleMeshCreateInfoFB*>(value), prefix, "const XrTriangleMeshCreateInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemPassthroughPropertiesFB*>(value), prefix, "const XrSystemPassthroughPropertiesFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PASSTHROUGH_CREATE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPassthroughCreateInfoFB*>(value), prefix, "const XrPassthroughCreateInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PASSTHROUGH_LAYER_CREATE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPassthroughLayerCreateInfoFB*>(value), prefix, "const XrPassthroughLayerCreateInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerPassthroughFB*>(value), prefix, "const XrCompositionLayerPassthroughFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_GEOMETRY_INSTANCE_CREATE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGeometryInstanceCreateInfoFB*>(value), prefix, "const XrGeometryInstanceCreateInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_GEOMETRY_INSTANCE_TRANSFORM_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGeometryInstanceTransformFB*>(value), prefix, "const XrGeometryInstanceTransformFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES2_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemPassthroughProperties2FB*>(value), prefix, "const XrSystemPassthroughProperties2FB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PASSTHROUGH_STYLE_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPassthroughStyleFB*>(value), prefix, "const XrPassthroughStyleFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_RGBA_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPassthroughColorMapMonoToRgbaFB*>(value), prefix, "const XrPassthroughColorMapMonoToRgbaFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_MONO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPassthroughColorMapMonoToMonoFB*>(value), prefix, "const XrPassthroughColorMapMonoToMonoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PASSTHROUGH_BRIGHTNESS_CONTRAST_SATURATION_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPassthroughBrightnessContrastSaturationFB*>(value), prefix, "const XrPassthroughBrightnessContrastSaturationFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_PASSTHROUGH_STATE_CHANGED_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataPassthroughStateChangedFB*>(value), prefix, "const XrEventDataPassthroughStateChangedFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_RENDER_MODEL_PATH_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrRenderModelPathInfoFB*>(value), prefix, "const XrRenderModelPathInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_RENDER_MODEL_PROPERTIES_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrRenderModelPropertiesFB*>(value), prefix, "const XrRenderModelPropertiesFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_RENDER_MODEL_BUFFER_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrRenderModelBufferFB*>(value), prefix, "const XrRenderModelBufferFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_RENDER_MODEL_LOAD_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrRenderModelLoadInfoFB*>(value), prefix, "const XrRenderModelLoadInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_RENDER_MODEL_PROPERTIES_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemRenderModelPropertiesFB*>(value), prefix, "const XrSystemRenderModelPropertiesFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_RENDER_MODEL_CAPABILITIES_REQUEST_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrRenderModelCapabilitiesRequestFB*>(value), prefix, "const XrRenderModelCapabilitiesRequestFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_BINDING_MODIFICATIONS_KHR:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrBindingModificationsKHR*>(value), prefix, "const XrBindingModificationsKHR*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIEW_LOCATE_FOVEATED_RENDERING_VARJO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrViewLocateFoveatedRenderingVARJO*>(value), prefix, "const XrViewLocateFoveatedRenderingVARJO*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FOVEATED_VIEW_CONFIGURATION_VIEW_VARJO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFoveatedViewConfigurationViewVARJO*>(value), prefix, "const XrFoveatedViewConfigurationViewVARJO*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_FOVEATED_RENDERING_PROPERTIES_VARJO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemFoveatedRenderingPropertiesVARJO*>(value), prefix, "const XrSystemFoveatedRenderingPropertiesVARJO*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_VARJO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerDepthTestVARJO*>(value), prefix, "const XrCompositionLayerDepthTestVARJO*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_VARJO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemMarkerTrackingPropertiesVARJO*>(value), prefix, "const XrSystemMarkerTrackingPropertiesVARJO*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataMarkerTrackingUpdateVARJO*>(value), prefix, "const XrEventDataMarkerTrackingUpdateVARJO*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_MARKER_SPACE_CREATE_INFO_VARJO:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrMarkerSpaceCreateInfoVARJO*>(value), prefix, "const XrMarkerSpaceCreateInfoVARJO*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FRAME_END_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFrameEndInfoML*>(value), prefix, "const XrFrameEndInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_GLOBAL_DIMMER_FRAME_END_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrGlobalDimmerFrameEndInfoML*>(value), prefix, "const XrGlobalDimmerFrameEndInfoML*", true, contents)) {
                    return false;
                }
                return true;
#if defined(XR_USE_PLATFORM_ML)
            case XR_TYPE_COORDINATE_SPACE_CREATE_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCoordinateSpaceCreateInfoML*>(value), prefix, "const XrCoordinateSpaceCreateInfoML*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_PLATFORM_ML)
            case XR_TYPE_SYSTEM_MARKER_UNDERSTANDING_PROPERTIES_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemMarkerUnderstandingPropertiesML*>(value), prefix, "const XrSystemMarkerUnderstandingPropertiesML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_MARKER_DETECTOR_CREATE_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrMarkerDetectorCreateInfoML*>(value), prefix, "const XrMarkerDetectorCreateInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_MARKER_DETECTOR_ARUCO_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrMarkerDetectorArucoInfoML*>(value), prefix, "const XrMarkerDetectorArucoInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_MARKER_DETECTOR_SIZE_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrMarkerDetectorSizeInfoML*>(value), prefix, "const XrMarkerDetectorSizeInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_MARKER_DETECTOR_APRIL_TAG_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrMarkerDetectorAprilTagInfoML*>(value), prefix, "const XrMarkerDetectorAprilTagInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_MARKER_DETECTOR_CUSTOM_PROFILE_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrMarkerDetectorCustomProfileInfoML*>(value), prefix, "const XrMarkerDetectorCustomProfileInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_MARKER_DETECTOR_SNAPSHOT_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrMarkerDetectorSnapshotInfoML*>(value), prefix, "const XrMarkerDetectorSnapshotInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_MARKER_DETECTOR_STATE_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrMarkerDetectorStateML*>(value), prefix, "const XrMarkerDetectorStateML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_MARKER_SPACE_CREATE_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrMarkerSpaceCreateInfoML*>(value), prefix, "const XrMarkerSpaceCreateInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_LOCALIZATION_MAP_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrLocalizationMapML*>(value), prefix, "const XrLocalizationMapML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_LOCALIZATION_CHANGED_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataLocalizationChangedML*>(value), prefix, "const XrEventDataLocalizationChangedML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_MAP_LOCALIZATION_REQUEST_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrMapLocalizationRequestInfoML*>(value), prefix, "const XrMapLocalizationRequestInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_LOCALIZATION_MAP_IMPORT_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrLocalizationMapImportInfoML*>(value), prefix, "const XrLocalizationMapImportInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_LOCALIZATION_ENABLE_EVENTS_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrLocalizationEnableEventsInfoML*>(value), prefix, "const XrLocalizationEnableEventsInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHORS_CREATE_INFO_FROM_POSE_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorsCreateInfoFromPoseML*>(value), prefix, "const XrSpatialAnchorsCreateInfoFromPoseML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_CREATE_SPATIAL_ANCHORS_COMPLETION_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCreateSpatialAnchorsCompletionML*>(value), prefix, "const XrCreateSpatialAnchorsCompletionML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHOR_STATE_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorStateML*>(value), prefix, "const XrSpatialAnchorStateML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHORS_CREATE_STORAGE_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorsCreateStorageInfoML*>(value), prefix, "const XrSpatialAnchorsCreateStorageInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHORS_QUERY_INFO_RADIUS_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorsQueryInfoRadiusML*>(value), prefix, "const XrSpatialAnchorsQueryInfoRadiusML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHORS_QUERY_COMPLETION_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorsQueryCompletionML*>(value), prefix, "const XrSpatialAnchorsQueryCompletionML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHORS_CREATE_INFO_FROM_UUIDS_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorsCreateInfoFromUuidsML*>(value), prefix, "const XrSpatialAnchorsCreateInfoFromUuidsML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHORS_PUBLISH_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorsPublishInfoML*>(value), prefix, "const XrSpatialAnchorsPublishInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHORS_PUBLISH_COMPLETION_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorsPublishCompletionML*>(value), prefix, "const XrSpatialAnchorsPublishCompletionML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHORS_DELETE_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorsDeleteInfoML*>(value), prefix, "const XrSpatialAnchorsDeleteInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHORS_DELETE_COMPLETION_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorsDeleteCompletionML*>(value), prefix, "const XrSpatialAnchorsDeleteCompletionML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHORS_UPDATE_EXPIRATION_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorsUpdateExpirationInfoML*>(value), prefix, "const XrSpatialAnchorsUpdateExpirationInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHORS_UPDATE_EXPIRATION_COMPLETION_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorsUpdateExpirationCompletionML*>(value), prefix, "const XrSpatialAnchorsUpdateExpirationCompletionML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHORS_PUBLISH_COMPLETION_DETAILS_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorsPublishCompletionDetailsML*>(value), prefix, "const XrSpatialAnchorsPublishCompletionDetailsML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHORS_DELETE_COMPLETION_DETAILS_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorsDeleteCompletionDetailsML*>(value), prefix, "const XrSpatialAnchorsDeleteCompletionDetailsML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHORS_UPDATE_EXPIRATION_COMPLETION_DETAILS_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorsUpdateExpirationCompletionDetailsML*>(value), prefix, "const XrSpatialAnchorsUpdateExpirationCompletionDetailsML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_HEADSET_FIT_CHANGED_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataHeadsetFitChangedML*>(value), prefix, "const XrEventDataHeadsetFitChangedML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_EYE_CALIBRATION_CHANGED_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataEyeCalibrationChangedML*>(value), prefix, "const XrEventDataEyeCalibrationChangedML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_USER_CALIBRATION_ENABLE_EVENTS_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrUserCalibrationEnableEventsInfoML*>(value), prefix, "const XrUserCalibrationEnableEventsInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHOR_PERSISTENCE_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorPersistenceInfoMSFT*>(value), prefix, "const XrSpatialAnchorPersistenceInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHOR_FROM_PERSISTED_ANCHOR_CREATE_INFO_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT*>(value), prefix, "const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_MARKERS_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneMarkersMSFT*>(value), prefix, "const XrSceneMarkersMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_MARKER_TYPE_FILTER_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneMarkerTypeFilterMSFT*>(value), prefix, "const XrSceneMarkerTypeFilterMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_MARKER_QR_CODES_MSFT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneMarkerQRCodesMSFT*>(value), prefix, "const XrSceneMarkerQRCodesMSFT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_QUERY_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceQueryInfoFB*>(value), prefix, "const XrSpaceQueryInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_QUERY_RESULTS_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceQueryResultsFB*>(value), prefix, "const XrSpaceQueryResultsFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_STORAGE_LOCATION_FILTER_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceStorageLocationFilterInfoFB*>(value), prefix, "const XrSpaceStorageLocationFilterInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_UUID_FILTER_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceUuidFilterInfoFB*>(value), prefix, "const XrSpaceUuidFilterInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceComponentFilterInfoFB*>(value), prefix, "const XrSpaceComponentFilterInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataSpaceQueryResultsAvailableFB*>(value), prefix, "const XrEventDataSpaceQueryResultsAvailableFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataSpaceQueryCompleteFB*>(value), prefix, "const XrEventDataSpaceQueryCompleteFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_SAVE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceSaveInfoFB*>(value), prefix, "const XrSpaceSaveInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_ERASE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceEraseInfoFB*>(value), prefix, "const XrSpaceEraseInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataSpaceSaveCompleteFB*>(value), prefix, "const XrEventDataSpaceSaveCompleteFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataSpaceEraseCompleteFB*>(value), prefix, "const XrEventDataSpaceEraseCompleteFB*", true, contents)) {
                    return false;
                }
                return true;
#if defined(XR_USE_GRAPHICS_API_VULKAN)
            case XR_TYPE_SWAPCHAIN_IMAGE_FOVEATION_VULKAN_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainImageFoveationVulkanFB*>(value), prefix, "const XrSwapchainImageFoveationVulkanFB*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
            case XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainStateAndroidSurfaceDimensionsFB*>(value), prefix, "const XrSwapchainStateAndroidSurfaceDimensionsFB*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
            case XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainStateSamplerOpenGLESFB*>(value), prefix, "const XrSwapchainStateSamplerOpenGLESFB*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
            case XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSwapchainStateSamplerVulkanFB*>(value), prefix, "const XrSwapchainStateSamplerVulkanFB*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
            case XR_TYPE_SPACE_SHARE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceShareInfoFB*>(value), prefix, "const XrSpaceShareInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_SPACE_SHARE_COMPLETE_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataSpaceShareCompleteFB*>(value), prefix, "const XrEventDataSpaceShareCompleteFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerSpaceWarpInfoFB*>(value), prefix, "const XrCompositionLayerSpaceWarpInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_SPACE_WARP_PROPERTIES_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemSpaceWarpPropertiesFB*>(value), prefix, "const XrSystemSpaceWarpPropertiesFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHapticAmplitudeEnvelopeVibrationFB*>(value), prefix, "const XrHapticAmplitudeEnvelopeVibrationFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SEMANTIC_LABELS_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSemanticLabelsFB*>(value), prefix, "const XrSemanticLabelsFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ROOM_LAYOUT_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrRoomLayoutFB*>(value), prefix, "const XrRoomLayoutFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_BOUNDARY_2D_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrBoundary2DFB*>(value), prefix, "const XrBoundary2DFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SEMANTIC_LABELS_SUPPORT_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSemanticLabelsSupportInfoFB*>(value), prefix, "const XrSemanticLabelsSupportInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_DIGITAL_LENS_CONTROL_ALMALENCE:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrDigitalLensControlALMALENCE*>(value), prefix, "const XrDigitalLensControlALMALENCE*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_SCENE_CAPTURE_COMPLETE_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataSceneCaptureCompleteFB*>(value), prefix, "const XrEventDataSceneCaptureCompleteFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_CAPTURE_REQUEST_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneCaptureRequestInfoFB*>(value), prefix, "const XrSceneCaptureRequestInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_CONTAINER_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceContainerFB*>(value), prefix, "const XrSpaceContainerFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FOVEATION_EYE_TRACKED_PROFILE_CREATE_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFoveationEyeTrackedProfileCreateInfoMETA*>(value), prefix, "const XrFoveationEyeTrackedProfileCreateInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FOVEATION_EYE_TRACKED_STATE_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFoveationEyeTrackedStateMETA*>(value), prefix, "const XrFoveationEyeTrackedStateMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_FOVEATION_EYE_TRACKED_PROPERTIES_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemFoveationEyeTrackedPropertiesMETA*>(value), prefix, "const XrSystemFoveationEyeTrackedPropertiesMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemFaceTrackingPropertiesFB*>(value), prefix, "const XrSystemFaceTrackingPropertiesFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FACE_TRACKER_CREATE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFaceTrackerCreateInfoFB*>(value), prefix, "const XrFaceTrackerCreateInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FACE_EXPRESSION_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFaceExpressionInfoFB*>(value), prefix, "const XrFaceExpressionInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FACE_EXPRESSION_WEIGHTS_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFaceExpressionWeightsFB*>(value), prefix, "const XrFaceExpressionWeightsFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EYE_TRACKER_CREATE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEyeTrackerCreateInfoFB*>(value), prefix, "const XrEyeTrackerCreateInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EYE_GAZES_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEyeGazesInfoFB*>(value), prefix, "const XrEyeGazesInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EYE_GAZES_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEyeGazesFB*>(value), prefix, "const XrEyeGazesFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_EYE_TRACKING_PROPERTIES_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemEyeTrackingPropertiesFB*>(value), prefix, "const XrSystemEyeTrackingPropertiesFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PASSTHROUGH_KEYBOARD_HANDS_INTENSITY_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPassthroughKeyboardHandsIntensityFB*>(value), prefix, "const XrPassthroughKeyboardHandsIntensityFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_SETTINGS_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerSettingsFB*>(value), prefix, "const XrCompositionLayerSettingsFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAPTIC_PCM_VIBRATION_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHapticPcmVibrationFB*>(value), prefix, "const XrHapticPcmVibrationFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_DEVICE_PCM_SAMPLE_RATE_STATE_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrDevicePcmSampleRateStateFB*>(value), prefix, "const XrDevicePcmSampleRateStateFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FRAME_SYNTHESIS_INFO_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFrameSynthesisInfoEXT*>(value), prefix, "const XrFrameSynthesisInfoEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FRAME_SYNTHESIS_CONFIG_VIEW_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFrameSynthesisConfigViewEXT*>(value), prefix, "const XrFrameSynthesisConfigViewEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerDepthTestFB*>(value), prefix, "const XrCompositionLayerDepthTestFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_LOCAL_DIMMING_FRAME_END_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrLocalDimmingFrameEndInfoMETA*>(value), prefix, "const XrLocalDimmingFrameEndInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PASSTHROUGH_PREFERENCES_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPassthroughPreferencesMETA*>(value), prefix, "const XrPassthroughPreferencesMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_VIRTUAL_KEYBOARD_PROPERTIES_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemVirtualKeyboardPropertiesMETA*>(value), prefix, "const XrSystemVirtualKeyboardPropertiesMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIRTUAL_KEYBOARD_CREATE_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVirtualKeyboardCreateInfoMETA*>(value), prefix, "const XrVirtualKeyboardCreateInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIRTUAL_KEYBOARD_SPACE_CREATE_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVirtualKeyboardSpaceCreateInfoMETA*>(value), prefix, "const XrVirtualKeyboardSpaceCreateInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIRTUAL_KEYBOARD_LOCATION_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVirtualKeyboardLocationInfoMETA*>(value), prefix, "const XrVirtualKeyboardLocationInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIRTUAL_KEYBOARD_MODEL_VISIBILITY_SET_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVirtualKeyboardModelVisibilitySetInfoMETA*>(value), prefix, "const XrVirtualKeyboardModelVisibilitySetInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIRTUAL_KEYBOARD_ANIMATION_STATE_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVirtualKeyboardAnimationStateMETA*>(value), prefix, "const XrVirtualKeyboardAnimationStateMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIRTUAL_KEYBOARD_MODEL_ANIMATION_STATES_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVirtualKeyboardModelAnimationStatesMETA*>(value), prefix, "const XrVirtualKeyboardModelAnimationStatesMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIRTUAL_KEYBOARD_TEXTURE_DATA_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVirtualKeyboardTextureDataMETA*>(value), prefix, "const XrVirtualKeyboardTextureDataMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIRTUAL_KEYBOARD_INPUT_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVirtualKeyboardInputInfoMETA*>(value), prefix, "const XrVirtualKeyboardInputInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_VIRTUAL_KEYBOARD_TEXT_CONTEXT_CHANGE_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVirtualKeyboardTextContextChangeInfoMETA*>(value), prefix, "const XrVirtualKeyboardTextContextChangeInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_COMMIT_TEXT_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataVirtualKeyboardCommitTextMETA*>(value), prefix, "const XrEventDataVirtualKeyboardCommitTextMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_BACKSPACE_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataVirtualKeyboardBackspaceMETA*>(value), prefix, "const XrEventDataVirtualKeyboardBackspaceMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_ENTER_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataVirtualKeyboardEnterMETA*>(value), prefix, "const XrEventDataVirtualKeyboardEnterMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_SHOWN_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataVirtualKeyboardShownMETA*>(value), prefix, "const XrEventDataVirtualKeyboardShownMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_HIDDEN_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataVirtualKeyboardHiddenMETA*>(value), prefix, "const XrEventDataVirtualKeyboardHiddenMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EXTERNAL_CAMERA_OCULUS:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrExternalCameraOCULUS*>(value), prefix, "const XrExternalCameraOCULUS*", true, contents)) {
                    return false;
                }
                return true;
#if defined(XR_USE_GRAPHICS_API_VULKAN)
            case XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrVulkanSwapchainCreateInfoMETA*>(value), prefix, "const XrVulkanSwapchainCreateInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
            case XR_TYPE_PERFORMANCE_METRICS_STATE_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPerformanceMetricsStateMETA*>(value), prefix, "const XrPerformanceMetricsStateMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PERFORMANCE_METRICS_COUNTER_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPerformanceMetricsCounterMETA*>(value), prefix, "const XrPerformanceMetricsCounterMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_LIST_SAVE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceListSaveInfoFB*>(value), prefix, "const XrSpaceListSaveInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_SPACE_LIST_SAVE_COMPLETE_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataSpaceListSaveCompleteFB*>(value), prefix, "const XrEventDataSpaceListSaveCompleteFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_USER_CREATE_INFO_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceUserCreateInfoFB*>(value), prefix, "const XrSpaceUserCreateInfoFB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_HEADSET_ID_PROPERTIES_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemHeadsetIdPropertiesMETA*>(value), prefix, "const XrSystemHeadsetIdPropertiesMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrRecommendedLayerResolutionMETA*>(value), prefix, "const XrRecommendedLayerResolutionMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_GET_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrRecommendedLayerResolutionGetInfoMETA*>(value), prefix, "const XrRecommendedLayerResolutionGetInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_PASSTHROUGH_COLOR_LUT_PROPERTIES_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemPassthroughColorLutPropertiesMETA*>(value), prefix, "const XrSystemPassthroughColorLutPropertiesMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PASSTHROUGH_COLOR_LUT_CREATE_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPassthroughColorLutCreateInfoMETA*>(value), prefix, "const XrPassthroughColorLutCreateInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PASSTHROUGH_COLOR_LUT_UPDATE_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPassthroughColorLutUpdateInfoMETA*>(value), prefix, "const XrPassthroughColorLutUpdateInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PASSTHROUGH_COLOR_MAP_LUT_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPassthroughColorMapLutMETA*>(value), prefix, "const XrPassthroughColorMapLutMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PASSTHROUGH_COLOR_MAP_INTERPOLATED_LUT_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPassthroughColorMapInterpolatedLutMETA*>(value), prefix, "const XrPassthroughColorMapInterpolatedLutMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_TRIANGLE_MESH_GET_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceTriangleMeshGetInfoMETA*>(value), prefix, "const XrSpaceTriangleMeshGetInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_TRIANGLE_MESH_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceTriangleMeshMETA*>(value), prefix, "const XrSpaceTriangleMeshMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_PASSTHROUGH_LAYER_RESUMED_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataPassthroughLayerResumedMETA*>(value), prefix, "const XrEventDataPassthroughLayerResumedMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES2_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemFaceTrackingProperties2FB*>(value), prefix, "const XrSystemFaceTrackingProperties2FB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FACE_TRACKER_CREATE_INFO2_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFaceTrackerCreateInfo2FB*>(value), prefix, "const XrFaceTrackerCreateInfo2FB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FACE_EXPRESSION_INFO2_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFaceExpressionInfo2FB*>(value), prefix, "const XrFaceExpressionInfo2FB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FACE_EXPRESSION_WEIGHTS2_FB:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFaceExpressionWeights2FB*>(value), prefix, "const XrFaceExpressionWeights2FB*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_SPATIAL_ENTITY_SHARING_PROPERTIES_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemSpatialEntitySharingPropertiesMETA*>(value), prefix, "const XrSystemSpatialEntitySharingPropertiesMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SHARE_SPACES_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrShareSpacesInfoMETA*>(value), prefix, "const XrShareSpacesInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_SHARE_SPACES_COMPLETE_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataShareSpacesCompleteMETA*>(value), prefix, "const XrEventDataShareSpacesCompleteMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ENVIRONMENT_DEPTH_PROVIDER_CREATE_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEnvironmentDepthProviderCreateInfoMETA*>(value), prefix, "const XrEnvironmentDepthProviderCreateInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ENVIRONMENT_DEPTH_SWAPCHAIN_CREATE_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEnvironmentDepthSwapchainCreateInfoMETA*>(value), prefix, "const XrEnvironmentDepthSwapchainCreateInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ENVIRONMENT_DEPTH_SWAPCHAIN_STATE_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEnvironmentDepthSwapchainStateMETA*>(value), prefix, "const XrEnvironmentDepthSwapchainStateMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ENVIRONMENT_DEPTH_IMAGE_ACQUIRE_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEnvironmentDepthImageAcquireInfoMETA*>(value), prefix, "const XrEnvironmentDepthImageAcquireInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ENVIRONMENT_DEPTH_IMAGE_VIEW_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEnvironmentDepthImageViewMETA*>(value), prefix, "const XrEnvironmentDepthImageViewMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ENVIRONMENT_DEPTH_IMAGE_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEnvironmentDepthImageMETA*>(value), prefix, "const XrEnvironmentDepthImageMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ENVIRONMENT_DEPTH_HAND_REMOVAL_SET_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEnvironmentDepthHandRemovalSetInfoMETA*>(value), prefix, "const XrEnvironmentDepthHandRemovalSetInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_ENVIRONMENT_DEPTH_PROPERTIES_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemEnvironmentDepthPropertiesMETA*>(value), prefix, "const XrSystemEnvironmentDepthPropertiesMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PASSTHROUGH_CREATE_INFO_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPassthroughCreateInfoHTC*>(value), prefix, "const XrPassthroughCreateInfoHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PASSTHROUGH_COLOR_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPassthroughColorHTC*>(value), prefix, "const XrPassthroughColorHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PASSTHROUGH_MESH_TRANSFORM_INFO_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPassthroughMeshTransformInfoHTC*>(value), prefix, "const XrPassthroughMeshTransformInfoHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrCompositionLayerPassthroughHTC*>(value), prefix, "const XrCompositionLayerPassthroughHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FOVEATION_APPLY_INFO_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFoveationApplyInfoHTC*>(value), prefix, "const XrFoveationApplyInfoHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FOVEATION_DYNAMIC_MODE_INFO_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFoveationDynamicModeInfoHTC*>(value), prefix, "const XrFoveationDynamicModeInfoHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FOVEATION_CUSTOM_MODE_INFO_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFoveationCustomModeInfoHTC*>(value), prefix, "const XrFoveationCustomModeInfoHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_ANCHOR_PROPERTIES_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemAnchorPropertiesHTC*>(value), prefix, "const XrSystemAnchorPropertiesHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorCreateInfoHTC*>(value), prefix, "const XrSpatialAnchorCreateInfoHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemBodyTrackingPropertiesHTC*>(value), prefix, "const XrSystemBodyTrackingPropertiesHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_BODY_TRACKER_CREATE_INFO_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrBodyTrackerCreateInfoHTC*>(value), prefix, "const XrBodyTrackerCreateInfoHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_BODY_JOINTS_LOCATE_INFO_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrBodyJointsLocateInfoHTC*>(value), prefix, "const XrBodyJointsLocateInfoHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_BODY_JOINT_LOCATIONS_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrBodyJointLocationsHTC*>(value), prefix, "const XrBodyJointLocationsHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_BODY_SKELETON_HTC:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrBodySkeletonHTC*>(value), prefix, "const XrBodySkeletonHTC*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ACTIVE_ACTION_SET_PRIORITIES_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrActiveActionSetPrioritiesEXT*>(value), prefix, "const XrActiveActionSetPrioritiesEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_FORCE_FEEDBACK_CURL_PROPERTIES_MNDX:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemForceFeedbackCurlPropertiesMNDX*>(value), prefix, "const XrSystemForceFeedbackCurlPropertiesMNDX*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FORCE_FEEDBACK_CURL_APPLY_LOCATIONS_MNDX:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrForceFeedbackCurlApplyLocationsMNDX*>(value), prefix, "const XrForceFeedbackCurlApplyLocationsMNDX*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_BODY_TRACKER_CREATE_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrBodyTrackerCreateInfoBD*>(value), prefix, "const XrBodyTrackerCreateInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_BODY_JOINTS_LOCATE_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrBodyJointsLocateInfoBD*>(value), prefix, "const XrBodyJointsLocateInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_BODY_JOINT_LOCATIONS_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrBodyJointLocationsBD*>(value), prefix, "const XrBodyJointLocationsBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemBodyTrackingPropertiesBD*>(value), prefix, "const XrSystemBodyTrackingPropertiesBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_SPATIAL_SENSING_PROPERTIES_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemSpatialSensingPropertiesBD*>(value), prefix, "const XrSystemSpatialSensingPropertiesBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ENTITY_COMPONENT_GET_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialEntityComponentGetInfoBD*>(value), prefix, "const XrSpatialEntityComponentGetInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ENTITY_LOCATION_GET_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialEntityLocationGetInfoBD*>(value), prefix, "const XrSpatialEntityLocationGetInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_LOCATION_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialEntityComponentDataLocationBD*>(value), prefix, "const XrSpatialEntityComponentDataLocationBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_SEMANTIC_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialEntityComponentDataSemanticBD*>(value), prefix, "const XrSpatialEntityComponentDataSemanticBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_BOUNDING_BOX_2D_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialEntityComponentDataBoundingBox2DBD*>(value), prefix, "const XrSpatialEntityComponentDataBoundingBox2DBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_POLYGON_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialEntityComponentDataPolygonBD*>(value), prefix, "const XrSpatialEntityComponentDataPolygonBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_BOUNDING_BOX_3D_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialEntityComponentDataBoundingBox3DBD*>(value), prefix, "const XrSpatialEntityComponentDataBoundingBox3DBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_TRIANGLE_MESH_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialEntityComponentDataTriangleMeshBD*>(value), prefix, "const XrSpatialEntityComponentDataTriangleMeshBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SENSE_DATA_PROVIDER_CREATE_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSenseDataProviderCreateInfoBD*>(value), prefix, "const XrSenseDataProviderCreateInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SENSE_DATA_PROVIDER_START_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSenseDataProviderStartInfoBD*>(value), prefix, "const XrSenseDataProviderStartInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_SENSE_DATA_PROVIDER_STATE_CHANGED_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataSenseDataProviderStateChangedBD*>(value), prefix, "const XrEventDataSenseDataProviderStateChangedBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_SENSE_DATA_UPDATED_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataSenseDataUpdatedBD*>(value), prefix, "const XrEventDataSenseDataUpdatedBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SENSE_DATA_QUERY_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSenseDataQueryInfoBD*>(value), prefix, "const XrSenseDataQueryInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SENSE_DATA_QUERY_COMPLETION_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSenseDataQueryCompletionBD*>(value), prefix, "const XrSenseDataQueryCompletionBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SENSE_DATA_FILTER_UUID_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSenseDataFilterUuidBD*>(value), prefix, "const XrSenseDataFilterUuidBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SENSE_DATA_FILTER_SEMANTIC_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSenseDataFilterSemanticBD*>(value), prefix, "const XrSenseDataFilterSemanticBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_QUERIED_SENSE_DATA_GET_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrQueriedSenseDataGetInfoBD*>(value), prefix, "const XrQueriedSenseDataGetInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_QUERIED_SENSE_DATA_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrQueriedSenseDataBD*>(value), prefix, "const XrQueriedSenseDataBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ENTITY_STATE_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialEntityStateBD*>(value), prefix, "const XrSpatialEntityStateBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ENTITY_ANCHOR_CREATE_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialEntityAnchorCreateInfoBD*>(value), prefix, "const XrSpatialEntityAnchorCreateInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_ANCHOR_SPACE_CREATE_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrAnchorSpaceCreateInfoBD*>(value), prefix, "const XrAnchorSpaceCreateInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_SPATIAL_ANCHOR_PROPERTIES_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemSpatialAnchorPropertiesBD*>(value), prefix, "const XrSystemSpatialAnchorPropertiesBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorCreateInfoBD*>(value), prefix, "const XrSpatialAnchorCreateInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHOR_CREATE_COMPLETION_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorCreateCompletionBD*>(value), prefix, "const XrSpatialAnchorCreateCompletionBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHOR_PERSIST_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorPersistInfoBD*>(value), prefix, "const XrSpatialAnchorPersistInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHOR_UNPERSIST_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorUnpersistInfoBD*>(value), prefix, "const XrSpatialAnchorUnpersistInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_SPATIAL_ANCHOR_SHARING_PROPERTIES_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemSpatialAnchorSharingPropertiesBD*>(value), prefix, "const XrSystemSpatialAnchorSharingPropertiesBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPATIAL_ANCHOR_SHARE_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpatialAnchorShareInfoBD*>(value), prefix, "const XrSpatialAnchorShareInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SHARED_SPATIAL_ANCHOR_DOWNLOAD_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSharedSpatialAnchorDownloadInfoBD*>(value), prefix, "const XrSharedSpatialAnchorDownloadInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_SPATIAL_SCENE_PROPERTIES_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemSpatialScenePropertiesBD*>(value), prefix, "const XrSystemSpatialScenePropertiesBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SCENE_CAPTURE_INFO_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSceneCaptureInfoBD*>(value), prefix, "const XrSceneCaptureInfoBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_SPATIAL_MESH_PROPERTIES_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemSpatialMeshPropertiesBD*>(value), prefix, "const XrSystemSpatialMeshPropertiesBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SENSE_DATA_PROVIDER_CREATE_INFO_SPATIAL_MESH_BD:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSenseDataProviderCreateInfoSpatialMeshBD*>(value), prefix, "const XrSenseDataProviderCreateInfoSpatialMeshBD*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAND_TRACKING_DATA_SOURCE_INFO_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHandTrackingDataSourceInfoEXT*>(value), prefix, "const XrHandTrackingDataSourceInfoEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_HAND_TRACKING_DATA_SOURCE_STATE_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrHandTrackingDataSourceStateEXT*>(value), prefix, "const XrHandTrackingDataSourceStateEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PLANE_DETECTOR_CREATE_INFO_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPlaneDetectorCreateInfoEXT*>(value), prefix, "const XrPlaneDetectorCreateInfoEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PLANE_DETECTOR_BEGIN_INFO_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPlaneDetectorBeginInfoEXT*>(value), prefix, "const XrPlaneDetectorBeginInfoEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PLANE_DETECTOR_GET_INFO_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPlaneDetectorGetInfoEXT*>(value), prefix, "const XrPlaneDetectorGetInfoEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PLANE_DETECTOR_LOCATIONS_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPlaneDetectorLocationsEXT*>(value), prefix, "const XrPlaneDetectorLocationsEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PLANE_DETECTOR_LOCATION_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPlaneDetectorLocationEXT*>(value), prefix, "const XrPlaneDetectorLocationEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_PLANE_DETECTOR_POLYGON_BUFFER_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrPlaneDetectorPolygonBufferEXT*>(value), prefix, "const XrPlaneDetectorPolygonBufferEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_PLANE_DETECTION_PROPERTIES_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemPlaneDetectionPropertiesEXT*>(value), prefix, "const XrSystemPlaneDetectionPropertiesEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FUTURE_CANCEL_INFO_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFutureCancelInfoEXT*>(value), prefix, "const XrFutureCancelInfoEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FUTURE_POLL_INFO_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFuturePollInfoEXT*>(value), prefix, "const XrFuturePollInfoEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FUTURE_COMPLETION_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFutureCompletionEXT*>(value), prefix, "const XrFutureCompletionEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FUTURE_POLL_RESULT_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFuturePollResultEXT*>(value), prefix, "const XrFuturePollResultEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_USER_PRESENCE_CHANGED_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataUserPresenceChangedEXT*>(value), prefix, "const XrEventDataUserPresenceChangedEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_USER_PRESENCE_PROPERTIES_EXT:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemUserPresencePropertiesEXT*>(value), prefix, "const XrSystemUserPresencePropertiesEXT*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_NOTIFICATIONS_SET_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemNotificationsSetInfoML*>(value), prefix, "const XrSystemNotificationsSetInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_WORLD_MESH_DETECTOR_CREATE_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrWorldMeshDetectorCreateInfoML*>(value), prefix, "const XrWorldMeshDetectorCreateInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_WORLD_MESH_STATE_REQUEST_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrWorldMeshStateRequestInfoML*>(value), prefix, "const XrWorldMeshStateRequestInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_WORLD_MESH_BLOCK_STATE_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrWorldMeshBlockStateML*>(value), prefix, "const XrWorldMeshBlockStateML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_WORLD_MESH_STATE_REQUEST_COMPLETION_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrWorldMeshStateRequestCompletionML*>(value), prefix, "const XrWorldMeshStateRequestCompletionML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_WORLD_MESH_BUFFER_RECOMMENDED_SIZE_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrWorldMeshBufferRecommendedSizeInfoML*>(value), prefix, "const XrWorldMeshBufferRecommendedSizeInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_WORLD_MESH_BUFFER_SIZE_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrWorldMeshBufferSizeML*>(value), prefix, "const XrWorldMeshBufferSizeML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_WORLD_MESH_BUFFER_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrWorldMeshBufferML*>(value), prefix, "const XrWorldMeshBufferML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_WORLD_MESH_BLOCK_REQUEST_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrWorldMeshBlockRequestML*>(value), prefix, "const XrWorldMeshBlockRequestML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_WORLD_MESH_GET_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrWorldMeshGetInfoML*>(value), prefix, "const XrWorldMeshGetInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_WORLD_MESH_BLOCK_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrWorldMeshBlockML*>(value), prefix, "const XrWorldMeshBlockML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_WORLD_MESH_REQUEST_COMPLETION_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrWorldMeshRequestCompletionML*>(value), prefix, "const XrWorldMeshRequestCompletionML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_WORLD_MESH_REQUEST_COMPLETION_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrWorldMeshRequestCompletionInfoML*>(value), prefix, "const XrWorldMeshRequestCompletionInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_FACIAL_EXPRESSION_PROPERTIES_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemFacialExpressionPropertiesML*>(value), prefix, "const XrSystemFacialExpressionPropertiesML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FACIAL_EXPRESSION_CLIENT_CREATE_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFacialExpressionClientCreateInfoML*>(value), prefix, "const XrFacialExpressionClientCreateInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FACIAL_EXPRESSION_BLEND_SHAPE_GET_INFO_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFacialExpressionBlendShapeGetInfoML*>(value), prefix, "const XrFacialExpressionBlendShapeGetInfoML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_FACIAL_EXPRESSION_BLEND_SHAPE_PROPERTIES_ML:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrFacialExpressionBlendShapePropertiesML*>(value), prefix, "const XrFacialExpressionBlendShapePropertiesML*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COLOCATION_DISCOVERY_START_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrColocationDiscoveryStartInfoMETA*>(value), prefix, "const XrColocationDiscoveryStartInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COLOCATION_DISCOVERY_STOP_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrColocationDiscoveryStopInfoMETA*>(value), prefix, "const XrColocationDiscoveryStopInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COLOCATION_ADVERTISEMENT_START_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrColocationAdvertisementStartInfoMETA*>(value), prefix, "const XrColocationAdvertisementStartInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_COLOCATION_ADVERTISEMENT_STOP_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrColocationAdvertisementStopInfoMETA*>(value), prefix, "const XrColocationAdvertisementStopInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_START_COLOCATION_ADVERTISEMENT_COMPLETE_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataStartColocationAdvertisementCompleteMETA*>(value), prefix, "const XrEventDataStartColocationAdvertisementCompleteMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_STOP_COLOCATION_ADVERTISEMENT_COMPLETE_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataStopColocationAdvertisementCompleteMETA*>(value), prefix, "const XrEventDataStopColocationAdvertisementCompleteMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_COLOCATION_ADVERTISEMENT_COMPLETE_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataColocationAdvertisementCompleteMETA*>(value), prefix, "const XrEventDataColocationAdvertisementCompleteMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_START_COLOCATION_DISCOVERY_COMPLETE_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataStartColocationDiscoveryCompleteMETA*>(value), prefix, "const XrEventDataStartColocationDiscoveryCompleteMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_COLOCATION_DISCOVERY_RESULT_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataColocationDiscoveryResultMETA*>(value), prefix, "const XrEventDataColocationDiscoveryResultMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_COLOCATION_DISCOVERY_COMPLETE_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataColocationDiscoveryCompleteMETA*>(value), prefix, "const XrEventDataColocationDiscoveryCompleteMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_EVENT_DATA_STOP_COLOCATION_DISCOVERY_COMPLETE_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrEventDataStopColocationDiscoveryCompleteMETA*>(value), prefix, "const XrEventDataStopColocationDiscoveryCompleteMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_COLOCATION_DISCOVERY_PROPERTIES_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemColocationDiscoveryPropertiesMETA*>(value), prefix, "const XrSystemColocationDiscoveryPropertiesMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SHARE_SPACES_RECIPIENT_GROUPS_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrShareSpacesRecipientGroupsMETA*>(value), prefix, "const XrShareSpacesRecipientGroupsMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SPACE_GROUP_UUID_FILTER_INFO_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSpaceGroupUuidFilterInfoMETA*>(value), prefix, "const XrSpaceGroupUuidFilterInfoMETA*", true, contents)) {
                    return false;
                }
                return true;
            case XR_TYPE_SYSTEM_SPATIAL_ENTITY_GROUP_SHARING_PROPERTIES_META:
                if (!ApiDumpOutputXrStruct(gen_dispatch_table, reinterpret_cast<const XrSystemSpatialEntityGroupSharingPropertiesMETA*>(value), prefix, "const XrSystemSpatialEntityGroupSharingPropertiesMETA*", true, contents)) {
                    return false;
                }
                return true;
            default:
                return false;
        }
    } catch(...) {
    }
    return false;
}


// Automatically generated api_dump layer commands

// ---- Core 1.0 commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetInstanceProperties(
    XrInstance instance,
    XrInstanceProperties* instanceProperties) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetInstanceProperties", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        std::ostringstream oss_instanceProperties;
        oss_instanceProperties << std::hex << reinterpret_cast<const void*>(instanceProperties);
        contents.emplace_back("XrInstanceProperties*", "instanceProperties", oss_instanceProperties.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetInstanceProperties(instance, instanceProperties);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrPollEvent(
    XrInstance instance,
    XrEventDataBuffer* eventData) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrPollEvent", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        std::ostringstream oss_eventData;
        oss_eventData << std::hex << reinterpret_cast<const void*>(eventData);
        contents.emplace_back("XrEventDataBuffer*", "eventData", oss_eventData.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->PollEvent(instance, eventData);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrResultToString(
    XrInstance instance,
    XrResult value,
    char buffer[XR_MAX_RESULT_STRING_SIZE]) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrResultToString", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (nullptr != gen_dispatch_table) {
            char value_string[XR_MAX_RESULT_STRING_SIZE] = {};
            gen_dispatch_table->ResultToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                               value, value_string);
            contents.emplace_back("XrResult", "value", value_string);
        } else {
                        contents.emplace_back("XrResult", "value", std::to_string(value));
        }
        contents.emplace_back("char*", "buffer", buffer);
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ResultToString(instance, value, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrStructureTypeToString(
    XrInstance instance,
    XrStructureType value,
    char buffer[XR_MAX_STRUCTURE_NAME_SIZE]) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrStructureTypeToString", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (nullptr != gen_dispatch_table) {
            char value_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value, value_string);
            contents.emplace_back("XrStructureType", "value", value_string);
        } else {
                        contents.emplace_back("XrStructureType", "value", std::to_string(value));
        }
        contents.emplace_back("char*", "buffer", buffer);
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->StructureTypeToString(instance, value, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSystem(
    XrInstance instance,
    const XrSystemGetInfo* getInfo,
    XrSystemId* systemId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSystem", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, getInfo, "getInfo", "const XrSystemGetInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_systemId;
        oss_systemId << std::hex << reinterpret_cast<const void*>(systemId);
        contents.emplace_back("XrSystemId*", "systemId", oss_systemId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSystem(instance, getInfo, systemId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSystemProperties(
    XrInstance instance,
    XrSystemId systemId,
    XrSystemProperties* properties) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSystemProperties", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        std::ostringstream oss_properties;
        oss_properties << std::hex << reinterpret_cast<const void*>(properties);
        contents.emplace_back("XrSystemProperties*", "properties", oss_properties.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSystemProperties(instance, systemId, properties);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateEnvironmentBlendModes(
    XrInstance instance,
    XrSystemId systemId,
    XrViewConfigurationType viewConfigurationType,
    uint32_t environmentBlendModeCapacityInput,
    uint32_t* environmentBlendModeCountOutput,
    XrEnvironmentBlendMode* environmentBlendModes) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateEnvironmentBlendModes", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        contents.emplace_back("XrViewConfigurationType", "viewConfigurationType", std::to_string(viewConfigurationType));
        std::ostringstream oss_environmentBlendModeCapacityInput;
        oss_environmentBlendModeCapacityInput << "0x" << std::hex << (environmentBlendModeCapacityInput);
        contents.emplace_back("uint32_t", "environmentBlendModeCapacityInput", oss_environmentBlendModeCapacityInput.str());
        std::ostringstream oss_environmentBlendModeCountOutput;
        oss_environmentBlendModeCountOutput << std::hex << (environmentBlendModeCountOutput);
        contents.emplace_back("uint32_t*", "environmentBlendModeCountOutput", oss_environmentBlendModeCountOutput.str());
        std::ostringstream oss_environmentBlendModes;
        oss_environmentBlendModes << std::hex << reinterpret_cast<const void*>(environmentBlendModes);
        contents.emplace_back("XrEnvironmentBlendMode*", "environmentBlendModes", oss_environmentBlendModes.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateEnvironmentBlendModes(instance, systemId, viewConfigurationType, environmentBlendModeCapacityInput, environmentBlendModeCountOutput, environmentBlendModes);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSession(
    XrInstance instance,
    const XrSessionCreateInfo* createInfo,
    XrSession* session) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSession", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrSessionCreateInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession*", "session", oss_session.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSession(instance, createInfo, session);
        if (XR_SUCCESS == result && nullptr != session) {
            auto exists = g_session_dispatch_map.find(*session);
            if (exists == g_session_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_session_dispatch_mutex);
                g_session_dispatch_map[*session] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroySession(
    XrSession session) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroySession", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroySession(session);
        auto exists = g_session_dispatch_map.find(session);
        if (exists != g_session_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_session_dispatch_mutex);
            g_session_dispatch_map.erase(session);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateReferenceSpaces(
    XrSession session,
    uint32_t spaceCapacityInput,
    uint32_t* spaceCountOutput,
    XrReferenceSpaceType* spaces) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateReferenceSpaces", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_spaceCapacityInput;
        oss_spaceCapacityInput << "0x" << std::hex << (spaceCapacityInput);
        contents.emplace_back("uint32_t", "spaceCapacityInput", oss_spaceCapacityInput.str());
        std::ostringstream oss_spaceCountOutput;
        oss_spaceCountOutput << std::hex << (spaceCountOutput);
        contents.emplace_back("uint32_t*", "spaceCountOutput", oss_spaceCountOutput.str());
        std::ostringstream oss_spaces;
        oss_spaces << std::hex << reinterpret_cast<const void*>(spaces);
        contents.emplace_back("XrReferenceSpaceType*", "spaces", oss_spaces.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateReferenceSpaces(session, spaceCapacityInput, spaceCountOutput, spaces);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateReferenceSpace(
    XrSession session,
    const XrReferenceSpaceCreateInfo* createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateReferenceSpace", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrReferenceSpaceCreateInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace*", "space", oss_space.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateReferenceSpace(session, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            auto exists = g_space_dispatch_map.find(*space);
            if (exists == g_space_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_space_dispatch_mutex);
                g_space_dispatch_map[*space] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetReferenceSpaceBoundsRect(
    XrSession session,
    XrReferenceSpaceType referenceSpaceType,
    XrExtent2Df* bounds) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetReferenceSpaceBoundsRect", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrReferenceSpaceType", "referenceSpaceType", std::to_string(referenceSpaceType));
        std::ostringstream oss_bounds;
        oss_bounds << std::hex << reinterpret_cast<const void*>(bounds);
        contents.emplace_back("XrExtent2Df*", "bounds", oss_bounds.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetReferenceSpaceBoundsRect(session, referenceSpaceType, bounds);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateActionSpace(
    XrSession session,
    const XrActionSpaceCreateInfo* createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateActionSpace", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrActionSpaceCreateInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace*", "space", oss_space.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateActionSpace(session, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            auto exists = g_space_dispatch_map.find(*space);
            if (exists == g_space_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_space_dispatch_mutex);
                g_space_dispatch_map[*space] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrLocateSpace(
    XrSpace space,
    XrSpace baseSpace,
    XrTime time,
    XrSpaceLocation* location) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_space_dispatch_mutex);
            auto map_iter = g_space_dispatch_map.find(space);
            if (map_iter == g_space_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrLocateSpace", "");
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace", "space", oss_space.str());
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(baseSpace);
        contents.emplace_back("XrSpace", "baseSpace", oss_baseSpace.str());
        contents.emplace_back("XrTime", "time", std::to_string(time));
        std::ostringstream oss_location;
        oss_location << std::hex << reinterpret_cast<const void*>(location);
        contents.emplace_back("XrSpaceLocation*", "location", oss_location.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->LocateSpace(space, baseSpace, time, location);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroySpace(
    XrSpace space) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_space_dispatch_mutex);
            auto map_iter = g_space_dispatch_map.find(space);
            if (map_iter == g_space_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroySpace", "");
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace", "space", oss_space.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroySpace(space);
        auto exists = g_space_dispatch_map.find(space);
        if (exists != g_space_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_space_dispatch_mutex);
            g_space_dispatch_map.erase(space);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateViewConfigurations(
    XrInstance instance,
    XrSystemId systemId,
    uint32_t viewConfigurationTypeCapacityInput,
    uint32_t* viewConfigurationTypeCountOutput,
    XrViewConfigurationType* viewConfigurationTypes) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateViewConfigurations", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        std::ostringstream oss_viewConfigurationTypeCapacityInput;
        oss_viewConfigurationTypeCapacityInput << "0x" << std::hex << (viewConfigurationTypeCapacityInput);
        contents.emplace_back("uint32_t", "viewConfigurationTypeCapacityInput", oss_viewConfigurationTypeCapacityInput.str());
        std::ostringstream oss_viewConfigurationTypeCountOutput;
        oss_viewConfigurationTypeCountOutput << std::hex << (viewConfigurationTypeCountOutput);
        contents.emplace_back("uint32_t*", "viewConfigurationTypeCountOutput", oss_viewConfigurationTypeCountOutput.str());
        std::ostringstream oss_viewConfigurationTypes;
        oss_viewConfigurationTypes << std::hex << reinterpret_cast<const void*>(viewConfigurationTypes);
        contents.emplace_back("XrViewConfigurationType*", "viewConfigurationTypes", oss_viewConfigurationTypes.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateViewConfigurations(instance, systemId, viewConfigurationTypeCapacityInput, viewConfigurationTypeCountOutput, viewConfigurationTypes);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetViewConfigurationProperties(
    XrInstance instance,
    XrSystemId systemId,
    XrViewConfigurationType viewConfigurationType,
    XrViewConfigurationProperties* configurationProperties) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetViewConfigurationProperties", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        contents.emplace_back("XrViewConfigurationType", "viewConfigurationType", std::to_string(viewConfigurationType));
        std::ostringstream oss_configurationProperties;
        oss_configurationProperties << std::hex << reinterpret_cast<const void*>(configurationProperties);
        contents.emplace_back("XrViewConfigurationProperties*", "configurationProperties", oss_configurationProperties.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetViewConfigurationProperties(instance, systemId, viewConfigurationType, configurationProperties);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateViewConfigurationViews(
    XrInstance instance,
    XrSystemId systemId,
    XrViewConfigurationType viewConfigurationType,
    uint32_t viewCapacityInput,
    uint32_t* viewCountOutput,
    XrViewConfigurationView* views) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateViewConfigurationViews", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        contents.emplace_back("XrViewConfigurationType", "viewConfigurationType", std::to_string(viewConfigurationType));
        std::ostringstream oss_viewCapacityInput;
        oss_viewCapacityInput << "0x" << std::hex << (viewCapacityInput);
        contents.emplace_back("uint32_t", "viewCapacityInput", oss_viewCapacityInput.str());
        std::ostringstream oss_viewCountOutput;
        oss_viewCountOutput << std::hex << (viewCountOutput);
        contents.emplace_back("uint32_t*", "viewCountOutput", oss_viewCountOutput.str());
        std::ostringstream oss_views;
        oss_views << std::hex << reinterpret_cast<const void*>(views);
        contents.emplace_back("XrViewConfigurationView*", "views", oss_views.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateViewConfigurationViews(instance, systemId, viewConfigurationType, viewCapacityInput, viewCountOutput, views);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateSwapchainFormats(
    XrSession session,
    uint32_t formatCapacityInput,
    uint32_t* formatCountOutput,
    int64_t* formats) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateSwapchainFormats", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_formatCapacityInput;
        oss_formatCapacityInput << "0x" << std::hex << (formatCapacityInput);
        contents.emplace_back("uint32_t", "formatCapacityInput", oss_formatCapacityInput.str());
        std::ostringstream oss_formatCountOutput;
        oss_formatCountOutput << std::hex << (formatCountOutput);
        contents.emplace_back("uint32_t*", "formatCountOutput", oss_formatCountOutput.str());
        std::ostringstream oss_formats;
        oss_formats << std::hex << reinterpret_cast<const void*>(formats);
        contents.emplace_back("int64_t*", "formats", oss_formats.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateSwapchainFormats(session, formatCapacityInput, formatCountOutput, formats);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSwapchain(
    XrSession session,
    const XrSwapchainCreateInfo* createInfo,
    XrSwapchain* swapchain) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSwapchain", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrSwapchainCreateInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_swapchain;
        oss_swapchain << std::hex << reinterpret_cast<const void*>(swapchain);
        contents.emplace_back("XrSwapchain*", "swapchain", oss_swapchain.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSwapchain(session, createInfo, swapchain);
        if (XR_SUCCESS == result && nullptr != swapchain) {
            auto exists = g_swapchain_dispatch_map.find(*swapchain);
            if (exists == g_swapchain_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_swapchain_dispatch_mutex);
                g_swapchain_dispatch_map[*swapchain] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroySwapchain(
    XrSwapchain swapchain) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_swapchain_dispatch_mutex);
            auto map_iter = g_swapchain_dispatch_map.find(swapchain);
            if (map_iter == g_swapchain_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroySwapchain", "");
        std::ostringstream oss_swapchain;
        oss_swapchain << std::hex << reinterpret_cast<const void*>(swapchain);
        contents.emplace_back("XrSwapchain", "swapchain", oss_swapchain.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroySwapchain(swapchain);
        auto exists = g_swapchain_dispatch_map.find(swapchain);
        if (exists != g_swapchain_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_swapchain_dispatch_mutex);
            g_swapchain_dispatch_map.erase(swapchain);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateSwapchainImages(
    XrSwapchain swapchain,
    uint32_t imageCapacityInput,
    uint32_t* imageCountOutput,
    XrSwapchainImageBaseHeader* images) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_swapchain_dispatch_mutex);
            auto map_iter = g_swapchain_dispatch_map.find(swapchain);
            if (map_iter == g_swapchain_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateSwapchainImages", "");
        std::ostringstream oss_swapchain;
        oss_swapchain << std::hex << reinterpret_cast<const void*>(swapchain);
        contents.emplace_back("XrSwapchain", "swapchain", oss_swapchain.str());
        std::ostringstream oss_imageCapacityInput;
        oss_imageCapacityInput << "0x" << std::hex << (imageCapacityInput);
        contents.emplace_back("uint32_t", "imageCapacityInput", oss_imageCapacityInput.str());
        std::ostringstream oss_imageCountOutput;
        oss_imageCountOutput << std::hex << (imageCountOutput);
        contents.emplace_back("uint32_t*", "imageCountOutput", oss_imageCountOutput.str());
        std::ostringstream oss_images;
        oss_images << std::hex << reinterpret_cast<const void*>(images);
        contents.emplace_back("XrSwapchainImageBaseHeader*", "images", oss_images.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateSwapchainImages(swapchain, imageCapacityInput, imageCountOutput, images);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrAcquireSwapchainImage(
    XrSwapchain swapchain,
    const XrSwapchainImageAcquireInfo* acquireInfo,
    uint32_t* index) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_swapchain_dispatch_mutex);
            auto map_iter = g_swapchain_dispatch_map.find(swapchain);
            if (map_iter == g_swapchain_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrAcquireSwapchainImage", "");
        std::ostringstream oss_swapchain;
        oss_swapchain << std::hex << reinterpret_cast<const void*>(swapchain);
        contents.emplace_back("XrSwapchain", "swapchain", oss_swapchain.str());
        if (nullptr == acquireInfo) {
            std::ostringstream oss_acquireInfo;
            oss_acquireInfo << std::hex << reinterpret_cast<const void*>(acquireInfo);
            contents.emplace_back("const XrSwapchainImageAcquireInfo*", "acquireInfo", oss_acquireInfo.str());
        } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, acquireInfo, "acquireInfo", "const XrSwapchainImageAcquireInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_index;
        oss_index << std::hex << (index);
        contents.emplace_back("uint32_t*", "index", oss_index.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->AcquireSwapchainImage(swapchain, acquireInfo, index);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrWaitSwapchainImage(
    XrSwapchain swapchain,
    const XrSwapchainImageWaitInfo* waitInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_swapchain_dispatch_mutex);
            auto map_iter = g_swapchain_dispatch_map.find(swapchain);
            if (map_iter == g_swapchain_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrWaitSwapchainImage", "");
        std::ostringstream oss_swapchain;
        oss_swapchain << std::hex << reinterpret_cast<const void*>(swapchain);
        contents.emplace_back("XrSwapchain", "swapchain", oss_swapchain.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, waitInfo, "waitInfo", "const XrSwapchainImageWaitInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->WaitSwapchainImage(swapchain, waitInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrReleaseSwapchainImage(
    XrSwapchain swapchain,
    const XrSwapchainImageReleaseInfo* releaseInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_swapchain_dispatch_mutex);
            auto map_iter = g_swapchain_dispatch_map.find(swapchain);
            if (map_iter == g_swapchain_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrReleaseSwapchainImage", "");
        std::ostringstream oss_swapchain;
        oss_swapchain << std::hex << reinterpret_cast<const void*>(swapchain);
        contents.emplace_back("XrSwapchain", "swapchain", oss_swapchain.str());
        if (nullptr == releaseInfo) {
            std::ostringstream oss_releaseInfo;
            oss_releaseInfo << std::hex << reinterpret_cast<const void*>(releaseInfo);
            contents.emplace_back("const XrSwapchainImageReleaseInfo*", "releaseInfo", oss_releaseInfo.str());
        } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, releaseInfo, "releaseInfo", "const XrSwapchainImageReleaseInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ReleaseSwapchainImage(swapchain, releaseInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrBeginSession(
    XrSession session,
    const XrSessionBeginInfo* beginInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrBeginSession", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, beginInfo, "beginInfo", "const XrSessionBeginInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->BeginSession(session, beginInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEndSession(
    XrSession session) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEndSession", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EndSession(session);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrRequestExitSession(
    XrSession session) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrRequestExitSession", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->RequestExitSession(session);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrWaitFrame(
    XrSession session,
    const XrFrameWaitInfo* frameWaitInfo,
    XrFrameState* frameState) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrWaitFrame", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (nullptr == frameWaitInfo) {
            std::ostringstream oss_frameWaitInfo;
            oss_frameWaitInfo << std::hex << reinterpret_cast<const void*>(frameWaitInfo);
            contents.emplace_back("const XrFrameWaitInfo*", "frameWaitInfo", oss_frameWaitInfo.str());
        } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, frameWaitInfo, "frameWaitInfo", "const XrFrameWaitInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_frameState;
        oss_frameState << std::hex << reinterpret_cast<const void*>(frameState);
        contents.emplace_back("XrFrameState*", "frameState", oss_frameState.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->WaitFrame(session, frameWaitInfo, frameState);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrBeginFrame(
    XrSession session,
    const XrFrameBeginInfo* frameBeginInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrBeginFrame", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (nullptr == frameBeginInfo) {
            std::ostringstream oss_frameBeginInfo;
            oss_frameBeginInfo << std::hex << reinterpret_cast<const void*>(frameBeginInfo);
            contents.emplace_back("const XrFrameBeginInfo*", "frameBeginInfo", oss_frameBeginInfo.str());
        } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, frameBeginInfo, "frameBeginInfo", "const XrFrameBeginInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->BeginFrame(session, frameBeginInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEndFrame(
    XrSession session,
    const XrFrameEndInfo* frameEndInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEndFrame", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, frameEndInfo, "frameEndInfo", "const XrFrameEndInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EndFrame(session, frameEndInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrLocateViews(
    XrSession session,
    const XrViewLocateInfo* viewLocateInfo,
    XrViewState* viewState,
    uint32_t viewCapacityInput,
    uint32_t* viewCountOutput,
    XrView* views) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrLocateViews", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, viewLocateInfo, "viewLocateInfo", "const XrViewLocateInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_viewState;
        oss_viewState << std::hex << reinterpret_cast<const void*>(viewState);
        contents.emplace_back("XrViewState*", "viewState", oss_viewState.str());
        std::ostringstream oss_viewCapacityInput;
        oss_viewCapacityInput << "0x" << std::hex << (viewCapacityInput);
        contents.emplace_back("uint32_t", "viewCapacityInput", oss_viewCapacityInput.str());
        std::ostringstream oss_viewCountOutput;
        oss_viewCountOutput << std::hex << (viewCountOutput);
        contents.emplace_back("uint32_t*", "viewCountOutput", oss_viewCountOutput.str());
        std::ostringstream oss_views;
        oss_views << std::hex << reinterpret_cast<const void*>(views);
        contents.emplace_back("XrView*", "views", oss_views.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->LocateViews(session, viewLocateInfo, viewState, viewCapacityInput, viewCountOutput, views);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrStringToPath(
    XrInstance instance,
    const char* pathString,
    XrPath* path) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrStringToPath", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("const char*", "pathString", pathString);
        std::ostringstream oss_path;
        oss_path << std::hex << reinterpret_cast<const void*>(path);
        contents.emplace_back("XrPath*", "path", oss_path.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->StringToPath(instance, pathString, path);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrPathToString(
    XrInstance instance,
    XrPath path,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrPathToString", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrPath", "path", std::to_string(path));
        std::ostringstream oss_bufferCapacityInput;
        oss_bufferCapacityInput << "0x" << std::hex << (bufferCapacityInput);
        contents.emplace_back("uint32_t", "bufferCapacityInput", oss_bufferCapacityInput.str());
        std::ostringstream oss_bufferCountOutput;
        oss_bufferCountOutput << std::hex << (bufferCountOutput);
        contents.emplace_back("uint32_t*", "bufferCountOutput", oss_bufferCountOutput.str());
        contents.emplace_back("char*", "buffer", (buffer ? buffer : "(nullptr)"));
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->PathToString(instance, path, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateActionSet(
    XrInstance instance,
    const XrActionSetCreateInfo* createInfo,
    XrActionSet* actionSet) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateActionSet", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrActionSetCreateInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_actionSet;
        oss_actionSet << std::hex << reinterpret_cast<const void*>(actionSet);
        contents.emplace_back("XrActionSet*", "actionSet", oss_actionSet.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateActionSet(instance, createInfo, actionSet);
        if (XR_SUCCESS == result && nullptr != actionSet) {
            auto exists = g_actionset_dispatch_map.find(*actionSet);
            if (exists == g_actionset_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_actionset_dispatch_mutex);
                g_actionset_dispatch_map[*actionSet] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyActionSet(
    XrActionSet actionSet) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_actionset_dispatch_mutex);
            auto map_iter = g_actionset_dispatch_map.find(actionSet);
            if (map_iter == g_actionset_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyActionSet", "");
        std::ostringstream oss_actionSet;
        oss_actionSet << std::hex << reinterpret_cast<const void*>(actionSet);
        contents.emplace_back("XrActionSet", "actionSet", oss_actionSet.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyActionSet(actionSet);
        auto exists = g_actionset_dispatch_map.find(actionSet);
        if (exists != g_actionset_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_actionset_dispatch_mutex);
            g_actionset_dispatch_map.erase(actionSet);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateAction(
    XrActionSet actionSet,
    const XrActionCreateInfo* createInfo,
    XrAction* action) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_actionset_dispatch_mutex);
            auto map_iter = g_actionset_dispatch_map.find(actionSet);
            if (map_iter == g_actionset_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateAction", "");
        std::ostringstream oss_actionSet;
        oss_actionSet << std::hex << reinterpret_cast<const void*>(actionSet);
        contents.emplace_back("XrActionSet", "actionSet", oss_actionSet.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrActionCreateInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_action;
        oss_action << std::hex << reinterpret_cast<const void*>(action);
        contents.emplace_back("XrAction*", "action", oss_action.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateAction(actionSet, createInfo, action);
        if (XR_SUCCESS == result && nullptr != action) {
            auto exists = g_action_dispatch_map.find(*action);
            if (exists == g_action_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_action_dispatch_mutex);
                g_action_dispatch_map[*action] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyAction(
    XrAction action) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_action_dispatch_mutex);
            auto map_iter = g_action_dispatch_map.find(action);
            if (map_iter == g_action_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyAction", "");
        std::ostringstream oss_action;
        oss_action << std::hex << reinterpret_cast<const void*>(action);
        contents.emplace_back("XrAction", "action", oss_action.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyAction(action);
        auto exists = g_action_dispatch_map.find(action);
        if (exists != g_action_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_action_dispatch_mutex);
            g_action_dispatch_map.erase(action);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSuggestInteractionProfileBindings(
    XrInstance instance,
    const XrInteractionProfileSuggestedBinding* suggestedBindings) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSuggestInteractionProfileBindings", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, suggestedBindings, "suggestedBindings", "const XrInteractionProfileSuggestedBinding*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SuggestInteractionProfileBindings(instance, suggestedBindings);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrAttachSessionActionSets(
    XrSession session,
    const XrSessionActionSetsAttachInfo* attachInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrAttachSessionActionSets", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, attachInfo, "attachInfo", "const XrSessionActionSetsAttachInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->AttachSessionActionSets(session, attachInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetCurrentInteractionProfile(
    XrSession session,
    XrPath topLevelUserPath,
    XrInteractionProfileState* interactionProfile) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetCurrentInteractionProfile", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrPath", "topLevelUserPath", std::to_string(topLevelUserPath));
        std::ostringstream oss_interactionProfile;
        oss_interactionProfile << std::hex << reinterpret_cast<const void*>(interactionProfile);
        contents.emplace_back("XrInteractionProfileState*", "interactionProfile", oss_interactionProfile.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetCurrentInteractionProfile(session, topLevelUserPath, interactionProfile);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetActionStateBoolean(
    XrSession session,
    const XrActionStateGetInfo* getInfo,
    XrActionStateBoolean* state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetActionStateBoolean", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, getInfo, "getInfo", "const XrActionStateGetInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_state;
        oss_state << std::hex << reinterpret_cast<const void*>(state);
        contents.emplace_back("XrActionStateBoolean*", "state", oss_state.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetActionStateBoolean(session, getInfo, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetActionStateFloat(
    XrSession session,
    const XrActionStateGetInfo* getInfo,
    XrActionStateFloat* state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetActionStateFloat", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, getInfo, "getInfo", "const XrActionStateGetInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_state;
        oss_state << std::hex << reinterpret_cast<const void*>(state);
        contents.emplace_back("XrActionStateFloat*", "state", oss_state.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetActionStateFloat(session, getInfo, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetActionStateVector2f(
    XrSession session,
    const XrActionStateGetInfo* getInfo,
    XrActionStateVector2f* state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetActionStateVector2f", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, getInfo, "getInfo", "const XrActionStateGetInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_state;
        oss_state << std::hex << reinterpret_cast<const void*>(state);
        contents.emplace_back("XrActionStateVector2f*", "state", oss_state.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetActionStateVector2f(session, getInfo, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetActionStatePose(
    XrSession session,
    const XrActionStateGetInfo* getInfo,
    XrActionStatePose* state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetActionStatePose", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, getInfo, "getInfo", "const XrActionStateGetInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_state;
        oss_state << std::hex << reinterpret_cast<const void*>(state);
        contents.emplace_back("XrActionStatePose*", "state", oss_state.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetActionStatePose(session, getInfo, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSyncActions(
    XrSession session,
    const XrActionsSyncInfo* syncInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSyncActions", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, syncInfo, "syncInfo", "const XrActionsSyncInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SyncActions(session, syncInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateBoundSourcesForAction(
    XrSession session,
    const XrBoundSourcesForActionEnumerateInfo* enumerateInfo,
    uint32_t sourceCapacityInput,
    uint32_t* sourceCountOutput,
    XrPath* sources) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateBoundSourcesForAction", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, enumerateInfo, "enumerateInfo", "const XrBoundSourcesForActionEnumerateInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_sourceCapacityInput;
        oss_sourceCapacityInput << "0x" << std::hex << (sourceCapacityInput);
        contents.emplace_back("uint32_t", "sourceCapacityInput", oss_sourceCapacityInput.str());
        std::ostringstream oss_sourceCountOutput;
        oss_sourceCountOutput << std::hex << (sourceCountOutput);
        contents.emplace_back("uint32_t*", "sourceCountOutput", oss_sourceCountOutput.str());
        std::ostringstream oss_sources;
        oss_sources << std::hex << reinterpret_cast<const void*>(sources);
        contents.emplace_back("XrPath*", "sources", oss_sources.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateBoundSourcesForAction(session, enumerateInfo, sourceCapacityInput, sourceCountOutput, sources);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetInputSourceLocalizedName(
    XrSession session,
    const XrInputSourceLocalizedNameGetInfo* getInfo,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetInputSourceLocalizedName", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, getInfo, "getInfo", "const XrInputSourceLocalizedNameGetInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_bufferCapacityInput;
        oss_bufferCapacityInput << "0x" << std::hex << (bufferCapacityInput);
        contents.emplace_back("uint32_t", "bufferCapacityInput", oss_bufferCapacityInput.str());
        std::ostringstream oss_bufferCountOutput;
        oss_bufferCountOutput << std::hex << (bufferCountOutput);
        contents.emplace_back("uint32_t*", "bufferCountOutput", oss_bufferCountOutput.str());
        contents.emplace_back("char*", "buffer", (buffer ? buffer : "(nullptr)"));
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetInputSourceLocalizedName(session, getInfo, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrApplyHapticFeedback(
    XrSession session,
    const XrHapticActionInfo* hapticActionInfo,
    const XrHapticBaseHeader* hapticFeedback) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrApplyHapticFeedback", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, hapticActionInfo, "hapticActionInfo", "const XrHapticActionInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, hapticFeedback, "hapticFeedback", "const XrHapticBaseHeader*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ApplyHapticFeedback(session, hapticActionInfo, hapticFeedback);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrStopHapticFeedback(
    XrSession session,
    const XrHapticActionInfo* hapticActionInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrStopHapticFeedback", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, hapticActionInfo, "hapticActionInfo", "const XrHapticActionInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->StopHapticFeedback(session, hapticActionInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_LOADER_VERSION_1_0 extension commands

// ---- Core 1.1 commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrLocateSpaces(
    XrSession session,
    const XrSpacesLocateInfo* locateInfo,
    XrSpaceLocations* spaceLocations) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrLocateSpaces", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, locateInfo, "locateInfo", "const XrSpacesLocateInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_spaceLocations;
        oss_spaceLocations << std::hex << reinterpret_cast<const void*>(spaceLocations);
        contents.emplace_back("XrSpaceLocations*", "spaceLocations", oss_spaceLocations.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->LocateSpaces(session, locateInfo, spaceLocations);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_KHR_android_thread_settings extension commands
#if defined(XR_USE_PLATFORM_ANDROID)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetAndroidApplicationThreadKHR(
    XrSession session,
    XrAndroidThreadTypeKHR threadType,
    uint32_t threadId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetAndroidApplicationThreadKHR", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrAndroidThreadTypeKHR", "threadType", std::to_string(threadType));
        std::ostringstream oss_threadId;
        oss_threadId << "0x" << std::hex << (threadId);
        contents.emplace_back("uint32_t", "threadId", oss_threadId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetAndroidApplicationThreadKHR(session, threadType, threadId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_PLATFORM_ANDROID)

// ---- XR_KHR_android_surface_swapchain extension commands
#if defined(XR_USE_PLATFORM_ANDROID)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSwapchainAndroidSurfaceKHR(
    XrSession session,
    const XrSwapchainCreateInfo* info,
    XrSwapchain* swapchain,
    jobject* surface) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSwapchainAndroidSurfaceKHR", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSwapchainCreateInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_swapchain;
        oss_swapchain << std::hex << reinterpret_cast<const void*>(swapchain);
        contents.emplace_back("XrSwapchain*", "swapchain", oss_swapchain.str());
        std::ostringstream oss_surface;
        oss_surface << std::hex << reinterpret_cast<const void*>(surface);
        contents.emplace_back("jobject*", "surface", oss_surface.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSwapchainAndroidSurfaceKHR(session, info, swapchain, surface);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_PLATFORM_ANDROID)

// ---- XR_KHR_opengl_enable extension commands
#if defined(XR_USE_GRAPHICS_API_OPENGL)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetOpenGLGraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsOpenGLKHR* graphicsRequirements) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetOpenGLGraphicsRequirementsKHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        std::ostringstream oss_graphicsRequirements;
        oss_graphicsRequirements << std::hex << reinterpret_cast<const void*>(graphicsRequirements);
        contents.emplace_back("XrGraphicsRequirementsOpenGLKHR*", "graphicsRequirements", oss_graphicsRequirements.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetOpenGLGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_GRAPHICS_API_OPENGL)

// ---- XR_KHR_opengl_es_enable extension commands
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetOpenGLESGraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsOpenGLESKHR* graphicsRequirements) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetOpenGLESGraphicsRequirementsKHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        std::ostringstream oss_graphicsRequirements;
        oss_graphicsRequirements << std::hex << reinterpret_cast<const void*>(graphicsRequirements);
        contents.emplace_back("XrGraphicsRequirementsOpenGLESKHR*", "graphicsRequirements", oss_graphicsRequirements.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetOpenGLESGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)

// ---- XR_KHR_vulkan_enable extension commands
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetVulkanInstanceExtensionsKHR(
    XrInstance instance,
    XrSystemId systemId,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetVulkanInstanceExtensionsKHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        std::ostringstream oss_bufferCapacityInput;
        oss_bufferCapacityInput << "0x" << std::hex << (bufferCapacityInput);
        contents.emplace_back("uint32_t", "bufferCapacityInput", oss_bufferCapacityInput.str());
        std::ostringstream oss_bufferCountOutput;
        oss_bufferCountOutput << std::hex << (bufferCountOutput);
        contents.emplace_back("uint32_t*", "bufferCountOutput", oss_bufferCountOutput.str());
        contents.emplace_back("char*", "buffer", (buffer ? buffer : "(nullptr)"));
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetVulkanInstanceExtensionsKHR(instance, systemId, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetVulkanDeviceExtensionsKHR(
    XrInstance instance,
    XrSystemId systemId,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetVulkanDeviceExtensionsKHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        std::ostringstream oss_bufferCapacityInput;
        oss_bufferCapacityInput << "0x" << std::hex << (bufferCapacityInput);
        contents.emplace_back("uint32_t", "bufferCapacityInput", oss_bufferCapacityInput.str());
        std::ostringstream oss_bufferCountOutput;
        oss_bufferCountOutput << std::hex << (bufferCountOutput);
        contents.emplace_back("uint32_t*", "bufferCountOutput", oss_bufferCountOutput.str());
        contents.emplace_back("char*", "buffer", (buffer ? buffer : "(nullptr)"));
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetVulkanDeviceExtensionsKHR(instance, systemId, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetVulkanGraphicsDeviceKHR(
    XrInstance instance,
    XrSystemId systemId,
    VkInstance vkInstance,
    VkPhysicalDevice* vkPhysicalDevice) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetVulkanGraphicsDeviceKHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        std::ostringstream oss_vkInstance;
        oss_vkInstance << std::hex << reinterpret_cast<const void*>(vkInstance);
        contents.emplace_back("VkInstance", "vkInstance", oss_vkInstance.str());
        std::ostringstream oss_vkPhysicalDevice;
        oss_vkPhysicalDevice << std::hex << reinterpret_cast<const void*>(vkPhysicalDevice);
        contents.emplace_back("VkPhysicalDevice*", "vkPhysicalDevice", oss_vkPhysicalDevice.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetVulkanGraphicsDeviceKHR(instance, systemId, vkInstance, vkPhysicalDevice);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetVulkanGraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsVulkanKHR* graphicsRequirements) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetVulkanGraphicsRequirementsKHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        std::ostringstream oss_graphicsRequirements;
        oss_graphicsRequirements << std::hex << reinterpret_cast<const void*>(graphicsRequirements);
        contents.emplace_back("XrGraphicsRequirementsVulkanKHR*", "graphicsRequirements", oss_graphicsRequirements.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetVulkanGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

// ---- XR_KHR_D3D11_enable extension commands
#if defined(XR_USE_GRAPHICS_API_D3D11)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetD3D11GraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsD3D11KHR* graphicsRequirements) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetD3D11GraphicsRequirementsKHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        std::ostringstream oss_graphicsRequirements;
        oss_graphicsRequirements << std::hex << reinterpret_cast<const void*>(graphicsRequirements);
        contents.emplace_back("XrGraphicsRequirementsD3D11KHR*", "graphicsRequirements", oss_graphicsRequirements.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetD3D11GraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_GRAPHICS_API_D3D11)

// ---- XR_KHR_D3D12_enable extension commands
#if defined(XR_USE_GRAPHICS_API_D3D12)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetD3D12GraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsD3D12KHR* graphicsRequirements) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetD3D12GraphicsRequirementsKHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        std::ostringstream oss_graphicsRequirements;
        oss_graphicsRequirements << std::hex << reinterpret_cast<const void*>(graphicsRequirements);
        contents.emplace_back("XrGraphicsRequirementsD3D12KHR*", "graphicsRequirements", oss_graphicsRequirements.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetD3D12GraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_GRAPHICS_API_D3D12)

// ---- XR_KHR_metal_enable extension commands
#if defined(XR_USE_GRAPHICS_API_METAL)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetMetalGraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsMetalKHR* graphicsRequirements) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetMetalGraphicsRequirementsKHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        std::ostringstream oss_graphicsRequirements;
        oss_graphicsRequirements << std::hex << reinterpret_cast<const void*>(graphicsRequirements);
        contents.emplace_back("XrGraphicsRequirementsMetalKHR*", "graphicsRequirements", oss_graphicsRequirements.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetMetalGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_GRAPHICS_API_METAL)

// ---- XR_KHR_visibility_mask extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetVisibilityMaskKHR(
    XrSession session,
    XrViewConfigurationType viewConfigurationType,
    uint32_t viewIndex,
    XrVisibilityMaskTypeKHR visibilityMaskType,
    XrVisibilityMaskKHR* visibilityMask) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetVisibilityMaskKHR", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrViewConfigurationType", "viewConfigurationType", std::to_string(viewConfigurationType));
        std::ostringstream oss_viewIndex;
        oss_viewIndex << "0x" << std::hex << (viewIndex);
        contents.emplace_back("uint32_t", "viewIndex", oss_viewIndex.str());
        contents.emplace_back("XrVisibilityMaskTypeKHR", "visibilityMaskType", std::to_string(visibilityMaskType));
        std::ostringstream oss_visibilityMask;
        oss_visibilityMask << std::hex << reinterpret_cast<const void*>(visibilityMask);
        contents.emplace_back("XrVisibilityMaskKHR*", "visibilityMask", oss_visibilityMask.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetVisibilityMaskKHR(session, viewConfigurationType, viewIndex, visibilityMaskType, visibilityMask);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_KHR_win32_convert_performance_counter_time extension commands
#if defined(XR_USE_PLATFORM_WIN32)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrConvertWin32PerformanceCounterToTimeKHR(
    XrInstance instance,
    const LARGE_INTEGER* performanceCounter,
    XrTime* time) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrConvertWin32PerformanceCounterToTimeKHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        std::ostringstream oss_performanceCounter;
        oss_performanceCounter << std::hex << reinterpret_cast<const void*>( (*performanceCounter).QuadPart );
        contents.emplace_back("const LARGE_INTEGER*", "performanceCounter", oss_performanceCounter.str());
        std::ostringstream oss_time;
        oss_time << std::hex << reinterpret_cast<const void*>(time);
        contents.emplace_back("XrTime*", "time", oss_time.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ConvertWin32PerformanceCounterToTimeKHR(instance, performanceCounter, time);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_PLATFORM_WIN32)
#if defined(XR_USE_PLATFORM_WIN32)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrConvertTimeToWin32PerformanceCounterKHR(
    XrInstance instance,
    XrTime time,
    LARGE_INTEGER* performanceCounter) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrConvertTimeToWin32PerformanceCounterKHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrTime", "time", std::to_string(time));
        std::ostringstream oss_performanceCounter;
        oss_performanceCounter << std::hex << reinterpret_cast<const void*>( (*performanceCounter).QuadPart );
        contents.emplace_back("LARGE_INTEGER*", "performanceCounter", oss_performanceCounter.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ConvertTimeToWin32PerformanceCounterKHR(instance, time, performanceCounter);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_PLATFORM_WIN32)

// ---- XR_KHR_convert_timespec_time extension commands
#if defined(XR_USE_TIMESPEC)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrConvertTimespecTimeToTimeKHR(
    XrInstance instance,
    const struct timespec* timespecTime,
    XrTime* time) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrConvertTimespecTimeToTimeKHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        std::ostringstream oss_timespecTime;
        oss_timespecTime << (*timespecTime).tv_sec << ".";
        oss_timespecTime << std::setw(9) << std::setfill('0') << (*timespecTime).tv_nsec << "s";
        contents.emplace_back("const struct timespec*", "timespecTime", oss_timespecTime.str());
        std::ostringstream oss_time;
        oss_time << std::hex << reinterpret_cast<const void*>(time);
        contents.emplace_back("XrTime*", "time", oss_time.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ConvertTimespecTimeToTimeKHR(instance, timespecTime, time);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_TIMESPEC)
#if defined(XR_USE_TIMESPEC)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrConvertTimeToTimespecTimeKHR(
    XrInstance instance,
    XrTime time,
    struct timespec* timespecTime) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrConvertTimeToTimespecTimeKHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrTime", "time", std::to_string(time));
        std::ostringstream oss_timespecTime;
        oss_timespecTime << (*timespecTime).tv_sec << ".";
        oss_timespecTime << std::setw(9) << std::setfill('0') << (*timespecTime).tv_nsec << "s";
        contents.emplace_back("struct timespec*", "timespecTime", oss_timespecTime.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ConvertTimeToTimespecTimeKHR(instance, time, timespecTime);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_TIMESPEC)

// ---- XR_KHR_loader_init extension commands

// ---- XR_KHR_vulkan_enable2 extension commands
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateVulkanInstanceKHR(
    XrInstance instance,
    const XrVulkanInstanceCreateInfoKHR* createInfo,
    VkInstance* vulkanInstance,
    VkResult* vulkanResult) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateVulkanInstanceKHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrVulkanInstanceCreateInfoKHR*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_vulkanInstance;
        oss_vulkanInstance << std::hex << reinterpret_cast<const void*>(vulkanInstance);
        contents.emplace_back("VkInstance*", "vulkanInstance", oss_vulkanInstance.str());
        std::ostringstream oss_vulkanResult;
        oss_vulkanResult << std::hex << reinterpret_cast<const void*>(vulkanResult);
        contents.emplace_back("VkResult*", "vulkanResult", oss_vulkanResult.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateVulkanInstanceKHR(instance, createInfo, vulkanInstance, vulkanResult);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateVulkanDeviceKHR(
    XrInstance instance,
    const XrVulkanDeviceCreateInfoKHR* createInfo,
    VkDevice* vulkanDevice,
    VkResult* vulkanResult) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateVulkanDeviceKHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrVulkanDeviceCreateInfoKHR*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_vulkanDevice;
        oss_vulkanDevice << std::hex << reinterpret_cast<const void*>(vulkanDevice);
        contents.emplace_back("VkDevice*", "vulkanDevice", oss_vulkanDevice.str());
        std::ostringstream oss_vulkanResult;
        oss_vulkanResult << std::hex << reinterpret_cast<const void*>(vulkanResult);
        contents.emplace_back("VkResult*", "vulkanResult", oss_vulkanResult.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateVulkanDeviceKHR(instance, createInfo, vulkanDevice, vulkanResult);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetVulkanGraphicsDevice2KHR(
    XrInstance instance,
    const XrVulkanGraphicsDeviceGetInfoKHR* getInfo,
    VkPhysicalDevice* vulkanPhysicalDevice) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetVulkanGraphicsDevice2KHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, getInfo, "getInfo", "const XrVulkanGraphicsDeviceGetInfoKHR*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_vulkanPhysicalDevice;
        oss_vulkanPhysicalDevice << std::hex << reinterpret_cast<const void*>(vulkanPhysicalDevice);
        contents.emplace_back("VkPhysicalDevice*", "vulkanPhysicalDevice", oss_vulkanPhysicalDevice.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetVulkanGraphicsDevice2KHR(instance, getInfo, vulkanPhysicalDevice);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetVulkanGraphicsRequirements2KHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsVulkanKHR* graphicsRequirements) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetVulkanGraphicsRequirements2KHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        std::ostringstream oss_graphicsRequirements;
        oss_graphicsRequirements << std::hex << reinterpret_cast<const void*>(graphicsRequirements);
        contents.emplace_back("XrGraphicsRequirementsVulkanKHR*", "graphicsRequirements", oss_graphicsRequirements.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetVulkanGraphicsRequirements2KHR(instance, systemId, graphicsRequirements);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

// ---- XR_KHR_extended_struct_name_lengths extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrStructureTypeToString2KHR(
    XrInstance instance,
    XrStructureType value,
    char buffer[XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR]) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrStructureTypeToString2KHR", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (nullptr != gen_dispatch_table) {
            char value_string[XR_MAX_STRUCTURE_NAME_SIZE] = {};
            gen_dispatch_table->StructureTypeToString(FindInstanceFromDispatchTable(gen_dispatch_table),
                                                      value, value_string);
            contents.emplace_back("XrStructureType", "value", value_string);
        } else {
                        contents.emplace_back("XrStructureType", "value", std::to_string(value));
        }
        contents.emplace_back("char*", "buffer", buffer);
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->StructureTypeToString2KHR(instance, value, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_KHR_locate_spaces extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrLocateSpacesKHR(
    XrSession session,
    const XrSpacesLocateInfo* locateInfo,
    XrSpaceLocations* spaceLocations) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrLocateSpacesKHR", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, locateInfo, "locateInfo", "const XrSpacesLocateInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_spaceLocations;
        oss_spaceLocations << std::hex << reinterpret_cast<const void*>(spaceLocations);
        contents.emplace_back("XrSpaceLocations*", "spaceLocations", oss_spaceLocations.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->LocateSpacesKHR(session, locateInfo, spaceLocations);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_EXT_performance_settings extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrPerfSettingsSetPerformanceLevelEXT(
    XrSession session,
    XrPerfSettingsDomainEXT domain,
    XrPerfSettingsLevelEXT level) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrPerfSettingsSetPerformanceLevelEXT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrPerfSettingsDomainEXT", "domain", std::to_string(domain));
        contents.emplace_back("XrPerfSettingsLevelEXT", "level", std::to_string(level));
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->PerfSettingsSetPerformanceLevelEXT(session, domain, level);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_EXT_thermal_query extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrThermalGetTemperatureTrendEXT(
    XrSession session,
    XrPerfSettingsDomainEXT domain,
    XrPerfSettingsNotificationLevelEXT* notificationLevel,
    float* tempHeadroom,
    float* tempSlope) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrThermalGetTemperatureTrendEXT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrPerfSettingsDomainEXT", "domain", std::to_string(domain));
        std::ostringstream oss_notificationLevel;
        oss_notificationLevel << std::hex << reinterpret_cast<const void*>(notificationLevel);
        contents.emplace_back("XrPerfSettingsNotificationLevelEXT*", "notificationLevel", oss_notificationLevel.str());
        std::ostringstream oss_tempHeadroom;
        oss_tempHeadroom << std::setprecision(32) << (tempHeadroom);
        contents.emplace_back("float*", "tempHeadroom", oss_tempHeadroom.str());
        std::ostringstream oss_tempSlope;
        oss_tempSlope << std::setprecision(32) << (tempSlope);
        contents.emplace_back("float*", "tempSlope", oss_tempSlope.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ThermalGetTemperatureTrendEXT(session, domain, notificationLevel, tempHeadroom, tempSlope);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_EXT_debug_utils extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetDebugUtilsObjectNameEXT(
    XrInstance instance,
    const XrDebugUtilsObjectNameInfoEXT* nameInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetDebugUtilsObjectNameEXT", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, nameInfo, "nameInfo", "const XrDebugUtilsObjectNameInfoEXT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetDebugUtilsObjectNameEXT(instance, nameInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateDebugUtilsMessengerEXT(
    XrInstance instance,
    const XrDebugUtilsMessengerCreateInfoEXT* createInfo,
    XrDebugUtilsMessengerEXT* messenger) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateDebugUtilsMessengerEXT", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrDebugUtilsMessengerCreateInfoEXT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_messenger;
        oss_messenger << std::hex << reinterpret_cast<const void*>(messenger);
        contents.emplace_back("XrDebugUtilsMessengerEXT*", "messenger", oss_messenger.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateDebugUtilsMessengerEXT(instance, createInfo, messenger);
        if (XR_SUCCESS == result && nullptr != messenger) {
            auto exists = g_debugutilsmessengerext_dispatch_map.find(*messenger);
            if (exists == g_debugutilsmessengerext_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_debugutilsmessengerext_dispatch_mutex);
                g_debugutilsmessengerext_dispatch_map[*messenger] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyDebugUtilsMessengerEXT(
    XrDebugUtilsMessengerEXT messenger) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_debugutilsmessengerext_dispatch_mutex);
            auto map_iter = g_debugutilsmessengerext_dispatch_map.find(messenger);
            if (map_iter == g_debugutilsmessengerext_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyDebugUtilsMessengerEXT", "");
        std::ostringstream oss_messenger;
        oss_messenger << std::hex << reinterpret_cast<const void*>(messenger);
        contents.emplace_back("XrDebugUtilsMessengerEXT", "messenger", oss_messenger.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyDebugUtilsMessengerEXT(messenger);
        auto exists = g_debugutilsmessengerext_dispatch_map.find(messenger);
        if (exists != g_debugutilsmessengerext_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_debugutilsmessengerext_dispatch_mutex);
            g_debugutilsmessengerext_dispatch_map.erase(messenger);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSubmitDebugUtilsMessageEXT(
    XrInstance instance,
    XrDebugUtilsMessageSeverityFlagsEXT messageSeverity,
    XrDebugUtilsMessageTypeFlagsEXT messageTypes,
    const XrDebugUtilsMessengerCallbackDataEXT* callbackData) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSubmitDebugUtilsMessageEXT", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrDebugUtilsMessageSeverityFlagsEXT", "messageSeverity", std::to_string(messageSeverity));
        contents.emplace_back("XrDebugUtilsMessageTypeFlagsEXT", "messageTypes", std::to_string(messageTypes));
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, callbackData, "callbackData", "const XrDebugUtilsMessengerCallbackDataEXT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, callbackData);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSessionBeginDebugUtilsLabelRegionEXT(
    XrSession session,
    const XrDebugUtilsLabelEXT* labelInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSessionBeginDebugUtilsLabelRegionEXT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, labelInfo, "labelInfo", "const XrDebugUtilsLabelEXT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SessionBeginDebugUtilsLabelRegionEXT(session, labelInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSessionEndDebugUtilsLabelRegionEXT(
    XrSession session) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSessionEndDebugUtilsLabelRegionEXT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SessionEndDebugUtilsLabelRegionEXT(session);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSessionInsertDebugUtilsLabelEXT(
    XrSession session,
    const XrDebugUtilsLabelEXT* labelInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSessionInsertDebugUtilsLabelEXT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, labelInfo, "labelInfo", "const XrDebugUtilsLabelEXT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SessionInsertDebugUtilsLabelEXT(session, labelInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_MSFT_spatial_anchor extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpatialAnchorMSFT(
    XrSession session,
    const XrSpatialAnchorCreateInfoMSFT* createInfo,
    XrSpatialAnchorMSFT* anchor) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpatialAnchorMSFT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrSpatialAnchorCreateInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(anchor);
        contents.emplace_back("XrSpatialAnchorMSFT*", "anchor", oss_anchor.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpatialAnchorMSFT(session, createInfo, anchor);
        if (XR_SUCCESS == result && nullptr != anchor) {
            auto exists = g_spatialanchormsft_dispatch_map.find(*anchor);
            if (exists == g_spatialanchormsft_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_spatialanchormsft_dispatch_mutex);
                g_spatialanchormsft_dispatch_map[*anchor] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpatialAnchorSpaceMSFT(
    XrSession session,
    const XrSpatialAnchorSpaceCreateInfoMSFT* createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpatialAnchorSpaceMSFT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrSpatialAnchorSpaceCreateInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace*", "space", oss_space.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpatialAnchorSpaceMSFT(session, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            auto exists = g_space_dispatch_map.find(*space);
            if (exists == g_space_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_space_dispatch_mutex);
                g_space_dispatch_map[*space] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroySpatialAnchorMSFT(
    XrSpatialAnchorMSFT anchor) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialanchormsft_dispatch_mutex);
            auto map_iter = g_spatialanchormsft_dispatch_map.find(anchor);
            if (map_iter == g_spatialanchormsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroySpatialAnchorMSFT", "");
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(anchor);
        contents.emplace_back("XrSpatialAnchorMSFT", "anchor", oss_anchor.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroySpatialAnchorMSFT(anchor);
        auto exists = g_spatialanchormsft_dispatch_map.find(anchor);
        if (exists != g_spatialanchormsft_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_spatialanchormsft_dispatch_mutex);
            g_spatialanchormsft_dispatch_map.erase(anchor);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_EXT_conformance_automation extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetInputDeviceActiveEXT(
    XrSession session,
    XrPath interactionProfile,
    XrPath topLevelPath,
    XrBool32 isActive) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetInputDeviceActiveEXT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrPath", "interactionProfile", std::to_string(interactionProfile));
        contents.emplace_back("XrPath", "topLevelPath", std::to_string(topLevelPath));
        std::ostringstream oss_isActive;
        oss_isActive << "0x" << std::hex << (isActive);
        contents.emplace_back("XrBool32", "isActive", oss_isActive.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetInputDeviceActiveEXT(session, interactionProfile, topLevelPath, isActive);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetInputDeviceStateBoolEXT(
    XrSession session,
    XrPath topLevelPath,
    XrPath inputSourcePath,
    XrBool32 state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetInputDeviceStateBoolEXT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrPath", "topLevelPath", std::to_string(topLevelPath));
        contents.emplace_back("XrPath", "inputSourcePath", std::to_string(inputSourcePath));
        std::ostringstream oss_state;
        oss_state << "0x" << std::hex << (state);
        contents.emplace_back("XrBool32", "state", oss_state.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetInputDeviceStateBoolEXT(session, topLevelPath, inputSourcePath, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetInputDeviceStateFloatEXT(
    XrSession session,
    XrPath topLevelPath,
    XrPath inputSourcePath,
    float state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetInputDeviceStateFloatEXT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrPath", "topLevelPath", std::to_string(topLevelPath));
        contents.emplace_back("XrPath", "inputSourcePath", std::to_string(inputSourcePath));
        std::ostringstream oss_state;
        oss_state << std::setprecision(32) << (state);
        contents.emplace_back("float", "state", oss_state.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetInputDeviceStateFloatEXT(session, topLevelPath, inputSourcePath, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetInputDeviceStateVector2fEXT(
    XrSession session,
    XrPath topLevelPath,
    XrPath inputSourcePath,
    XrVector2f state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetInputDeviceStateVector2fEXT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrPath", "topLevelPath", std::to_string(topLevelPath));
        contents.emplace_back("XrPath", "inputSourcePath", std::to_string(inputSourcePath));
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &state, "state", "XrVector2f", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetInputDeviceStateVector2fEXT(session, topLevelPath, inputSourcePath, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetInputDeviceLocationEXT(
    XrSession session,
    XrPath topLevelPath,
    XrPath inputSourcePath,
    XrSpace space,
    XrPosef pose) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetInputDeviceLocationEXT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrPath", "topLevelPath", std::to_string(topLevelPath));
        contents.emplace_back("XrPath", "inputSourcePath", std::to_string(inputSourcePath));
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace", "space", oss_space.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, &pose, "pose", "XrPosef", false, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetInputDeviceLocationEXT(session, topLevelPath, inputSourcePath, space, pose);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_MSFT_spatial_graph_bridge extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpatialGraphNodeSpaceMSFT(
    XrSession session,
    const XrSpatialGraphNodeSpaceCreateInfoMSFT* createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpatialGraphNodeSpaceMSFT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrSpatialGraphNodeSpaceCreateInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace*", "space", oss_space.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpatialGraphNodeSpaceMSFT(session, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            auto exists = g_space_dispatch_map.find(*space);
            if (exists == g_space_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_space_dispatch_mutex);
                g_space_dispatch_map[*space] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrTryCreateSpatialGraphStaticNodeBindingMSFT(
    XrSession session,
    const XrSpatialGraphStaticNodeBindingCreateInfoMSFT* createInfo,
    XrSpatialGraphNodeBindingMSFT* nodeBinding) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrTryCreateSpatialGraphStaticNodeBindingMSFT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrSpatialGraphStaticNodeBindingCreateInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_nodeBinding;
        oss_nodeBinding << std::hex << reinterpret_cast<const void*>(nodeBinding);
        contents.emplace_back("XrSpatialGraphNodeBindingMSFT*", "nodeBinding", oss_nodeBinding.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->TryCreateSpatialGraphStaticNodeBindingMSFT(session, createInfo, nodeBinding);
        if (XR_SUCCESS == result && nullptr != nodeBinding) {
            auto exists = g_spatialgraphnodebindingmsft_dispatch_map.find(*nodeBinding);
            if (exists == g_spatialgraphnodebindingmsft_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_spatialgraphnodebindingmsft_dispatch_mutex);
                g_spatialgraphnodebindingmsft_dispatch_map[*nodeBinding] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroySpatialGraphNodeBindingMSFT(
    XrSpatialGraphNodeBindingMSFT nodeBinding) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialgraphnodebindingmsft_dispatch_mutex);
            auto map_iter = g_spatialgraphnodebindingmsft_dispatch_map.find(nodeBinding);
            if (map_iter == g_spatialgraphnodebindingmsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroySpatialGraphNodeBindingMSFT", "");
        std::ostringstream oss_nodeBinding;
        oss_nodeBinding << std::hex << reinterpret_cast<const void*>(nodeBinding);
        contents.emplace_back("XrSpatialGraphNodeBindingMSFT", "nodeBinding", oss_nodeBinding.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroySpatialGraphNodeBindingMSFT(nodeBinding);
        auto exists = g_spatialgraphnodebindingmsft_dispatch_map.find(nodeBinding);
        if (exists != g_spatialgraphnodebindingmsft_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_spatialgraphnodebindingmsft_dispatch_mutex);
            g_spatialgraphnodebindingmsft_dispatch_map.erase(nodeBinding);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSpatialGraphNodeBindingPropertiesMSFT(
    XrSpatialGraphNodeBindingMSFT nodeBinding,
    const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT* getInfo,
    XrSpatialGraphNodeBindingPropertiesMSFT* properties) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialgraphnodebindingmsft_dispatch_mutex);
            auto map_iter = g_spatialgraphnodebindingmsft_dispatch_map.find(nodeBinding);
            if (map_iter == g_spatialgraphnodebindingmsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSpatialGraphNodeBindingPropertiesMSFT", "");
        std::ostringstream oss_nodeBinding;
        oss_nodeBinding << std::hex << reinterpret_cast<const void*>(nodeBinding);
        contents.emplace_back("XrSpatialGraphNodeBindingMSFT", "nodeBinding", oss_nodeBinding.str());
        if (nullptr == getInfo) {
            std::ostringstream oss_getInfo;
            oss_getInfo << std::hex << reinterpret_cast<const void*>(getInfo);
            contents.emplace_back("const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT*", "getInfo", oss_getInfo.str());
        } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, getInfo, "getInfo", "const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_properties;
        oss_properties << std::hex << reinterpret_cast<const void*>(properties);
        contents.emplace_back("XrSpatialGraphNodeBindingPropertiesMSFT*", "properties", oss_properties.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSpatialGraphNodeBindingPropertiesMSFT(nodeBinding, getInfo, properties);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_EXT_hand_tracking extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateHandTrackerEXT(
    XrSession session,
    const XrHandTrackerCreateInfoEXT* createInfo,
    XrHandTrackerEXT* handTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateHandTrackerEXT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrHandTrackerCreateInfoEXT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_handTracker;
        oss_handTracker << std::hex << reinterpret_cast<const void*>(handTracker);
        contents.emplace_back("XrHandTrackerEXT*", "handTracker", oss_handTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateHandTrackerEXT(session, createInfo, handTracker);
        if (XR_SUCCESS == result && nullptr != handTracker) {
            auto exists = g_handtrackerext_dispatch_map.find(*handTracker);
            if (exists == g_handtrackerext_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_handtrackerext_dispatch_mutex);
                g_handtrackerext_dispatch_map[*handTracker] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyHandTrackerEXT(
    XrHandTrackerEXT handTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_handtrackerext_dispatch_mutex);
            auto map_iter = g_handtrackerext_dispatch_map.find(handTracker);
            if (map_iter == g_handtrackerext_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyHandTrackerEXT", "");
        std::ostringstream oss_handTracker;
        oss_handTracker << std::hex << reinterpret_cast<const void*>(handTracker);
        contents.emplace_back("XrHandTrackerEXT", "handTracker", oss_handTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyHandTrackerEXT(handTracker);
        auto exists = g_handtrackerext_dispatch_map.find(handTracker);
        if (exists != g_handtrackerext_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_handtrackerext_dispatch_mutex);
            g_handtrackerext_dispatch_map.erase(handTracker);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrLocateHandJointsEXT(
    XrHandTrackerEXT handTracker,
    const XrHandJointsLocateInfoEXT* locateInfo,
    XrHandJointLocationsEXT* locations) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_handtrackerext_dispatch_mutex);
            auto map_iter = g_handtrackerext_dispatch_map.find(handTracker);
            if (map_iter == g_handtrackerext_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrLocateHandJointsEXT", "");
        std::ostringstream oss_handTracker;
        oss_handTracker << std::hex << reinterpret_cast<const void*>(handTracker);
        contents.emplace_back("XrHandTrackerEXT", "handTracker", oss_handTracker.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, locateInfo, "locateInfo", "const XrHandJointsLocateInfoEXT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_locations;
        oss_locations << std::hex << reinterpret_cast<const void*>(locations);
        contents.emplace_back("XrHandJointLocationsEXT*", "locations", oss_locations.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->LocateHandJointsEXT(handTracker, locateInfo, locations);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_MSFT_hand_tracking_mesh extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateHandMeshSpaceMSFT(
    XrHandTrackerEXT handTracker,
    const XrHandMeshSpaceCreateInfoMSFT* createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_handtrackerext_dispatch_mutex);
            auto map_iter = g_handtrackerext_dispatch_map.find(handTracker);
            if (map_iter == g_handtrackerext_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateHandMeshSpaceMSFT", "");
        std::ostringstream oss_handTracker;
        oss_handTracker << std::hex << reinterpret_cast<const void*>(handTracker);
        contents.emplace_back("XrHandTrackerEXT", "handTracker", oss_handTracker.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrHandMeshSpaceCreateInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace*", "space", oss_space.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateHandMeshSpaceMSFT(handTracker, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            auto exists = g_space_dispatch_map.find(*space);
            if (exists == g_space_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_space_dispatch_mutex);
                g_space_dispatch_map[*space] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrUpdateHandMeshMSFT(
    XrHandTrackerEXT handTracker,
    const XrHandMeshUpdateInfoMSFT* updateInfo,
    XrHandMeshMSFT* handMesh) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_handtrackerext_dispatch_mutex);
            auto map_iter = g_handtrackerext_dispatch_map.find(handTracker);
            if (map_iter == g_handtrackerext_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrUpdateHandMeshMSFT", "");
        std::ostringstream oss_handTracker;
        oss_handTracker << std::hex << reinterpret_cast<const void*>(handTracker);
        contents.emplace_back("XrHandTrackerEXT", "handTracker", oss_handTracker.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, updateInfo, "updateInfo", "const XrHandMeshUpdateInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_handMesh;
        oss_handMesh << std::hex << reinterpret_cast<const void*>(handMesh);
        contents.emplace_back("XrHandMeshMSFT*", "handMesh", oss_handMesh.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->UpdateHandMeshMSFT(handTracker, updateInfo, handMesh);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_MSFT_controller_model extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetControllerModelKeyMSFT(
    XrSession session,
    XrPath topLevelUserPath,
    XrControllerModelKeyStateMSFT* controllerModelKeyState) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetControllerModelKeyMSFT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrPath", "topLevelUserPath", std::to_string(topLevelUserPath));
        std::ostringstream oss_controllerModelKeyState;
        oss_controllerModelKeyState << std::hex << reinterpret_cast<const void*>(controllerModelKeyState);
        contents.emplace_back("XrControllerModelKeyStateMSFT*", "controllerModelKeyState", oss_controllerModelKeyState.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetControllerModelKeyMSFT(session, topLevelUserPath, controllerModelKeyState);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrLoadControllerModelMSFT(
    XrSession session,
    XrControllerModelKeyMSFT modelKey,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    uint8_t* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrLoadControllerModelMSFT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrControllerModelKeyMSFT", "modelKey", std::to_string(modelKey));
        std::ostringstream oss_bufferCapacityInput;
        oss_bufferCapacityInput << "0x" << std::hex << (bufferCapacityInput);
        contents.emplace_back("uint32_t", "bufferCapacityInput", oss_bufferCapacityInput.str());
        std::ostringstream oss_bufferCountOutput;
        oss_bufferCountOutput << std::hex << (bufferCountOutput);
        contents.emplace_back("uint32_t*", "bufferCountOutput", oss_bufferCountOutput.str());
        std::ostringstream oss_buffer;
        oss_buffer << "0x" << std::hex << (buffer);
        contents.emplace_back("uint8_t*", "buffer", oss_buffer.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->LoadControllerModelMSFT(session, modelKey, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetControllerModelPropertiesMSFT(
    XrSession session,
    XrControllerModelKeyMSFT modelKey,
    XrControllerModelPropertiesMSFT* properties) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetControllerModelPropertiesMSFT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrControllerModelKeyMSFT", "modelKey", std::to_string(modelKey));
        std::ostringstream oss_properties;
        oss_properties << std::hex << reinterpret_cast<const void*>(properties);
        contents.emplace_back("XrControllerModelPropertiesMSFT*", "properties", oss_properties.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetControllerModelPropertiesMSFT(session, modelKey, properties);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetControllerModelStateMSFT(
    XrSession session,
    XrControllerModelKeyMSFT modelKey,
    XrControllerModelStateMSFT* state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetControllerModelStateMSFT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrControllerModelKeyMSFT", "modelKey", std::to_string(modelKey));
        std::ostringstream oss_state;
        oss_state << std::hex << reinterpret_cast<const void*>(state);
        contents.emplace_back("XrControllerModelStateMSFT*", "state", oss_state.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetControllerModelStateMSFT(session, modelKey, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_MSFT_perception_anchor_interop extension commands
#if defined(XR_USE_PLATFORM_WIN32)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpatialAnchorFromPerceptionAnchorMSFT(
    XrSession session,
    IUnknown* perceptionAnchor,
    XrSpatialAnchorMSFT* anchor) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpatialAnchorFromPerceptionAnchorMSFT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_perceptionAnchor;
        oss_perceptionAnchor << std::hex << reinterpret_cast<const void*>(perceptionAnchor);
        contents.emplace_back("IUnknown*", "perceptionAnchor", oss_perceptionAnchor.str());
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(anchor);
        contents.emplace_back("XrSpatialAnchorMSFT*", "anchor", oss_anchor.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpatialAnchorFromPerceptionAnchorMSFT(session, perceptionAnchor, anchor);
        if (XR_SUCCESS == result && nullptr != anchor) {
            auto exists = g_spatialanchormsft_dispatch_map.find(*anchor);
            if (exists == g_spatialanchormsft_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_spatialanchormsft_dispatch_mutex);
                g_spatialanchormsft_dispatch_map[*anchor] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_PLATFORM_WIN32)
#if defined(XR_USE_PLATFORM_WIN32)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrTryGetPerceptionAnchorFromSpatialAnchorMSFT(
    XrSession session,
    XrSpatialAnchorMSFT anchor,
    IUnknown** perceptionAnchor) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrTryGetPerceptionAnchorFromSpatialAnchorMSFT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(anchor);
        contents.emplace_back("XrSpatialAnchorMSFT", "anchor", oss_anchor.str());
        std::ostringstream oss_perceptionAnchor;
        oss_perceptionAnchor << std::hex << reinterpret_cast<const void*>(perceptionAnchor);
        contents.emplace_back("IUnknown**", "perceptionAnchor", oss_perceptionAnchor.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->TryGetPerceptionAnchorFromSpatialAnchorMSFT(session, anchor, perceptionAnchor);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_PLATFORM_WIN32)

// ---- XR_MSFT_composition_layer_reprojection extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateReprojectionModesMSFT(
    XrInstance instance,
    XrSystemId systemId,
    XrViewConfigurationType viewConfigurationType,
    uint32_t modeCapacityInput,
    uint32_t* modeCountOutput,
    XrReprojectionModeMSFT* modes) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateReprojectionModesMSFT", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        contents.emplace_back("XrViewConfigurationType", "viewConfigurationType", std::to_string(viewConfigurationType));
        std::ostringstream oss_modeCapacityInput;
        oss_modeCapacityInput << "0x" << std::hex << (modeCapacityInput);
        contents.emplace_back("uint32_t", "modeCapacityInput", oss_modeCapacityInput.str());
        std::ostringstream oss_modeCountOutput;
        oss_modeCountOutput << std::hex << (modeCountOutput);
        contents.emplace_back("uint32_t*", "modeCountOutput", oss_modeCountOutput.str());
        std::ostringstream oss_modes;
        oss_modes << std::hex << reinterpret_cast<const void*>(modes);
        contents.emplace_back("XrReprojectionModeMSFT*", "modes", oss_modes.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateReprojectionModesMSFT(instance, systemId, viewConfigurationType, modeCapacityInput, modeCountOutput, modes);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_swapchain_update_state extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrUpdateSwapchainFB(
    XrSwapchain swapchain,
    const XrSwapchainStateBaseHeaderFB* state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_swapchain_dispatch_mutex);
            auto map_iter = g_swapchain_dispatch_map.find(swapchain);
            if (map_iter == g_swapchain_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrUpdateSwapchainFB", "");
        std::ostringstream oss_swapchain;
        oss_swapchain << std::hex << reinterpret_cast<const void*>(swapchain);
        contents.emplace_back("XrSwapchain", "swapchain", oss_swapchain.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, state, "state", "const XrSwapchainStateBaseHeaderFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->UpdateSwapchainFB(swapchain, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSwapchainStateFB(
    XrSwapchain swapchain,
    XrSwapchainStateBaseHeaderFB* state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_swapchain_dispatch_mutex);
            auto map_iter = g_swapchain_dispatch_map.find(swapchain);
            if (map_iter == g_swapchain_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSwapchainStateFB", "");
        std::ostringstream oss_swapchain;
        oss_swapchain << std::hex << reinterpret_cast<const void*>(swapchain);
        contents.emplace_back("XrSwapchain", "swapchain", oss_swapchain.str());
        std::ostringstream oss_state;
        oss_state << std::hex << reinterpret_cast<const void*>(state);
        contents.emplace_back("XrSwapchainStateBaseHeaderFB*", "state", oss_state.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSwapchainStateFB(swapchain, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_body_tracking extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateBodyTrackerFB(
    XrSession session,
    const XrBodyTrackerCreateInfoFB* createInfo,
    XrBodyTrackerFB* bodyTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateBodyTrackerFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrBodyTrackerCreateInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_bodyTracker;
        oss_bodyTracker << std::hex << reinterpret_cast<const void*>(bodyTracker);
        contents.emplace_back("XrBodyTrackerFB*", "bodyTracker", oss_bodyTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateBodyTrackerFB(session, createInfo, bodyTracker);
        if (XR_SUCCESS == result && nullptr != bodyTracker) {
            auto exists = g_bodytrackerfb_dispatch_map.find(*bodyTracker);
            if (exists == g_bodytrackerfb_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_bodytrackerfb_dispatch_mutex);
                g_bodytrackerfb_dispatch_map[*bodyTracker] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyBodyTrackerFB(
    XrBodyTrackerFB bodyTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_bodytrackerfb_dispatch_mutex);
            auto map_iter = g_bodytrackerfb_dispatch_map.find(bodyTracker);
            if (map_iter == g_bodytrackerfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyBodyTrackerFB", "");
        std::ostringstream oss_bodyTracker;
        oss_bodyTracker << std::hex << reinterpret_cast<const void*>(bodyTracker);
        contents.emplace_back("XrBodyTrackerFB", "bodyTracker", oss_bodyTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyBodyTrackerFB(bodyTracker);
        auto exists = g_bodytrackerfb_dispatch_map.find(bodyTracker);
        if (exists != g_bodytrackerfb_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_bodytrackerfb_dispatch_mutex);
            g_bodytrackerfb_dispatch_map.erase(bodyTracker);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrLocateBodyJointsFB(
    XrBodyTrackerFB bodyTracker,
    const XrBodyJointsLocateInfoFB* locateInfo,
    XrBodyJointLocationsFB* locations) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_bodytrackerfb_dispatch_mutex);
            auto map_iter = g_bodytrackerfb_dispatch_map.find(bodyTracker);
            if (map_iter == g_bodytrackerfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrLocateBodyJointsFB", "");
        std::ostringstream oss_bodyTracker;
        oss_bodyTracker << std::hex << reinterpret_cast<const void*>(bodyTracker);
        contents.emplace_back("XrBodyTrackerFB", "bodyTracker", oss_bodyTracker.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, locateInfo, "locateInfo", "const XrBodyJointsLocateInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_locations;
        oss_locations << std::hex << reinterpret_cast<const void*>(locations);
        contents.emplace_back("XrBodyJointLocationsFB*", "locations", oss_locations.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->LocateBodyJointsFB(bodyTracker, locateInfo, locations);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetBodySkeletonFB(
    XrBodyTrackerFB bodyTracker,
    XrBodySkeletonFB* skeleton) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_bodytrackerfb_dispatch_mutex);
            auto map_iter = g_bodytrackerfb_dispatch_map.find(bodyTracker);
            if (map_iter == g_bodytrackerfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetBodySkeletonFB", "");
        std::ostringstream oss_bodyTracker;
        oss_bodyTracker << std::hex << reinterpret_cast<const void*>(bodyTracker);
        contents.emplace_back("XrBodyTrackerFB", "bodyTracker", oss_bodyTracker.str());
        std::ostringstream oss_skeleton;
        oss_skeleton << std::hex << reinterpret_cast<const void*>(skeleton);
        contents.emplace_back("XrBodySkeletonFB*", "skeleton", oss_skeleton.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetBodySkeletonFB(bodyTracker, skeleton);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_MSFT_scene_understanding extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateSceneComputeFeaturesMSFT(
    XrInstance instance,
    XrSystemId systemId,
    uint32_t featureCapacityInput,
    uint32_t* featureCountOutput,
    XrSceneComputeFeatureMSFT* features) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateSceneComputeFeaturesMSFT", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        contents.emplace_back("XrSystemId", "systemId", std::to_string(systemId));
        std::ostringstream oss_featureCapacityInput;
        oss_featureCapacityInput << "0x" << std::hex << (featureCapacityInput);
        contents.emplace_back("uint32_t", "featureCapacityInput", oss_featureCapacityInput.str());
        std::ostringstream oss_featureCountOutput;
        oss_featureCountOutput << std::hex << (featureCountOutput);
        contents.emplace_back("uint32_t*", "featureCountOutput", oss_featureCountOutput.str());
        std::ostringstream oss_features;
        oss_features << std::hex << reinterpret_cast<const void*>(features);
        contents.emplace_back("XrSceneComputeFeatureMSFT*", "features", oss_features.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateSceneComputeFeaturesMSFT(instance, systemId, featureCapacityInput, featureCountOutput, features);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSceneObserverMSFT(
    XrSession session,
    const XrSceneObserverCreateInfoMSFT* createInfo,
    XrSceneObserverMSFT* sceneObserver) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSceneObserverMSFT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (nullptr == createInfo) {
            std::ostringstream oss_createInfo;
            oss_createInfo << std::hex << reinterpret_cast<const void*>(createInfo);
            contents.emplace_back("const XrSceneObserverCreateInfoMSFT*", "createInfo", oss_createInfo.str());
        } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrSceneObserverCreateInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_sceneObserver;
        oss_sceneObserver << std::hex << reinterpret_cast<const void*>(sceneObserver);
        contents.emplace_back("XrSceneObserverMSFT*", "sceneObserver", oss_sceneObserver.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSceneObserverMSFT(session, createInfo, sceneObserver);
        if (XR_SUCCESS == result && nullptr != sceneObserver) {
            auto exists = g_sceneobservermsft_dispatch_map.find(*sceneObserver);
            if (exists == g_sceneobservermsft_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_sceneobservermsft_dispatch_mutex);
                g_sceneobservermsft_dispatch_map[*sceneObserver] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroySceneObserverMSFT(
    XrSceneObserverMSFT sceneObserver) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sceneobservermsft_dispatch_mutex);
            auto map_iter = g_sceneobservermsft_dispatch_map.find(sceneObserver);
            if (map_iter == g_sceneobservermsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroySceneObserverMSFT", "");
        std::ostringstream oss_sceneObserver;
        oss_sceneObserver << std::hex << reinterpret_cast<const void*>(sceneObserver);
        contents.emplace_back("XrSceneObserverMSFT", "sceneObserver", oss_sceneObserver.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroySceneObserverMSFT(sceneObserver);
        auto exists = g_sceneobservermsft_dispatch_map.find(sceneObserver);
        if (exists != g_sceneobservermsft_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_sceneobservermsft_dispatch_mutex);
            g_sceneobservermsft_dispatch_map.erase(sceneObserver);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSceneMSFT(
    XrSceneObserverMSFT sceneObserver,
    const XrSceneCreateInfoMSFT* createInfo,
    XrSceneMSFT* scene) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sceneobservermsft_dispatch_mutex);
            auto map_iter = g_sceneobservermsft_dispatch_map.find(sceneObserver);
            if (map_iter == g_sceneobservermsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSceneMSFT", "");
        std::ostringstream oss_sceneObserver;
        oss_sceneObserver << std::hex << reinterpret_cast<const void*>(sceneObserver);
        contents.emplace_back("XrSceneObserverMSFT", "sceneObserver", oss_sceneObserver.str());
        if (nullptr == createInfo) {
            std::ostringstream oss_createInfo;
            oss_createInfo << std::hex << reinterpret_cast<const void*>(createInfo);
            contents.emplace_back("const XrSceneCreateInfoMSFT*", "createInfo", oss_createInfo.str());
        } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrSceneCreateInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_scene;
        oss_scene << std::hex << reinterpret_cast<const void*>(scene);
        contents.emplace_back("XrSceneMSFT*", "scene", oss_scene.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSceneMSFT(sceneObserver, createInfo, scene);
        if (XR_SUCCESS == result && nullptr != scene) {
            auto exists = g_scenemsft_dispatch_map.find(*scene);
            if (exists == g_scenemsft_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_scenemsft_dispatch_mutex);
                g_scenemsft_dispatch_map[*scene] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroySceneMSFT(
    XrSceneMSFT scene) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_scenemsft_dispatch_mutex);
            auto map_iter = g_scenemsft_dispatch_map.find(scene);
            if (map_iter == g_scenemsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroySceneMSFT", "");
        std::ostringstream oss_scene;
        oss_scene << std::hex << reinterpret_cast<const void*>(scene);
        contents.emplace_back("XrSceneMSFT", "scene", oss_scene.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroySceneMSFT(scene);
        auto exists = g_scenemsft_dispatch_map.find(scene);
        if (exists != g_scenemsft_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_scenemsft_dispatch_mutex);
            g_scenemsft_dispatch_map.erase(scene);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrComputeNewSceneMSFT(
    XrSceneObserverMSFT sceneObserver,
    const XrNewSceneComputeInfoMSFT* computeInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sceneobservermsft_dispatch_mutex);
            auto map_iter = g_sceneobservermsft_dispatch_map.find(sceneObserver);
            if (map_iter == g_sceneobservermsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrComputeNewSceneMSFT", "");
        std::ostringstream oss_sceneObserver;
        oss_sceneObserver << std::hex << reinterpret_cast<const void*>(sceneObserver);
        contents.emplace_back("XrSceneObserverMSFT", "sceneObserver", oss_sceneObserver.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, computeInfo, "computeInfo", "const XrNewSceneComputeInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ComputeNewSceneMSFT(sceneObserver, computeInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSceneComputeStateMSFT(
    XrSceneObserverMSFT sceneObserver,
    XrSceneComputeStateMSFT* state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sceneobservermsft_dispatch_mutex);
            auto map_iter = g_sceneobservermsft_dispatch_map.find(sceneObserver);
            if (map_iter == g_sceneobservermsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSceneComputeStateMSFT", "");
        std::ostringstream oss_sceneObserver;
        oss_sceneObserver << std::hex << reinterpret_cast<const void*>(sceneObserver);
        contents.emplace_back("XrSceneObserverMSFT", "sceneObserver", oss_sceneObserver.str());
        std::ostringstream oss_state;
        oss_state << std::hex << reinterpret_cast<const void*>(state);
        contents.emplace_back("XrSceneComputeStateMSFT*", "state", oss_state.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSceneComputeStateMSFT(sceneObserver, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSceneComponentsMSFT(
    XrSceneMSFT scene,
    const XrSceneComponentsGetInfoMSFT* getInfo,
    XrSceneComponentsMSFT* components) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_scenemsft_dispatch_mutex);
            auto map_iter = g_scenemsft_dispatch_map.find(scene);
            if (map_iter == g_scenemsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSceneComponentsMSFT", "");
        std::ostringstream oss_scene;
        oss_scene << std::hex << reinterpret_cast<const void*>(scene);
        contents.emplace_back("XrSceneMSFT", "scene", oss_scene.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, getInfo, "getInfo", "const XrSceneComponentsGetInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_components;
        oss_components << std::hex << reinterpret_cast<const void*>(components);
        contents.emplace_back("XrSceneComponentsMSFT*", "components", oss_components.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSceneComponentsMSFT(scene, getInfo, components);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrLocateSceneComponentsMSFT(
    XrSceneMSFT scene,
    const XrSceneComponentsLocateInfoMSFT* locateInfo,
    XrSceneComponentLocationsMSFT* locations) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_scenemsft_dispatch_mutex);
            auto map_iter = g_scenemsft_dispatch_map.find(scene);
            if (map_iter == g_scenemsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrLocateSceneComponentsMSFT", "");
        std::ostringstream oss_scene;
        oss_scene << std::hex << reinterpret_cast<const void*>(scene);
        contents.emplace_back("XrSceneMSFT", "scene", oss_scene.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, locateInfo, "locateInfo", "const XrSceneComponentsLocateInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_locations;
        oss_locations << std::hex << reinterpret_cast<const void*>(locations);
        contents.emplace_back("XrSceneComponentLocationsMSFT*", "locations", oss_locations.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->LocateSceneComponentsMSFT(scene, locateInfo, locations);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSceneMeshBuffersMSFT(
    XrSceneMSFT scene,
    const XrSceneMeshBuffersGetInfoMSFT* getInfo,
    XrSceneMeshBuffersMSFT* buffers) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_scenemsft_dispatch_mutex);
            auto map_iter = g_scenemsft_dispatch_map.find(scene);
            if (map_iter == g_scenemsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSceneMeshBuffersMSFT", "");
        std::ostringstream oss_scene;
        oss_scene << std::hex << reinterpret_cast<const void*>(scene);
        contents.emplace_back("XrSceneMSFT", "scene", oss_scene.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, getInfo, "getInfo", "const XrSceneMeshBuffersGetInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_buffers;
        oss_buffers << std::hex << reinterpret_cast<const void*>(buffers);
        contents.emplace_back("XrSceneMeshBuffersMSFT*", "buffers", oss_buffers.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSceneMeshBuffersMSFT(scene, getInfo, buffers);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_MSFT_scene_understanding_serialization extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDeserializeSceneMSFT(
    XrSceneObserverMSFT sceneObserver,
    const XrSceneDeserializeInfoMSFT* deserializeInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sceneobservermsft_dispatch_mutex);
            auto map_iter = g_sceneobservermsft_dispatch_map.find(sceneObserver);
            if (map_iter == g_sceneobservermsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDeserializeSceneMSFT", "");
        std::ostringstream oss_sceneObserver;
        oss_sceneObserver << std::hex << reinterpret_cast<const void*>(sceneObserver);
        contents.emplace_back("XrSceneObserverMSFT", "sceneObserver", oss_sceneObserver.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, deserializeInfo, "deserializeInfo", "const XrSceneDeserializeInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DeserializeSceneMSFT(sceneObserver, deserializeInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSerializedSceneFragmentDataMSFT(
    XrSceneMSFT scene,
    const XrSerializedSceneFragmentDataGetInfoMSFT* getInfo,
    uint32_t countInput,
    uint32_t* readOutput,
    uint8_t* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_scenemsft_dispatch_mutex);
            auto map_iter = g_scenemsft_dispatch_map.find(scene);
            if (map_iter == g_scenemsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSerializedSceneFragmentDataMSFT", "");
        std::ostringstream oss_scene;
        oss_scene << std::hex << reinterpret_cast<const void*>(scene);
        contents.emplace_back("XrSceneMSFT", "scene", oss_scene.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, getInfo, "getInfo", "const XrSerializedSceneFragmentDataGetInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_countInput;
        oss_countInput << "0x" << std::hex << (countInput);
        contents.emplace_back("uint32_t", "countInput", oss_countInput.str());
        std::ostringstream oss_readOutput;
        oss_readOutput << std::hex << (readOutput);
        contents.emplace_back("uint32_t*", "readOutput", oss_readOutput.str());
        std::ostringstream oss_buffer;
        oss_buffer << "0x" << std::hex << (buffer);
        contents.emplace_back("uint8_t*", "buffer", oss_buffer.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSerializedSceneFragmentDataMSFT(scene, getInfo, countInput, readOutput, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_display_refresh_rate extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateDisplayRefreshRatesFB(
    XrSession session,
    uint32_t displayRefreshRateCapacityInput,
    uint32_t* displayRefreshRateCountOutput,
    float* displayRefreshRates) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateDisplayRefreshRatesFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_displayRefreshRateCapacityInput;
        oss_displayRefreshRateCapacityInput << "0x" << std::hex << (displayRefreshRateCapacityInput);
        contents.emplace_back("uint32_t", "displayRefreshRateCapacityInput", oss_displayRefreshRateCapacityInput.str());
        std::ostringstream oss_displayRefreshRateCountOutput;
        oss_displayRefreshRateCountOutput << std::hex << (displayRefreshRateCountOutput);
        contents.emplace_back("uint32_t*", "displayRefreshRateCountOutput", oss_displayRefreshRateCountOutput.str());
        std::ostringstream oss_displayRefreshRates;
        oss_displayRefreshRates << std::setprecision(32) << (displayRefreshRates);
        contents.emplace_back("float*", "displayRefreshRates", oss_displayRefreshRates.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateDisplayRefreshRatesFB(session, displayRefreshRateCapacityInput, displayRefreshRateCountOutput, displayRefreshRates);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetDisplayRefreshRateFB(
    XrSession session,
    float* displayRefreshRate) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetDisplayRefreshRateFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_displayRefreshRate;
        oss_displayRefreshRate << std::setprecision(32) << (displayRefreshRate);
        contents.emplace_back("float*", "displayRefreshRate", oss_displayRefreshRate.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetDisplayRefreshRateFB(session, displayRefreshRate);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrRequestDisplayRefreshRateFB(
    XrSession session,
    float displayRefreshRate) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrRequestDisplayRefreshRateFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_displayRefreshRate;
        oss_displayRefreshRate << std::setprecision(32) << (displayRefreshRate);
        contents.emplace_back("float", "displayRefreshRate", oss_displayRefreshRate.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->RequestDisplayRefreshRateFB(session, displayRefreshRate);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_HTCX_vive_tracker_interaction extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateViveTrackerPathsHTCX(
    XrInstance instance,
    uint32_t pathCapacityInput,
    uint32_t* pathCountOutput,
    XrViveTrackerPathsHTCX* paths) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateViveTrackerPathsHTCX", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        std::ostringstream oss_pathCapacityInput;
        oss_pathCapacityInput << "0x" << std::hex << (pathCapacityInput);
        contents.emplace_back("uint32_t", "pathCapacityInput", oss_pathCapacityInput.str());
        std::ostringstream oss_pathCountOutput;
        oss_pathCountOutput << std::hex << (pathCountOutput);
        contents.emplace_back("uint32_t*", "pathCountOutput", oss_pathCountOutput.str());
        std::ostringstream oss_paths;
        oss_paths << std::hex << reinterpret_cast<const void*>(paths);
        contents.emplace_back("XrViveTrackerPathsHTCX*", "paths", oss_paths.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateViveTrackerPathsHTCX(instance, pathCapacityInput, pathCountOutput, paths);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_HTC_facial_tracking extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateFacialTrackerHTC(
    XrSession session,
    const XrFacialTrackerCreateInfoHTC* createInfo,
    XrFacialTrackerHTC* facialTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateFacialTrackerHTC", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrFacialTrackerCreateInfoHTC*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_facialTracker;
        oss_facialTracker << std::hex << reinterpret_cast<const void*>(facialTracker);
        contents.emplace_back("XrFacialTrackerHTC*", "facialTracker", oss_facialTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateFacialTrackerHTC(session, createInfo, facialTracker);
        if (XR_SUCCESS == result && nullptr != facialTracker) {
            auto exists = g_facialtrackerhtc_dispatch_map.find(*facialTracker);
            if (exists == g_facialtrackerhtc_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_facialtrackerhtc_dispatch_mutex);
                g_facialtrackerhtc_dispatch_map[*facialTracker] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyFacialTrackerHTC(
    XrFacialTrackerHTC facialTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_facialtrackerhtc_dispatch_mutex);
            auto map_iter = g_facialtrackerhtc_dispatch_map.find(facialTracker);
            if (map_iter == g_facialtrackerhtc_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyFacialTrackerHTC", "");
        std::ostringstream oss_facialTracker;
        oss_facialTracker << std::hex << reinterpret_cast<const void*>(facialTracker);
        contents.emplace_back("XrFacialTrackerHTC", "facialTracker", oss_facialTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyFacialTrackerHTC(facialTracker);
        auto exists = g_facialtrackerhtc_dispatch_map.find(facialTracker);
        if (exists != g_facialtrackerhtc_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_facialtrackerhtc_dispatch_mutex);
            g_facialtrackerhtc_dispatch_map.erase(facialTracker);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetFacialExpressionsHTC(
    XrFacialTrackerHTC facialTracker,
    XrFacialExpressionsHTC* facialExpressions) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_facialtrackerhtc_dispatch_mutex);
            auto map_iter = g_facialtrackerhtc_dispatch_map.find(facialTracker);
            if (map_iter == g_facialtrackerhtc_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetFacialExpressionsHTC", "");
        std::ostringstream oss_facialTracker;
        oss_facialTracker << std::hex << reinterpret_cast<const void*>(facialTracker);
        contents.emplace_back("XrFacialTrackerHTC", "facialTracker", oss_facialTracker.str());
        std::ostringstream oss_facialExpressions;
        oss_facialExpressions << std::hex << reinterpret_cast<const void*>(facialExpressions);
        contents.emplace_back("XrFacialExpressionsHTC*", "facialExpressions", oss_facialExpressions.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetFacialExpressionsHTC(facialTracker, facialExpressions);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_color_space extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateColorSpacesFB(
    XrSession session,
    uint32_t colorSpaceCapacityInput,
    uint32_t* colorSpaceCountOutput,
    XrColorSpaceFB* colorSpaces) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateColorSpacesFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_colorSpaceCapacityInput;
        oss_colorSpaceCapacityInput << "0x" << std::hex << (colorSpaceCapacityInput);
        contents.emplace_back("uint32_t", "colorSpaceCapacityInput", oss_colorSpaceCapacityInput.str());
        std::ostringstream oss_colorSpaceCountOutput;
        oss_colorSpaceCountOutput << std::hex << (colorSpaceCountOutput);
        contents.emplace_back("uint32_t*", "colorSpaceCountOutput", oss_colorSpaceCountOutput.str());
        std::ostringstream oss_colorSpaces;
        oss_colorSpaces << std::hex << reinterpret_cast<const void*>(colorSpaces);
        contents.emplace_back("XrColorSpaceFB*", "colorSpaces", oss_colorSpaces.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateColorSpacesFB(session, colorSpaceCapacityInput, colorSpaceCountOutput, colorSpaces);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetColorSpaceFB(
    XrSession session,
    const XrColorSpaceFB colorSpace) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetColorSpaceFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("const XrColorSpaceFB", "colorSpace", std::to_string(colorSpace));
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetColorSpaceFB(session, colorSpace);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_hand_tracking_mesh extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetHandMeshFB(
    XrHandTrackerEXT handTracker,
    XrHandTrackingMeshFB* mesh) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_handtrackerext_dispatch_mutex);
            auto map_iter = g_handtrackerext_dispatch_map.find(handTracker);
            if (map_iter == g_handtrackerext_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetHandMeshFB", "");
        std::ostringstream oss_handTracker;
        oss_handTracker << std::hex << reinterpret_cast<const void*>(handTracker);
        contents.emplace_back("XrHandTrackerEXT", "handTracker", oss_handTracker.str());
        std::ostringstream oss_mesh;
        oss_mesh << std::hex << reinterpret_cast<const void*>(mesh);
        contents.emplace_back("XrHandTrackingMeshFB*", "mesh", oss_mesh.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetHandMeshFB(handTracker, mesh);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_spatial_entity extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpatialAnchorFB(
    XrSession session,
    const XrSpatialAnchorCreateInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpatialAnchorFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSpatialAnchorCreateInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_requestId;
        oss_requestId << std::hex << reinterpret_cast<const void*>(requestId);
        contents.emplace_back("XrAsyncRequestIdFB*", "requestId", oss_requestId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpatialAnchorFB(session, info, requestId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSpaceUuidFB(
    XrSpace space,
    XrUuidEXT* uuid) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_space_dispatch_mutex);
            auto map_iter = g_space_dispatch_map.find(space);
            if (map_iter == g_space_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSpaceUuidFB", "");
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace", "space", oss_space.str());
        std::ostringstream oss_uuid;
        oss_uuid << std::hex << reinterpret_cast<const void*>(uuid);
        contents.emplace_back("XrUuidEXT*", "uuid", oss_uuid.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSpaceUuidFB(space, uuid);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateSpaceSupportedComponentsFB(
    XrSpace space,
    uint32_t componentTypeCapacityInput,
    uint32_t* componentTypeCountOutput,
    XrSpaceComponentTypeFB* componentTypes) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_space_dispatch_mutex);
            auto map_iter = g_space_dispatch_map.find(space);
            if (map_iter == g_space_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateSpaceSupportedComponentsFB", "");
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace", "space", oss_space.str());
        std::ostringstream oss_componentTypeCapacityInput;
        oss_componentTypeCapacityInput << "0x" << std::hex << (componentTypeCapacityInput);
        contents.emplace_back("uint32_t", "componentTypeCapacityInput", oss_componentTypeCapacityInput.str());
        std::ostringstream oss_componentTypeCountOutput;
        oss_componentTypeCountOutput << std::hex << (componentTypeCountOutput);
        contents.emplace_back("uint32_t*", "componentTypeCountOutput", oss_componentTypeCountOutput.str());
        std::ostringstream oss_componentTypes;
        oss_componentTypes << std::hex << reinterpret_cast<const void*>(componentTypes);
        contents.emplace_back("XrSpaceComponentTypeFB*", "componentTypes", oss_componentTypes.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateSpaceSupportedComponentsFB(space, componentTypeCapacityInput, componentTypeCountOutput, componentTypes);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetSpaceComponentStatusFB(
    XrSpace space,
    const XrSpaceComponentStatusSetInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_space_dispatch_mutex);
            auto map_iter = g_space_dispatch_map.find(space);
            if (map_iter == g_space_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetSpaceComponentStatusFB", "");
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace", "space", oss_space.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSpaceComponentStatusSetInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_requestId;
        oss_requestId << std::hex << reinterpret_cast<const void*>(requestId);
        contents.emplace_back("XrAsyncRequestIdFB*", "requestId", oss_requestId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetSpaceComponentStatusFB(space, info, requestId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSpaceComponentStatusFB(
    XrSpace space,
    XrSpaceComponentTypeFB componentType,
    XrSpaceComponentStatusFB* status) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_space_dispatch_mutex);
            auto map_iter = g_space_dispatch_map.find(space);
            if (map_iter == g_space_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSpaceComponentStatusFB", "");
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace", "space", oss_space.str());
        contents.emplace_back("XrSpaceComponentTypeFB", "componentType", std::to_string(componentType));
        std::ostringstream oss_status;
        oss_status << std::hex << reinterpret_cast<const void*>(status);
        contents.emplace_back("XrSpaceComponentStatusFB*", "status", oss_status.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSpaceComponentStatusFB(space, componentType, status);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_foveation extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateFoveationProfileFB(
    XrSession session,
    const XrFoveationProfileCreateInfoFB* createInfo,
    XrFoveationProfileFB* profile) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateFoveationProfileFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrFoveationProfileCreateInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_profile;
        oss_profile << std::hex << reinterpret_cast<const void*>(profile);
        contents.emplace_back("XrFoveationProfileFB*", "profile", oss_profile.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateFoveationProfileFB(session, createInfo, profile);
        if (XR_SUCCESS == result && nullptr != profile) {
            auto exists = g_foveationprofilefb_dispatch_map.find(*profile);
            if (exists == g_foveationprofilefb_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_foveationprofilefb_dispatch_mutex);
                g_foveationprofilefb_dispatch_map[*profile] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyFoveationProfileFB(
    XrFoveationProfileFB profile) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_foveationprofilefb_dispatch_mutex);
            auto map_iter = g_foveationprofilefb_dispatch_map.find(profile);
            if (map_iter == g_foveationprofilefb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyFoveationProfileFB", "");
        std::ostringstream oss_profile;
        oss_profile << std::hex << reinterpret_cast<const void*>(profile);
        contents.emplace_back("XrFoveationProfileFB", "profile", oss_profile.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyFoveationProfileFB(profile);
        auto exists = g_foveationprofilefb_dispatch_map.find(profile);
        if (exists != g_foveationprofilefb_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_foveationprofilefb_dispatch_mutex);
            g_foveationprofilefb_dispatch_map.erase(profile);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_keyboard_tracking extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrQuerySystemTrackedKeyboardFB(
    XrSession session,
    const XrKeyboardTrackingQueryFB* queryInfo,
    XrKeyboardTrackingDescriptionFB* keyboard) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrQuerySystemTrackedKeyboardFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, queryInfo, "queryInfo", "const XrKeyboardTrackingQueryFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(keyboard);
        contents.emplace_back("XrKeyboardTrackingDescriptionFB*", "keyboard", oss_keyboard.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->QuerySystemTrackedKeyboardFB(session, queryInfo, keyboard);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateKeyboardSpaceFB(
    XrSession session,
    const XrKeyboardSpaceCreateInfoFB* createInfo,
    XrSpace* keyboardSpace) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateKeyboardSpaceFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrKeyboardSpaceCreateInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_keyboardSpace;
        oss_keyboardSpace << std::hex << reinterpret_cast<const void*>(keyboardSpace);
        contents.emplace_back("XrSpace*", "keyboardSpace", oss_keyboardSpace.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateKeyboardSpaceFB(session, createInfo, keyboardSpace);
        if (XR_SUCCESS == result && nullptr != keyboardSpace) {
            auto exists = g_space_dispatch_map.find(*keyboardSpace);
            if (exists == g_space_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_space_dispatch_mutex);
                g_space_dispatch_map[*keyboardSpace] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_triangle_mesh extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateTriangleMeshFB(
    XrSession session,
    const XrTriangleMeshCreateInfoFB* createInfo,
    XrTriangleMeshFB* outTriangleMesh) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateTriangleMeshFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrTriangleMeshCreateInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_outTriangleMesh;
        oss_outTriangleMesh << std::hex << reinterpret_cast<const void*>(outTriangleMesh);
        contents.emplace_back("XrTriangleMeshFB*", "outTriangleMesh", oss_outTriangleMesh.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateTriangleMeshFB(session, createInfo, outTriangleMesh);
        if (XR_SUCCESS == result && nullptr != outTriangleMesh) {
            auto exists = g_trianglemeshfb_dispatch_map.find(*outTriangleMesh);
            if (exists == g_trianglemeshfb_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_trianglemeshfb_dispatch_mutex);
                g_trianglemeshfb_dispatch_map[*outTriangleMesh] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyTriangleMeshFB(
    XrTriangleMeshFB mesh) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_trianglemeshfb_dispatch_mutex);
            auto map_iter = g_trianglemeshfb_dispatch_map.find(mesh);
            if (map_iter == g_trianglemeshfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyTriangleMeshFB", "");
        std::ostringstream oss_mesh;
        oss_mesh << std::hex << reinterpret_cast<const void*>(mesh);
        contents.emplace_back("XrTriangleMeshFB", "mesh", oss_mesh.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyTriangleMeshFB(mesh);
        auto exists = g_trianglemeshfb_dispatch_map.find(mesh);
        if (exists != g_trianglemeshfb_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_trianglemeshfb_dispatch_mutex);
            g_trianglemeshfb_dispatch_map.erase(mesh);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrTriangleMeshGetVertexBufferFB(
    XrTriangleMeshFB mesh,
    XrVector3f** outVertexBuffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_trianglemeshfb_dispatch_mutex);
            auto map_iter = g_trianglemeshfb_dispatch_map.find(mesh);
            if (map_iter == g_trianglemeshfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrTriangleMeshGetVertexBufferFB", "");
        std::ostringstream oss_mesh;
        oss_mesh << std::hex << reinterpret_cast<const void*>(mesh);
        contents.emplace_back("XrTriangleMeshFB", "mesh", oss_mesh.str());
        std::ostringstream oss_outVertexBuffer;
        oss_outVertexBuffer << std::hex << reinterpret_cast<const void*>(outVertexBuffer);
        contents.emplace_back("XrVector3f**", "outVertexBuffer", oss_outVertexBuffer.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->TriangleMeshGetVertexBufferFB(mesh, outVertexBuffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrTriangleMeshGetIndexBufferFB(
    XrTriangleMeshFB mesh,
    uint32_t** outIndexBuffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_trianglemeshfb_dispatch_mutex);
            auto map_iter = g_trianglemeshfb_dispatch_map.find(mesh);
            if (map_iter == g_trianglemeshfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrTriangleMeshGetIndexBufferFB", "");
        std::ostringstream oss_mesh;
        oss_mesh << std::hex << reinterpret_cast<const void*>(mesh);
        contents.emplace_back("XrTriangleMeshFB", "mesh", oss_mesh.str());
        std::ostringstream oss_outIndexBuffer;
        oss_outIndexBuffer << std::hex << (outIndexBuffer);
        contents.emplace_back("uint32_t**", "outIndexBuffer", oss_outIndexBuffer.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->TriangleMeshGetIndexBufferFB(mesh, outIndexBuffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrTriangleMeshBeginUpdateFB(
    XrTriangleMeshFB mesh) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_trianglemeshfb_dispatch_mutex);
            auto map_iter = g_trianglemeshfb_dispatch_map.find(mesh);
            if (map_iter == g_trianglemeshfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrTriangleMeshBeginUpdateFB", "");
        std::ostringstream oss_mesh;
        oss_mesh << std::hex << reinterpret_cast<const void*>(mesh);
        contents.emplace_back("XrTriangleMeshFB", "mesh", oss_mesh.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->TriangleMeshBeginUpdateFB(mesh);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrTriangleMeshEndUpdateFB(
    XrTriangleMeshFB mesh,
    uint32_t vertexCount,
    uint32_t triangleCount) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_trianglemeshfb_dispatch_mutex);
            auto map_iter = g_trianglemeshfb_dispatch_map.find(mesh);
            if (map_iter == g_trianglemeshfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrTriangleMeshEndUpdateFB", "");
        std::ostringstream oss_mesh;
        oss_mesh << std::hex << reinterpret_cast<const void*>(mesh);
        contents.emplace_back("XrTriangleMeshFB", "mesh", oss_mesh.str());
        std::ostringstream oss_vertexCount;
        oss_vertexCount << "0x" << std::hex << (vertexCount);
        contents.emplace_back("uint32_t", "vertexCount", oss_vertexCount.str());
        std::ostringstream oss_triangleCount;
        oss_triangleCount << "0x" << std::hex << (triangleCount);
        contents.emplace_back("uint32_t", "triangleCount", oss_triangleCount.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->TriangleMeshEndUpdateFB(mesh, vertexCount, triangleCount);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrTriangleMeshBeginVertexBufferUpdateFB(
    XrTriangleMeshFB mesh,
    uint32_t* outVertexCount) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_trianglemeshfb_dispatch_mutex);
            auto map_iter = g_trianglemeshfb_dispatch_map.find(mesh);
            if (map_iter == g_trianglemeshfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrTriangleMeshBeginVertexBufferUpdateFB", "");
        std::ostringstream oss_mesh;
        oss_mesh << std::hex << reinterpret_cast<const void*>(mesh);
        contents.emplace_back("XrTriangleMeshFB", "mesh", oss_mesh.str());
        std::ostringstream oss_outVertexCount;
        oss_outVertexCount << std::hex << (outVertexCount);
        contents.emplace_back("uint32_t*", "outVertexCount", oss_outVertexCount.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->TriangleMeshBeginVertexBufferUpdateFB(mesh, outVertexCount);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrTriangleMeshEndVertexBufferUpdateFB(
    XrTriangleMeshFB mesh) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_trianglemeshfb_dispatch_mutex);
            auto map_iter = g_trianglemeshfb_dispatch_map.find(mesh);
            if (map_iter == g_trianglemeshfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrTriangleMeshEndVertexBufferUpdateFB", "");
        std::ostringstream oss_mesh;
        oss_mesh << std::hex << reinterpret_cast<const void*>(mesh);
        contents.emplace_back("XrTriangleMeshFB", "mesh", oss_mesh.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->TriangleMeshEndVertexBufferUpdateFB(mesh);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_passthrough extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreatePassthroughFB(
    XrSession session,
    const XrPassthroughCreateInfoFB* createInfo,
    XrPassthroughFB* outPassthrough) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreatePassthroughFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrPassthroughCreateInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_outPassthrough;
        oss_outPassthrough << std::hex << reinterpret_cast<const void*>(outPassthrough);
        contents.emplace_back("XrPassthroughFB*", "outPassthrough", oss_outPassthrough.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreatePassthroughFB(session, createInfo, outPassthrough);
        if (XR_SUCCESS == result && nullptr != outPassthrough) {
            auto exists = g_passthroughfb_dispatch_map.find(*outPassthrough);
            if (exists == g_passthroughfb_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_passthroughfb_dispatch_mutex);
                g_passthroughfb_dispatch_map[*outPassthrough] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyPassthroughFB(
    XrPassthroughFB passthrough) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_passthroughfb_dispatch_mutex);
            auto map_iter = g_passthroughfb_dispatch_map.find(passthrough);
            if (map_iter == g_passthroughfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyPassthroughFB", "");
        std::ostringstream oss_passthrough;
        oss_passthrough << std::hex << reinterpret_cast<const void*>(passthrough);
        contents.emplace_back("XrPassthroughFB", "passthrough", oss_passthrough.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyPassthroughFB(passthrough);
        auto exists = g_passthroughfb_dispatch_map.find(passthrough);
        if (exists != g_passthroughfb_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_passthroughfb_dispatch_mutex);
            g_passthroughfb_dispatch_map.erase(passthrough);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrPassthroughStartFB(
    XrPassthroughFB passthrough) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_passthroughfb_dispatch_mutex);
            auto map_iter = g_passthroughfb_dispatch_map.find(passthrough);
            if (map_iter == g_passthroughfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrPassthroughStartFB", "");
        std::ostringstream oss_passthrough;
        oss_passthrough << std::hex << reinterpret_cast<const void*>(passthrough);
        contents.emplace_back("XrPassthroughFB", "passthrough", oss_passthrough.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->PassthroughStartFB(passthrough);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrPassthroughPauseFB(
    XrPassthroughFB passthrough) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_passthroughfb_dispatch_mutex);
            auto map_iter = g_passthroughfb_dispatch_map.find(passthrough);
            if (map_iter == g_passthroughfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrPassthroughPauseFB", "");
        std::ostringstream oss_passthrough;
        oss_passthrough << std::hex << reinterpret_cast<const void*>(passthrough);
        contents.emplace_back("XrPassthroughFB", "passthrough", oss_passthrough.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->PassthroughPauseFB(passthrough);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreatePassthroughLayerFB(
    XrSession session,
    const XrPassthroughLayerCreateInfoFB* createInfo,
    XrPassthroughLayerFB* outLayer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreatePassthroughLayerFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrPassthroughLayerCreateInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_outLayer;
        oss_outLayer << std::hex << reinterpret_cast<const void*>(outLayer);
        contents.emplace_back("XrPassthroughLayerFB*", "outLayer", oss_outLayer.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreatePassthroughLayerFB(session, createInfo, outLayer);
        if (XR_SUCCESS == result && nullptr != outLayer) {
            auto exists = g_passthroughlayerfb_dispatch_map.find(*outLayer);
            if (exists == g_passthroughlayerfb_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_passthroughlayerfb_dispatch_mutex);
                g_passthroughlayerfb_dispatch_map[*outLayer] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyPassthroughLayerFB(
    XrPassthroughLayerFB layer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_passthroughlayerfb_dispatch_mutex);
            auto map_iter = g_passthroughlayerfb_dispatch_map.find(layer);
            if (map_iter == g_passthroughlayerfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyPassthroughLayerFB", "");
        std::ostringstream oss_layer;
        oss_layer << std::hex << reinterpret_cast<const void*>(layer);
        contents.emplace_back("XrPassthroughLayerFB", "layer", oss_layer.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyPassthroughLayerFB(layer);
        auto exists = g_passthroughlayerfb_dispatch_map.find(layer);
        if (exists != g_passthroughlayerfb_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_passthroughlayerfb_dispatch_mutex);
            g_passthroughlayerfb_dispatch_map.erase(layer);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrPassthroughLayerPauseFB(
    XrPassthroughLayerFB layer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_passthroughlayerfb_dispatch_mutex);
            auto map_iter = g_passthroughlayerfb_dispatch_map.find(layer);
            if (map_iter == g_passthroughlayerfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrPassthroughLayerPauseFB", "");
        std::ostringstream oss_layer;
        oss_layer << std::hex << reinterpret_cast<const void*>(layer);
        contents.emplace_back("XrPassthroughLayerFB", "layer", oss_layer.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->PassthroughLayerPauseFB(layer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrPassthroughLayerResumeFB(
    XrPassthroughLayerFB layer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_passthroughlayerfb_dispatch_mutex);
            auto map_iter = g_passthroughlayerfb_dispatch_map.find(layer);
            if (map_iter == g_passthroughlayerfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrPassthroughLayerResumeFB", "");
        std::ostringstream oss_layer;
        oss_layer << std::hex << reinterpret_cast<const void*>(layer);
        contents.emplace_back("XrPassthroughLayerFB", "layer", oss_layer.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->PassthroughLayerResumeFB(layer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrPassthroughLayerSetStyleFB(
    XrPassthroughLayerFB layer,
    const XrPassthroughStyleFB* style) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_passthroughlayerfb_dispatch_mutex);
            auto map_iter = g_passthroughlayerfb_dispatch_map.find(layer);
            if (map_iter == g_passthroughlayerfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrPassthroughLayerSetStyleFB", "");
        std::ostringstream oss_layer;
        oss_layer << std::hex << reinterpret_cast<const void*>(layer);
        contents.emplace_back("XrPassthroughLayerFB", "layer", oss_layer.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, style, "style", "const XrPassthroughStyleFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->PassthroughLayerSetStyleFB(layer, style);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateGeometryInstanceFB(
    XrSession session,
    const XrGeometryInstanceCreateInfoFB* createInfo,
    XrGeometryInstanceFB* outGeometryInstance) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateGeometryInstanceFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrGeometryInstanceCreateInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_outGeometryInstance;
        oss_outGeometryInstance << std::hex << reinterpret_cast<const void*>(outGeometryInstance);
        contents.emplace_back("XrGeometryInstanceFB*", "outGeometryInstance", oss_outGeometryInstance.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateGeometryInstanceFB(session, createInfo, outGeometryInstance);
        if (XR_SUCCESS == result && nullptr != outGeometryInstance) {
            auto exists = g_geometryinstancefb_dispatch_map.find(*outGeometryInstance);
            if (exists == g_geometryinstancefb_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_geometryinstancefb_dispatch_mutex);
                g_geometryinstancefb_dispatch_map[*outGeometryInstance] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyGeometryInstanceFB(
    XrGeometryInstanceFB instance) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_geometryinstancefb_dispatch_mutex);
            auto map_iter = g_geometryinstancefb_dispatch_map.find(instance);
            if (map_iter == g_geometryinstancefb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyGeometryInstanceFB", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrGeometryInstanceFB", "instance", oss_instance.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyGeometryInstanceFB(instance);
        auto exists = g_geometryinstancefb_dispatch_map.find(instance);
        if (exists != g_geometryinstancefb_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_geometryinstancefb_dispatch_mutex);
            g_geometryinstancefb_dispatch_map.erase(instance);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGeometryInstanceSetTransformFB(
    XrGeometryInstanceFB instance,
    const XrGeometryInstanceTransformFB* transformation) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_geometryinstancefb_dispatch_mutex);
            auto map_iter = g_geometryinstancefb_dispatch_map.find(instance);
            if (map_iter == g_geometryinstancefb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGeometryInstanceSetTransformFB", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrGeometryInstanceFB", "instance", oss_instance.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, transformation, "transformation", "const XrGeometryInstanceTransformFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GeometryInstanceSetTransformFB(instance, transformation);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_render_model extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateRenderModelPathsFB(
    XrSession session,
    uint32_t pathCapacityInput,
    uint32_t* pathCountOutput,
    XrRenderModelPathInfoFB* paths) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateRenderModelPathsFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_pathCapacityInput;
        oss_pathCapacityInput << "0x" << std::hex << (pathCapacityInput);
        contents.emplace_back("uint32_t", "pathCapacityInput", oss_pathCapacityInput.str());
        std::ostringstream oss_pathCountOutput;
        oss_pathCountOutput << std::hex << (pathCountOutput);
        contents.emplace_back("uint32_t*", "pathCountOutput", oss_pathCountOutput.str());
        std::ostringstream oss_paths;
        oss_paths << std::hex << reinterpret_cast<const void*>(paths);
        contents.emplace_back("XrRenderModelPathInfoFB*", "paths", oss_paths.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateRenderModelPathsFB(session, pathCapacityInput, pathCountOutput, paths);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetRenderModelPropertiesFB(
    XrSession session,
    XrPath path,
    XrRenderModelPropertiesFB* properties) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetRenderModelPropertiesFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrPath", "path", std::to_string(path));
        std::ostringstream oss_properties;
        oss_properties << std::hex << reinterpret_cast<const void*>(properties);
        contents.emplace_back("XrRenderModelPropertiesFB*", "properties", oss_properties.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetRenderModelPropertiesFB(session, path, properties);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrLoadRenderModelFB(
    XrSession session,
    const XrRenderModelLoadInfoFB* info,
    XrRenderModelBufferFB* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrLoadRenderModelFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrRenderModelLoadInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_buffer;
        oss_buffer << std::hex << reinterpret_cast<const void*>(buffer);
        contents.emplace_back("XrRenderModelBufferFB*", "buffer", oss_buffer.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->LoadRenderModelFB(session, info, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_VARJO_environment_depth_estimation extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetEnvironmentDepthEstimationVARJO(
    XrSession session,
    XrBool32 enabled) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetEnvironmentDepthEstimationVARJO", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_enabled;
        oss_enabled << "0x" << std::hex << (enabled);
        contents.emplace_back("XrBool32", "enabled", oss_enabled.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetEnvironmentDepthEstimationVARJO(session, enabled);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_VARJO_marker_tracking extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetMarkerTrackingVARJO(
    XrSession session,
    XrBool32 enabled) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetMarkerTrackingVARJO", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_enabled;
        oss_enabled << "0x" << std::hex << (enabled);
        contents.emplace_back("XrBool32", "enabled", oss_enabled.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetMarkerTrackingVARJO(session, enabled);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetMarkerTrackingTimeoutVARJO(
    XrSession session,
    uint64_t markerId,
    XrDuration timeout) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetMarkerTrackingTimeoutVARJO", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_markerId;
        oss_markerId << "0x" << std::hex << (markerId);
        contents.emplace_back("uint64_t", "markerId", oss_markerId.str());
        contents.emplace_back("XrDuration", "timeout", std::to_string(timeout));
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetMarkerTrackingTimeoutVARJO(session, markerId, timeout);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetMarkerTrackingPredictionVARJO(
    XrSession session,
    uint64_t markerId,
    XrBool32 enable) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetMarkerTrackingPredictionVARJO", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_markerId;
        oss_markerId << "0x" << std::hex << (markerId);
        contents.emplace_back("uint64_t", "markerId", oss_markerId.str());
        std::ostringstream oss_enable;
        oss_enable << "0x" << std::hex << (enable);
        contents.emplace_back("XrBool32", "enable", oss_enable.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetMarkerTrackingPredictionVARJO(session, markerId, enable);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetMarkerSizeVARJO(
    XrSession session,
    uint64_t markerId,
    XrExtent2Df* size) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetMarkerSizeVARJO", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_markerId;
        oss_markerId << "0x" << std::hex << (markerId);
        contents.emplace_back("uint64_t", "markerId", oss_markerId.str());
        std::ostringstream oss_size;
        oss_size << std::hex << reinterpret_cast<const void*>(size);
        contents.emplace_back("XrExtent2Df*", "size", oss_size.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetMarkerSizeVARJO(session, markerId, size);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateMarkerSpaceVARJO(
    XrSession session,
    const XrMarkerSpaceCreateInfoVARJO* createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateMarkerSpaceVARJO", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrMarkerSpaceCreateInfoVARJO*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace*", "space", oss_space.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateMarkerSpaceVARJO(session, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            auto exists = g_space_dispatch_map.find(*space);
            if (exists == g_space_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_space_dispatch_mutex);
                g_space_dispatch_map[*space] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_VARJO_view_offset extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetViewOffsetVARJO(
    XrSession session,
    float offset) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetViewOffsetVARJO", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_offset;
        oss_offset << std::setprecision(32) << (offset);
        contents.emplace_back("float", "offset", oss_offset.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetViewOffsetVARJO(session, offset);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_ML_compat extension commands
#if defined(XR_USE_PLATFORM_ML)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpaceFromCoordinateFrameUIDML(
    XrSession session,
    const XrCoordinateSpaceCreateInfoML *createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpaceFromCoordinateFrameUIDML", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrCoordinateSpaceCreateInfoML", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace*", "space", oss_space.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpaceFromCoordinateFrameUIDML(session, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            auto exists = g_space_dispatch_map.find(*space);
            if (exists == g_space_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_space_dispatch_mutex);
                g_space_dispatch_map[*space] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_PLATFORM_ML)

// ---- XR_ML_marker_understanding extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateMarkerDetectorML(
    XrSession session,
    const XrMarkerDetectorCreateInfoML* createInfo,
    XrMarkerDetectorML* markerDetector) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateMarkerDetectorML", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrMarkerDetectorCreateInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_markerDetector;
        oss_markerDetector << std::hex << reinterpret_cast<const void*>(markerDetector);
        contents.emplace_back("XrMarkerDetectorML*", "markerDetector", oss_markerDetector.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateMarkerDetectorML(session, createInfo, markerDetector);
        if (XR_SUCCESS == result && nullptr != markerDetector) {
            auto exists = g_markerdetectorml_dispatch_map.find(*markerDetector);
            if (exists == g_markerdetectorml_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_markerdetectorml_dispatch_mutex);
                g_markerdetectorml_dispatch_map[*markerDetector] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyMarkerDetectorML(
    XrMarkerDetectorML markerDetector) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_markerdetectorml_dispatch_mutex);
            auto map_iter = g_markerdetectorml_dispatch_map.find(markerDetector);
            if (map_iter == g_markerdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyMarkerDetectorML", "");
        std::ostringstream oss_markerDetector;
        oss_markerDetector << std::hex << reinterpret_cast<const void*>(markerDetector);
        contents.emplace_back("XrMarkerDetectorML", "markerDetector", oss_markerDetector.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyMarkerDetectorML(markerDetector);
        auto exists = g_markerdetectorml_dispatch_map.find(markerDetector);
        if (exists != g_markerdetectorml_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_markerdetectorml_dispatch_mutex);
            g_markerdetectorml_dispatch_map.erase(markerDetector);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSnapshotMarkerDetectorML(
    XrMarkerDetectorML markerDetector,
    XrMarkerDetectorSnapshotInfoML* snapshotInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_markerdetectorml_dispatch_mutex);
            auto map_iter = g_markerdetectorml_dispatch_map.find(markerDetector);
            if (map_iter == g_markerdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSnapshotMarkerDetectorML", "");
        std::ostringstream oss_markerDetector;
        oss_markerDetector << std::hex << reinterpret_cast<const void*>(markerDetector);
        contents.emplace_back("XrMarkerDetectorML", "markerDetector", oss_markerDetector.str());
        std::ostringstream oss_snapshotInfo;
        oss_snapshotInfo << std::hex << reinterpret_cast<const void*>(snapshotInfo);
        contents.emplace_back("XrMarkerDetectorSnapshotInfoML*", "snapshotInfo", oss_snapshotInfo.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SnapshotMarkerDetectorML(markerDetector, snapshotInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetMarkerDetectorStateML(
    XrMarkerDetectorML markerDetector,
    XrMarkerDetectorStateML* state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_markerdetectorml_dispatch_mutex);
            auto map_iter = g_markerdetectorml_dispatch_map.find(markerDetector);
            if (map_iter == g_markerdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetMarkerDetectorStateML", "");
        std::ostringstream oss_markerDetector;
        oss_markerDetector << std::hex << reinterpret_cast<const void*>(markerDetector);
        contents.emplace_back("XrMarkerDetectorML", "markerDetector", oss_markerDetector.str());
        std::ostringstream oss_state;
        oss_state << std::hex << reinterpret_cast<const void*>(state);
        contents.emplace_back("XrMarkerDetectorStateML*", "state", oss_state.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetMarkerDetectorStateML(markerDetector, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetMarkersML(
    XrMarkerDetectorML markerDetector,
    uint32_t markerCapacityInput,
    uint32_t* markerCountOutput,
    XrMarkerML* markers) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_markerdetectorml_dispatch_mutex);
            auto map_iter = g_markerdetectorml_dispatch_map.find(markerDetector);
            if (map_iter == g_markerdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetMarkersML", "");
        std::ostringstream oss_markerDetector;
        oss_markerDetector << std::hex << reinterpret_cast<const void*>(markerDetector);
        contents.emplace_back("XrMarkerDetectorML", "markerDetector", oss_markerDetector.str());
        std::ostringstream oss_markerCapacityInput;
        oss_markerCapacityInput << "0x" << std::hex << (markerCapacityInput);
        contents.emplace_back("uint32_t", "markerCapacityInput", oss_markerCapacityInput.str());
        std::ostringstream oss_markerCountOutput;
        oss_markerCountOutput << std::hex << (markerCountOutput);
        contents.emplace_back("uint32_t*", "markerCountOutput", oss_markerCountOutput.str());
        std::ostringstream oss_markers;
        oss_markers << std::hex << reinterpret_cast<const void*>(markers);
        contents.emplace_back("XrMarkerML*", "markers", oss_markers.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetMarkersML(markerDetector, markerCapacityInput, markerCountOutput, markers);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetMarkerReprojectionErrorML(
    XrMarkerDetectorML markerDetector,
    XrMarkerML marker,
    float* reprojectionErrorMeters) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_markerdetectorml_dispatch_mutex);
            auto map_iter = g_markerdetectorml_dispatch_map.find(markerDetector);
            if (map_iter == g_markerdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetMarkerReprojectionErrorML", "");
        std::ostringstream oss_markerDetector;
        oss_markerDetector << std::hex << reinterpret_cast<const void*>(markerDetector);
        contents.emplace_back("XrMarkerDetectorML", "markerDetector", oss_markerDetector.str());
        contents.emplace_back("XrMarkerML", "marker", std::to_string(marker));
        std::ostringstream oss_reprojectionErrorMeters;
        oss_reprojectionErrorMeters << std::setprecision(32) << (reprojectionErrorMeters);
        contents.emplace_back("float*", "reprojectionErrorMeters", oss_reprojectionErrorMeters.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetMarkerReprojectionErrorML(markerDetector, marker, reprojectionErrorMeters);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetMarkerLengthML(
    XrMarkerDetectorML markerDetector,
    XrMarkerML marker,
    float* meters) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_markerdetectorml_dispatch_mutex);
            auto map_iter = g_markerdetectorml_dispatch_map.find(markerDetector);
            if (map_iter == g_markerdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetMarkerLengthML", "");
        std::ostringstream oss_markerDetector;
        oss_markerDetector << std::hex << reinterpret_cast<const void*>(markerDetector);
        contents.emplace_back("XrMarkerDetectorML", "markerDetector", oss_markerDetector.str());
        contents.emplace_back("XrMarkerML", "marker", std::to_string(marker));
        std::ostringstream oss_meters;
        oss_meters << std::setprecision(32) << (meters);
        contents.emplace_back("float*", "meters", oss_meters.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetMarkerLengthML(markerDetector, marker, meters);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetMarkerNumberML(
    XrMarkerDetectorML markerDetector,
    XrMarkerML marker,
    uint64_t* number) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_markerdetectorml_dispatch_mutex);
            auto map_iter = g_markerdetectorml_dispatch_map.find(markerDetector);
            if (map_iter == g_markerdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetMarkerNumberML", "");
        std::ostringstream oss_markerDetector;
        oss_markerDetector << std::hex << reinterpret_cast<const void*>(markerDetector);
        contents.emplace_back("XrMarkerDetectorML", "markerDetector", oss_markerDetector.str());
        contents.emplace_back("XrMarkerML", "marker", std::to_string(marker));
        std::ostringstream oss_number;
        oss_number << std::hex << (number);
        contents.emplace_back("uint64_t*", "number", oss_number.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetMarkerNumberML(markerDetector, marker, number);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetMarkerStringML(
    XrMarkerDetectorML markerDetector,
    XrMarkerML marker,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_markerdetectorml_dispatch_mutex);
            auto map_iter = g_markerdetectorml_dispatch_map.find(markerDetector);
            if (map_iter == g_markerdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetMarkerStringML", "");
        std::ostringstream oss_markerDetector;
        oss_markerDetector << std::hex << reinterpret_cast<const void*>(markerDetector);
        contents.emplace_back("XrMarkerDetectorML", "markerDetector", oss_markerDetector.str());
        contents.emplace_back("XrMarkerML", "marker", std::to_string(marker));
        std::ostringstream oss_bufferCapacityInput;
        oss_bufferCapacityInput << "0x" << std::hex << (bufferCapacityInput);
        contents.emplace_back("uint32_t", "bufferCapacityInput", oss_bufferCapacityInput.str());
        std::ostringstream oss_bufferCountOutput;
        oss_bufferCountOutput << std::hex << (bufferCountOutput);
        contents.emplace_back("uint32_t*", "bufferCountOutput", oss_bufferCountOutput.str());
        contents.emplace_back("char*", "buffer", (buffer ? buffer : "(nullptr)"));
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetMarkerStringML(markerDetector, marker, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateMarkerSpaceML(
    XrSession session,
    const XrMarkerSpaceCreateInfoML* createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateMarkerSpaceML", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrMarkerSpaceCreateInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace*", "space", oss_space.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateMarkerSpaceML(session, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            auto exists = g_space_dispatch_map.find(*space);
            if (exists == g_space_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_space_dispatch_mutex);
                g_space_dispatch_map[*space] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_ML_localization_map extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnableLocalizationEventsML(
    XrSession session,
    const XrLocalizationEnableEventsInfoML * info) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnableLocalizationEventsML", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrLocalizationEnableEventsInfoML *", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnableLocalizationEventsML(session, info);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrQueryLocalizationMapsML(
    XrSession session,
    const XrLocalizationMapQueryInfoBaseHeaderML* queryInfo,
    uint32_t mapCapacityInput,
    uint32_t * mapCountOutput,
    XrLocalizationMapML* maps) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrQueryLocalizationMapsML", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (nullptr == queryInfo) {
            std::ostringstream oss_queryInfo;
            oss_queryInfo << std::hex << reinterpret_cast<const void*>(queryInfo);
            contents.emplace_back("const XrLocalizationMapQueryInfoBaseHeaderML*", "queryInfo", oss_queryInfo.str());
        } else if (!ApiDumpOutputXrStruct(gen_dispatch_table, queryInfo, "queryInfo", "const XrLocalizationMapQueryInfoBaseHeaderML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_mapCapacityInput;
        oss_mapCapacityInput << "0x" << std::hex << (mapCapacityInput);
        contents.emplace_back("uint32_t", "mapCapacityInput", oss_mapCapacityInput.str());
        std::ostringstream oss_mapCountOutput;
        oss_mapCountOutput << std::hex << (mapCountOutput);
        contents.emplace_back("uint32_t *", "mapCountOutput", oss_mapCountOutput.str());
        std::ostringstream oss_maps;
        oss_maps << std::hex << reinterpret_cast<const void*>(maps);
        contents.emplace_back("XrLocalizationMapML*", "maps", oss_maps.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->QueryLocalizationMapsML(session, queryInfo, mapCapacityInput, mapCountOutput, maps);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrRequestMapLocalizationML(
    XrSession session,
    const XrMapLocalizationRequestInfoML* requestInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrRequestMapLocalizationML", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, requestInfo, "requestInfo", "const XrMapLocalizationRequestInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->RequestMapLocalizationML(session, requestInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrImportLocalizationMapML(
    XrSession session,
    const XrLocalizationMapImportInfoML* importInfo,
    XrUuidEXT* mapUuid) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrImportLocalizationMapML", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, importInfo, "importInfo", "const XrLocalizationMapImportInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_mapUuid;
        oss_mapUuid << std::hex << reinterpret_cast<const void*>(mapUuid);
        contents.emplace_back("XrUuidEXT*", "mapUuid", oss_mapUuid.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ImportLocalizationMapML(session, importInfo, mapUuid);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateExportedLocalizationMapML(
    XrSession session,
    const XrUuidEXT* mapUuid,
    XrExportedLocalizationMapML* map) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateExportedLocalizationMapML", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, mapUuid, "mapUuid", "const XrUuidEXT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_map;
        oss_map << std::hex << reinterpret_cast<const void*>(map);
        contents.emplace_back("XrExportedLocalizationMapML*", "map", oss_map.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateExportedLocalizationMapML(session, mapUuid, map);
        if (XR_SUCCESS == result && nullptr != map) {
            auto exists = g_exportedlocalizationmapml_dispatch_map.find(*map);
            if (exists == g_exportedlocalizationmapml_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_exportedlocalizationmapml_dispatch_mutex);
                g_exportedlocalizationmapml_dispatch_map[*map] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyExportedLocalizationMapML(
    XrExportedLocalizationMapML map) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_exportedlocalizationmapml_dispatch_mutex);
            auto map_iter = g_exportedlocalizationmapml_dispatch_map.find(map);
            if (map_iter == g_exportedlocalizationmapml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyExportedLocalizationMapML", "");
        std::ostringstream oss_map;
        oss_map << std::hex << reinterpret_cast<const void*>(map);
        contents.emplace_back("XrExportedLocalizationMapML", "map", oss_map.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyExportedLocalizationMapML(map);
        auto exists = g_exportedlocalizationmapml_dispatch_map.find(map);
        if (exists != g_exportedlocalizationmapml_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_exportedlocalizationmapml_dispatch_mutex);
            g_exportedlocalizationmapml_dispatch_map.erase(map);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetExportedLocalizationMapDataML(
    XrExportedLocalizationMapML map,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_exportedlocalizationmapml_dispatch_mutex);
            auto map_iter = g_exportedlocalizationmapml_dispatch_map.find(map);
            if (map_iter == g_exportedlocalizationmapml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetExportedLocalizationMapDataML", "");
        std::ostringstream oss_map;
        oss_map << std::hex << reinterpret_cast<const void*>(map);
        contents.emplace_back("XrExportedLocalizationMapML", "map", oss_map.str());
        std::ostringstream oss_bufferCapacityInput;
        oss_bufferCapacityInput << "0x" << std::hex << (bufferCapacityInput);
        contents.emplace_back("uint32_t", "bufferCapacityInput", oss_bufferCapacityInput.str());
        std::ostringstream oss_bufferCountOutput;
        oss_bufferCountOutput << std::hex << (bufferCountOutput);
        contents.emplace_back("uint32_t*", "bufferCountOutput", oss_bufferCountOutput.str());
        contents.emplace_back("char*", "buffer", (buffer ? buffer : "(nullptr)"));
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetExportedLocalizationMapDataML(map, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_ML_spatial_anchors extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpatialAnchorsAsyncML(
    XrSession session,
    const XrSpatialAnchorsCreateInfoBaseHeaderML* createInfo,
    XrFutureEXT* future) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpatialAnchorsAsyncML", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrSpatialAnchorsCreateInfoBaseHeaderML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT*", "future", oss_future.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpatialAnchorsAsyncML(session, createInfo, future);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpatialAnchorsCompleteML(
    XrSession session,
    XrFutureEXT future,
    XrCreateSpatialAnchorsCompletionML* completion) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpatialAnchorsCompleteML", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT", "future", oss_future.str());
        std::ostringstream oss_completion;
        oss_completion << std::hex << reinterpret_cast<const void*>(completion);
        contents.emplace_back("XrCreateSpatialAnchorsCompletionML*", "completion", oss_completion.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpatialAnchorsCompleteML(session, future, completion);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSpatialAnchorStateML(
    XrSpace anchor,
    XrSpatialAnchorStateML* state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_space_dispatch_mutex);
            auto map_iter = g_space_dispatch_map.find(anchor);
            if (map_iter == g_space_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSpatialAnchorStateML", "");
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(anchor);
        contents.emplace_back("XrSpace", "anchor", oss_anchor.str());
        std::ostringstream oss_state;
        oss_state << std::hex << reinterpret_cast<const void*>(state);
        contents.emplace_back("XrSpatialAnchorStateML*", "state", oss_state.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSpatialAnchorStateML(anchor, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_ML_spatial_anchors_storage extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpatialAnchorsStorageML(
    XrSession session,
    const XrSpatialAnchorsCreateStorageInfoML* createInfo,
    XrSpatialAnchorsStorageML* storage) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpatialAnchorsStorageML", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrSpatialAnchorsCreateStorageInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_storage;
        oss_storage << std::hex << reinterpret_cast<const void*>(storage);
        contents.emplace_back("XrSpatialAnchorsStorageML*", "storage", oss_storage.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpatialAnchorsStorageML(session, createInfo, storage);
        if (XR_SUCCESS == result && nullptr != storage) {
            auto exists = g_spatialanchorsstorageml_dispatch_map.find(*storage);
            if (exists == g_spatialanchorsstorageml_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_spatialanchorsstorageml_dispatch_mutex);
                g_spatialanchorsstorageml_dispatch_map[*storage] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroySpatialAnchorsStorageML(
    XrSpatialAnchorsStorageML storage) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialanchorsstorageml_dispatch_mutex);
            auto map_iter = g_spatialanchorsstorageml_dispatch_map.find(storage);
            if (map_iter == g_spatialanchorsstorageml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroySpatialAnchorsStorageML", "");
        std::ostringstream oss_storage;
        oss_storage << std::hex << reinterpret_cast<const void*>(storage);
        contents.emplace_back("XrSpatialAnchorsStorageML", "storage", oss_storage.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroySpatialAnchorsStorageML(storage);
        auto exists = g_spatialanchorsstorageml_dispatch_map.find(storage);
        if (exists != g_spatialanchorsstorageml_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_spatialanchorsstorageml_dispatch_mutex);
            g_spatialanchorsstorageml_dispatch_map.erase(storage);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrQuerySpatialAnchorsAsyncML(
    XrSpatialAnchorsStorageML storage,
    const XrSpatialAnchorsQueryInfoBaseHeaderML* queryInfo,
    XrFutureEXT* future) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialanchorsstorageml_dispatch_mutex);
            auto map_iter = g_spatialanchorsstorageml_dispatch_map.find(storage);
            if (map_iter == g_spatialanchorsstorageml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrQuerySpatialAnchorsAsyncML", "");
        std::ostringstream oss_storage;
        oss_storage << std::hex << reinterpret_cast<const void*>(storage);
        contents.emplace_back("XrSpatialAnchorsStorageML", "storage", oss_storage.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, queryInfo, "queryInfo", "const XrSpatialAnchorsQueryInfoBaseHeaderML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT*", "future", oss_future.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->QuerySpatialAnchorsAsyncML(storage, queryInfo, future);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrQuerySpatialAnchorsCompleteML(
    XrSpatialAnchorsStorageML storage,
    XrFutureEXT future,
    XrSpatialAnchorsQueryCompletionML* completion) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialanchorsstorageml_dispatch_mutex);
            auto map_iter = g_spatialanchorsstorageml_dispatch_map.find(storage);
            if (map_iter == g_spatialanchorsstorageml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrQuerySpatialAnchorsCompleteML", "");
        std::ostringstream oss_storage;
        oss_storage << std::hex << reinterpret_cast<const void*>(storage);
        contents.emplace_back("XrSpatialAnchorsStorageML", "storage", oss_storage.str());
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT", "future", oss_future.str());
        std::ostringstream oss_completion;
        oss_completion << std::hex << reinterpret_cast<const void*>(completion);
        contents.emplace_back("XrSpatialAnchorsQueryCompletionML*", "completion", oss_completion.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->QuerySpatialAnchorsCompleteML(storage, future, completion);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrPublishSpatialAnchorsAsyncML(
    XrSpatialAnchorsStorageML storage,
    const XrSpatialAnchorsPublishInfoML* publishInfo,
    XrFutureEXT* future) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialanchorsstorageml_dispatch_mutex);
            auto map_iter = g_spatialanchorsstorageml_dispatch_map.find(storage);
            if (map_iter == g_spatialanchorsstorageml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrPublishSpatialAnchorsAsyncML", "");
        std::ostringstream oss_storage;
        oss_storage << std::hex << reinterpret_cast<const void*>(storage);
        contents.emplace_back("XrSpatialAnchorsStorageML", "storage", oss_storage.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, publishInfo, "publishInfo", "const XrSpatialAnchorsPublishInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT*", "future", oss_future.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->PublishSpatialAnchorsAsyncML(storage, publishInfo, future);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrPublishSpatialAnchorsCompleteML(
    XrSpatialAnchorsStorageML storage,
    XrFutureEXT future,
    XrSpatialAnchorsPublishCompletionML* completion) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialanchorsstorageml_dispatch_mutex);
            auto map_iter = g_spatialanchorsstorageml_dispatch_map.find(storage);
            if (map_iter == g_spatialanchorsstorageml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrPublishSpatialAnchorsCompleteML", "");
        std::ostringstream oss_storage;
        oss_storage << std::hex << reinterpret_cast<const void*>(storage);
        contents.emplace_back("XrSpatialAnchorsStorageML", "storage", oss_storage.str());
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT", "future", oss_future.str());
        std::ostringstream oss_completion;
        oss_completion << std::hex << reinterpret_cast<const void*>(completion);
        contents.emplace_back("XrSpatialAnchorsPublishCompletionML*", "completion", oss_completion.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->PublishSpatialAnchorsCompleteML(storage, future, completion);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDeleteSpatialAnchorsAsyncML(
    XrSpatialAnchorsStorageML storage,
    const XrSpatialAnchorsDeleteInfoML* deleteInfo,
    XrFutureEXT* future) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialanchorsstorageml_dispatch_mutex);
            auto map_iter = g_spatialanchorsstorageml_dispatch_map.find(storage);
            if (map_iter == g_spatialanchorsstorageml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDeleteSpatialAnchorsAsyncML", "");
        std::ostringstream oss_storage;
        oss_storage << std::hex << reinterpret_cast<const void*>(storage);
        contents.emplace_back("XrSpatialAnchorsStorageML", "storage", oss_storage.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, deleteInfo, "deleteInfo", "const XrSpatialAnchorsDeleteInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT*", "future", oss_future.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DeleteSpatialAnchorsAsyncML(storage, deleteInfo, future);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDeleteSpatialAnchorsCompleteML(
    XrSpatialAnchorsStorageML storage,
    XrFutureEXT future,
    XrSpatialAnchorsDeleteCompletionML* completion) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialanchorsstorageml_dispatch_mutex);
            auto map_iter = g_spatialanchorsstorageml_dispatch_map.find(storage);
            if (map_iter == g_spatialanchorsstorageml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDeleteSpatialAnchorsCompleteML", "");
        std::ostringstream oss_storage;
        oss_storage << std::hex << reinterpret_cast<const void*>(storage);
        contents.emplace_back("XrSpatialAnchorsStorageML", "storage", oss_storage.str());
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT", "future", oss_future.str());
        std::ostringstream oss_completion;
        oss_completion << std::hex << reinterpret_cast<const void*>(completion);
        contents.emplace_back("XrSpatialAnchorsDeleteCompletionML*", "completion", oss_completion.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DeleteSpatialAnchorsCompleteML(storage, future, completion);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrUpdateSpatialAnchorsExpirationAsyncML(
    XrSpatialAnchorsStorageML storage,
    const XrSpatialAnchorsUpdateExpirationInfoML* updateInfo,
    XrFutureEXT* future) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialanchorsstorageml_dispatch_mutex);
            auto map_iter = g_spatialanchorsstorageml_dispatch_map.find(storage);
            if (map_iter == g_spatialanchorsstorageml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrUpdateSpatialAnchorsExpirationAsyncML", "");
        std::ostringstream oss_storage;
        oss_storage << std::hex << reinterpret_cast<const void*>(storage);
        contents.emplace_back("XrSpatialAnchorsStorageML", "storage", oss_storage.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, updateInfo, "updateInfo", "const XrSpatialAnchorsUpdateExpirationInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT*", "future", oss_future.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->UpdateSpatialAnchorsExpirationAsyncML(storage, updateInfo, future);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrUpdateSpatialAnchorsExpirationCompleteML(
    XrSpatialAnchorsStorageML storage,
    XrFutureEXT future,
    XrSpatialAnchorsUpdateExpirationCompletionML* completion) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialanchorsstorageml_dispatch_mutex);
            auto map_iter = g_spatialanchorsstorageml_dispatch_map.find(storage);
            if (map_iter == g_spatialanchorsstorageml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrUpdateSpatialAnchorsExpirationCompleteML", "");
        std::ostringstream oss_storage;
        oss_storage << std::hex << reinterpret_cast<const void*>(storage);
        contents.emplace_back("XrSpatialAnchorsStorageML", "storage", oss_storage.str());
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT", "future", oss_future.str());
        std::ostringstream oss_completion;
        oss_completion << std::hex << reinterpret_cast<const void*>(completion);
        contents.emplace_back("XrSpatialAnchorsUpdateExpirationCompletionML*", "completion", oss_completion.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->UpdateSpatialAnchorsExpirationCompleteML(storage, future, completion);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_MSFT_spatial_anchor_persistence extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpatialAnchorStoreConnectionMSFT(
    XrSession session,
    XrSpatialAnchorStoreConnectionMSFT* spatialAnchorStore) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpatialAnchorStoreConnectionMSFT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_spatialAnchorStore;
        oss_spatialAnchorStore << std::hex << reinterpret_cast<const void*>(spatialAnchorStore);
        contents.emplace_back("XrSpatialAnchorStoreConnectionMSFT*", "spatialAnchorStore", oss_spatialAnchorStore.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpatialAnchorStoreConnectionMSFT(session, spatialAnchorStore);
        if (XR_SUCCESS == result && nullptr != spatialAnchorStore) {
            auto exists = g_spatialanchorstoreconnectionmsft_dispatch_map.find(*spatialAnchorStore);
            if (exists == g_spatialanchorstoreconnectionmsft_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_spatialanchorstoreconnectionmsft_dispatch_mutex);
                g_spatialanchorstoreconnectionmsft_dispatch_map[*spatialAnchorStore] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroySpatialAnchorStoreConnectionMSFT(
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialanchorstoreconnectionmsft_dispatch_mutex);
            auto map_iter = g_spatialanchorstoreconnectionmsft_dispatch_map.find(spatialAnchorStore);
            if (map_iter == g_spatialanchorstoreconnectionmsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroySpatialAnchorStoreConnectionMSFT", "");
        std::ostringstream oss_spatialAnchorStore;
        oss_spatialAnchorStore << std::hex << reinterpret_cast<const void*>(spatialAnchorStore);
        contents.emplace_back("XrSpatialAnchorStoreConnectionMSFT", "spatialAnchorStore", oss_spatialAnchorStore.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroySpatialAnchorStoreConnectionMSFT(spatialAnchorStore);
        auto exists = g_spatialanchorstoreconnectionmsft_dispatch_map.find(spatialAnchorStore);
        if (exists != g_spatialanchorstoreconnectionmsft_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_spatialanchorstoreconnectionmsft_dispatch_mutex);
            g_spatialanchorstoreconnectionmsft_dispatch_map.erase(spatialAnchorStore);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrPersistSpatialAnchorMSFT(
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore,
    const XrSpatialAnchorPersistenceInfoMSFT* spatialAnchorPersistenceInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialanchorstoreconnectionmsft_dispatch_mutex);
            auto map_iter = g_spatialanchorstoreconnectionmsft_dispatch_map.find(spatialAnchorStore);
            if (map_iter == g_spatialanchorstoreconnectionmsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrPersistSpatialAnchorMSFT", "");
        std::ostringstream oss_spatialAnchorStore;
        oss_spatialAnchorStore << std::hex << reinterpret_cast<const void*>(spatialAnchorStore);
        contents.emplace_back("XrSpatialAnchorStoreConnectionMSFT", "spatialAnchorStore", oss_spatialAnchorStore.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, spatialAnchorPersistenceInfo, "spatialAnchorPersistenceInfo", "const XrSpatialAnchorPersistenceInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->PersistSpatialAnchorMSFT(spatialAnchorStore, spatialAnchorPersistenceInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumeratePersistedSpatialAnchorNamesMSFT(
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore,
    uint32_t spatialAnchorNameCapacityInput,
    uint32_t* spatialAnchorNameCountOutput,
    XrSpatialAnchorPersistenceNameMSFT* spatialAnchorNames) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialanchorstoreconnectionmsft_dispatch_mutex);
            auto map_iter = g_spatialanchorstoreconnectionmsft_dispatch_map.find(spatialAnchorStore);
            if (map_iter == g_spatialanchorstoreconnectionmsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumeratePersistedSpatialAnchorNamesMSFT", "");
        std::ostringstream oss_spatialAnchorStore;
        oss_spatialAnchorStore << std::hex << reinterpret_cast<const void*>(spatialAnchorStore);
        contents.emplace_back("XrSpatialAnchorStoreConnectionMSFT", "spatialAnchorStore", oss_spatialAnchorStore.str());
        std::ostringstream oss_spatialAnchorNameCapacityInput;
        oss_spatialAnchorNameCapacityInput << "0x" << std::hex << (spatialAnchorNameCapacityInput);
        contents.emplace_back("uint32_t", "spatialAnchorNameCapacityInput", oss_spatialAnchorNameCapacityInput.str());
        std::ostringstream oss_spatialAnchorNameCountOutput;
        oss_spatialAnchorNameCountOutput << std::hex << (spatialAnchorNameCountOutput);
        contents.emplace_back("uint32_t*", "spatialAnchorNameCountOutput", oss_spatialAnchorNameCountOutput.str());
        std::ostringstream oss_spatialAnchorNames;
        oss_spatialAnchorNames << std::hex << reinterpret_cast<const void*>(spatialAnchorNames);
        contents.emplace_back("XrSpatialAnchorPersistenceNameMSFT*", "spatialAnchorNames", oss_spatialAnchorNames.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumeratePersistedSpatialAnchorNamesMSFT(spatialAnchorStore, spatialAnchorNameCapacityInput, spatialAnchorNameCountOutput, spatialAnchorNames);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpatialAnchorFromPersistedNameMSFT(
    XrSession session,
    const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT* spatialAnchorCreateInfo,
    XrSpatialAnchorMSFT* spatialAnchor) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpatialAnchorFromPersistedNameMSFT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, spatialAnchorCreateInfo, "spatialAnchorCreateInfo", "const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_spatialAnchor;
        oss_spatialAnchor << std::hex << reinterpret_cast<const void*>(spatialAnchor);
        contents.emplace_back("XrSpatialAnchorMSFT*", "spatialAnchor", oss_spatialAnchor.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpatialAnchorFromPersistedNameMSFT(session, spatialAnchorCreateInfo, spatialAnchor);
        if (XR_SUCCESS == result && nullptr != spatialAnchor) {
            auto exists = g_spatialanchormsft_dispatch_map.find(*spatialAnchor);
            if (exists == g_spatialanchormsft_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_spatialanchormsft_dispatch_mutex);
                g_spatialanchormsft_dispatch_map[*spatialAnchor] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrUnpersistSpatialAnchorMSFT(
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore,
    const XrSpatialAnchorPersistenceNameMSFT* spatialAnchorPersistenceName) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialanchorstoreconnectionmsft_dispatch_mutex);
            auto map_iter = g_spatialanchorstoreconnectionmsft_dispatch_map.find(spatialAnchorStore);
            if (map_iter == g_spatialanchorstoreconnectionmsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrUnpersistSpatialAnchorMSFT", "");
        std::ostringstream oss_spatialAnchorStore;
        oss_spatialAnchorStore << std::hex << reinterpret_cast<const void*>(spatialAnchorStore);
        contents.emplace_back("XrSpatialAnchorStoreConnectionMSFT", "spatialAnchorStore", oss_spatialAnchorStore.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, spatialAnchorPersistenceName, "spatialAnchorPersistenceName", "const XrSpatialAnchorPersistenceNameMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->UnpersistSpatialAnchorMSFT(spatialAnchorStore, spatialAnchorPersistenceName);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrClearSpatialAnchorStoreMSFT(
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spatialanchorstoreconnectionmsft_dispatch_mutex);
            auto map_iter = g_spatialanchorstoreconnectionmsft_dispatch_map.find(spatialAnchorStore);
            if (map_iter == g_spatialanchorstoreconnectionmsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrClearSpatialAnchorStoreMSFT", "");
        std::ostringstream oss_spatialAnchorStore;
        oss_spatialAnchorStore << std::hex << reinterpret_cast<const void*>(spatialAnchorStore);
        contents.emplace_back("XrSpatialAnchorStoreConnectionMSFT", "spatialAnchorStore", oss_spatialAnchorStore.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ClearSpatialAnchorStoreMSFT(spatialAnchorStore);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_MSFT_scene_marker extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSceneMarkerRawDataMSFT(
    XrSceneMSFT scene,
    const XrUuidMSFT* markerId,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    uint8_t* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_scenemsft_dispatch_mutex);
            auto map_iter = g_scenemsft_dispatch_map.find(scene);
            if (map_iter == g_scenemsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSceneMarkerRawDataMSFT", "");
        std::ostringstream oss_scene;
        oss_scene << std::hex << reinterpret_cast<const void*>(scene);
        contents.emplace_back("XrSceneMSFT", "scene", oss_scene.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, markerId, "markerId", "const XrUuidMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_bufferCapacityInput;
        oss_bufferCapacityInput << "0x" << std::hex << (bufferCapacityInput);
        contents.emplace_back("uint32_t", "bufferCapacityInput", oss_bufferCapacityInput.str());
        std::ostringstream oss_bufferCountOutput;
        oss_bufferCountOutput << std::hex << (bufferCountOutput);
        contents.emplace_back("uint32_t*", "bufferCountOutput", oss_bufferCountOutput.str());
        std::ostringstream oss_buffer;
        oss_buffer << "0x" << std::hex << (buffer);
        contents.emplace_back("uint8_t*", "buffer", oss_buffer.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSceneMarkerRawDataMSFT(scene, markerId, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSceneMarkerDecodedStringMSFT(
    XrSceneMSFT scene,
    const XrUuidMSFT* markerId,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_scenemsft_dispatch_mutex);
            auto map_iter = g_scenemsft_dispatch_map.find(scene);
            if (map_iter == g_scenemsft_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSceneMarkerDecodedStringMSFT", "");
        std::ostringstream oss_scene;
        oss_scene << std::hex << reinterpret_cast<const void*>(scene);
        contents.emplace_back("XrSceneMSFT", "scene", oss_scene.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, markerId, "markerId", "const XrUuidMSFT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_bufferCapacityInput;
        oss_bufferCapacityInput << "0x" << std::hex << (bufferCapacityInput);
        contents.emplace_back("uint32_t", "bufferCapacityInput", oss_bufferCapacityInput.str());
        std::ostringstream oss_bufferCountOutput;
        oss_bufferCountOutput << std::hex << (bufferCountOutput);
        contents.emplace_back("uint32_t*", "bufferCountOutput", oss_bufferCountOutput.str());
        contents.emplace_back("char*", "buffer", (buffer ? buffer : "(nullptr)"));
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSceneMarkerDecodedStringMSFT(scene, markerId, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_spatial_entity_query extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrQuerySpacesFB(
    XrSession session,
    const XrSpaceQueryInfoBaseHeaderFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrQuerySpacesFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSpaceQueryInfoBaseHeaderFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_requestId;
        oss_requestId << std::hex << reinterpret_cast<const void*>(requestId);
        contents.emplace_back("XrAsyncRequestIdFB*", "requestId", oss_requestId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->QuerySpacesFB(session, info, requestId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrRetrieveSpaceQueryResultsFB(
    XrSession session,
    XrAsyncRequestIdFB requestId,
    XrSpaceQueryResultsFB* results) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrRetrieveSpaceQueryResultsFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrAsyncRequestIdFB", "requestId", std::to_string(requestId));
        std::ostringstream oss_results;
        oss_results << std::hex << reinterpret_cast<const void*>(results);
        contents.emplace_back("XrSpaceQueryResultsFB*", "results", oss_results.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->RetrieveSpaceQueryResultsFB(session, requestId, results);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_spatial_entity_storage extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSaveSpaceFB(
    XrSession session,
    const XrSpaceSaveInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSaveSpaceFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSpaceSaveInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_requestId;
        oss_requestId << std::hex << reinterpret_cast<const void*>(requestId);
        contents.emplace_back("XrAsyncRequestIdFB*", "requestId", oss_requestId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SaveSpaceFB(session, info, requestId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEraseSpaceFB(
    XrSession session,
    const XrSpaceEraseInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEraseSpaceFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSpaceEraseInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_requestId;
        oss_requestId << std::hex << reinterpret_cast<const void*>(requestId);
        contents.emplace_back("XrAsyncRequestIdFB*", "requestId", oss_requestId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EraseSpaceFB(session, info, requestId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_OCULUS_audio_device_guid extension commands
#if defined(XR_USE_PLATFORM_WIN32)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetAudioOutputDeviceGuidOculus(
    XrInstance instance,
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS]) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetAudioOutputDeviceGuidOculus", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        std::ostringstream oss_buffer;
        oss_buffer << std::hex << reinterpret_cast<const void*>(buffer);
        contents.emplace_back("wchar_t*", "buffer", oss_buffer.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetAudioOutputDeviceGuidOculus(instance, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_PLATFORM_WIN32)
#if defined(XR_USE_PLATFORM_WIN32)
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetAudioInputDeviceGuidOculus(
    XrInstance instance,
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS]) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetAudioInputDeviceGuidOculus", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        std::ostringstream oss_buffer;
        oss_buffer << std::hex << reinterpret_cast<const void*>(buffer);
        contents.emplace_back("wchar_t*", "buffer", oss_buffer.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetAudioInputDeviceGuidOculus(instance, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

#endif // defined(XR_USE_PLATFORM_WIN32)

// ---- XR_FB_spatial_entity_sharing extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrShareSpacesFB(
    XrSession session,
    const XrSpaceShareInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrShareSpacesFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSpaceShareInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_requestId;
        oss_requestId << std::hex << reinterpret_cast<const void*>(requestId);
        contents.emplace_back("XrAsyncRequestIdFB*", "requestId", oss_requestId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ShareSpacesFB(session, info, requestId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_scene extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSpaceBoundingBox2DFB(
    XrSession session,
    XrSpace space,
    XrRect2Df* boundingBox2DOutput) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSpaceBoundingBox2DFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace", "space", oss_space.str());
        std::ostringstream oss_boundingBox2DOutput;
        oss_boundingBox2DOutput << std::hex << reinterpret_cast<const void*>(boundingBox2DOutput);
        contents.emplace_back("XrRect2Df*", "boundingBox2DOutput", oss_boundingBox2DOutput.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSpaceBoundingBox2DFB(session, space, boundingBox2DOutput);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSpaceBoundingBox3DFB(
    XrSession session,
    XrSpace space,
    XrRect3DfFB* boundingBox3DOutput) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSpaceBoundingBox3DFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace", "space", oss_space.str());
        std::ostringstream oss_boundingBox3DOutput;
        oss_boundingBox3DOutput << std::hex << reinterpret_cast<const void*>(boundingBox3DOutput);
        contents.emplace_back("XrRect3DfFB*", "boundingBox3DOutput", oss_boundingBox3DOutput.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSpaceBoundingBox3DFB(session, space, boundingBox3DOutput);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSpaceSemanticLabelsFB(
    XrSession session,
    XrSpace space,
    XrSemanticLabelsFB* semanticLabelsOutput) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSpaceSemanticLabelsFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace", "space", oss_space.str());
        std::ostringstream oss_semanticLabelsOutput;
        oss_semanticLabelsOutput << std::hex << reinterpret_cast<const void*>(semanticLabelsOutput);
        contents.emplace_back("XrSemanticLabelsFB*", "semanticLabelsOutput", oss_semanticLabelsOutput.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSpaceSemanticLabelsFB(session, space, semanticLabelsOutput);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSpaceBoundary2DFB(
    XrSession session,
    XrSpace space,
    XrBoundary2DFB* boundary2DOutput) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSpaceBoundary2DFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace", "space", oss_space.str());
        std::ostringstream oss_boundary2DOutput;
        oss_boundary2DOutput << std::hex << reinterpret_cast<const void*>(boundary2DOutput);
        contents.emplace_back("XrBoundary2DFB*", "boundary2DOutput", oss_boundary2DOutput.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSpaceBoundary2DFB(session, space, boundary2DOutput);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSpaceRoomLayoutFB(
    XrSession session,
    XrSpace space,
    XrRoomLayoutFB* roomLayoutOutput) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSpaceRoomLayoutFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace", "space", oss_space.str());
        std::ostringstream oss_roomLayoutOutput;
        oss_roomLayoutOutput << std::hex << reinterpret_cast<const void*>(roomLayoutOutput);
        contents.emplace_back("XrRoomLayoutFB*", "roomLayoutOutput", oss_roomLayoutOutput.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSpaceRoomLayoutFB(session, space, roomLayoutOutput);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_ALMALENCE_digital_lens_control extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetDigitalLensControlALMALENCE(
    XrSession session,
    const XrDigitalLensControlALMALENCE* digitalLensControl) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetDigitalLensControlALMALENCE", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, digitalLensControl, "digitalLensControl", "const XrDigitalLensControlALMALENCE*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetDigitalLensControlALMALENCE(session, digitalLensControl);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_scene_capture extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrRequestSceneCaptureFB(
    XrSession session,
    const XrSceneCaptureRequestInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrRequestSceneCaptureFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSceneCaptureRequestInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_requestId;
        oss_requestId << std::hex << reinterpret_cast<const void*>(requestId);
        contents.emplace_back("XrAsyncRequestIdFB*", "requestId", oss_requestId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->RequestSceneCaptureFB(session, info, requestId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_spatial_entity_container extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSpaceContainerFB(
    XrSession session,
    XrSpace space,
    XrSpaceContainerFB* spaceContainerOutput) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSpaceContainerFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace", "space", oss_space.str());
        std::ostringstream oss_spaceContainerOutput;
        oss_spaceContainerOutput << std::hex << reinterpret_cast<const void*>(spaceContainerOutput);
        contents.emplace_back("XrSpaceContainerFB*", "spaceContainerOutput", oss_spaceContainerOutput.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSpaceContainerFB(session, space, spaceContainerOutput);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_META_foveation_eye_tracked extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetFoveationEyeTrackedStateMETA(
    XrSession session,
    XrFoveationEyeTrackedStateMETA* foveationState) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetFoveationEyeTrackedStateMETA", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_foveationState;
        oss_foveationState << std::hex << reinterpret_cast<const void*>(foveationState);
        contents.emplace_back("XrFoveationEyeTrackedStateMETA*", "foveationState", oss_foveationState.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetFoveationEyeTrackedStateMETA(session, foveationState);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_face_tracking extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateFaceTrackerFB(
    XrSession session,
    const XrFaceTrackerCreateInfoFB* createInfo,
    XrFaceTrackerFB* faceTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateFaceTrackerFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrFaceTrackerCreateInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_faceTracker;
        oss_faceTracker << std::hex << reinterpret_cast<const void*>(faceTracker);
        contents.emplace_back("XrFaceTrackerFB*", "faceTracker", oss_faceTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateFaceTrackerFB(session, createInfo, faceTracker);
        if (XR_SUCCESS == result && nullptr != faceTracker) {
            auto exists = g_facetrackerfb_dispatch_map.find(*faceTracker);
            if (exists == g_facetrackerfb_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_facetrackerfb_dispatch_mutex);
                g_facetrackerfb_dispatch_map[*faceTracker] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyFaceTrackerFB(
    XrFaceTrackerFB faceTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_facetrackerfb_dispatch_mutex);
            auto map_iter = g_facetrackerfb_dispatch_map.find(faceTracker);
            if (map_iter == g_facetrackerfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyFaceTrackerFB", "");
        std::ostringstream oss_faceTracker;
        oss_faceTracker << std::hex << reinterpret_cast<const void*>(faceTracker);
        contents.emplace_back("XrFaceTrackerFB", "faceTracker", oss_faceTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyFaceTrackerFB(faceTracker);
        auto exists = g_facetrackerfb_dispatch_map.find(faceTracker);
        if (exists != g_facetrackerfb_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_facetrackerfb_dispatch_mutex);
            g_facetrackerfb_dispatch_map.erase(faceTracker);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetFaceExpressionWeightsFB(
    XrFaceTrackerFB faceTracker,
    const XrFaceExpressionInfoFB* expressionInfo,
    XrFaceExpressionWeightsFB* expressionWeights) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_facetrackerfb_dispatch_mutex);
            auto map_iter = g_facetrackerfb_dispatch_map.find(faceTracker);
            if (map_iter == g_facetrackerfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetFaceExpressionWeightsFB", "");
        std::ostringstream oss_faceTracker;
        oss_faceTracker << std::hex << reinterpret_cast<const void*>(faceTracker);
        contents.emplace_back("XrFaceTrackerFB", "faceTracker", oss_faceTracker.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, expressionInfo, "expressionInfo", "const XrFaceExpressionInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_expressionWeights;
        oss_expressionWeights << std::hex << reinterpret_cast<const void*>(expressionWeights);
        contents.emplace_back("XrFaceExpressionWeightsFB*", "expressionWeights", oss_expressionWeights.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetFaceExpressionWeightsFB(faceTracker, expressionInfo, expressionWeights);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_eye_tracking_social extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateEyeTrackerFB(
    XrSession session,
    const XrEyeTrackerCreateInfoFB* createInfo,
    XrEyeTrackerFB* eyeTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateEyeTrackerFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrEyeTrackerCreateInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_eyeTracker;
        oss_eyeTracker << std::hex << reinterpret_cast<const void*>(eyeTracker);
        contents.emplace_back("XrEyeTrackerFB*", "eyeTracker", oss_eyeTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateEyeTrackerFB(session, createInfo, eyeTracker);
        if (XR_SUCCESS == result && nullptr != eyeTracker) {
            auto exists = g_eyetrackerfb_dispatch_map.find(*eyeTracker);
            if (exists == g_eyetrackerfb_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_eyetrackerfb_dispatch_mutex);
                g_eyetrackerfb_dispatch_map[*eyeTracker] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyEyeTrackerFB(
    XrEyeTrackerFB eyeTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_eyetrackerfb_dispatch_mutex);
            auto map_iter = g_eyetrackerfb_dispatch_map.find(eyeTracker);
            if (map_iter == g_eyetrackerfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyEyeTrackerFB", "");
        std::ostringstream oss_eyeTracker;
        oss_eyeTracker << std::hex << reinterpret_cast<const void*>(eyeTracker);
        contents.emplace_back("XrEyeTrackerFB", "eyeTracker", oss_eyeTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyEyeTrackerFB(eyeTracker);
        auto exists = g_eyetrackerfb_dispatch_map.find(eyeTracker);
        if (exists != g_eyetrackerfb_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_eyetrackerfb_dispatch_mutex);
            g_eyetrackerfb_dispatch_map.erase(eyeTracker);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetEyeGazesFB(
    XrEyeTrackerFB eyeTracker,
    const XrEyeGazesInfoFB* gazeInfo,
    XrEyeGazesFB* eyeGazes) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_eyetrackerfb_dispatch_mutex);
            auto map_iter = g_eyetrackerfb_dispatch_map.find(eyeTracker);
            if (map_iter == g_eyetrackerfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetEyeGazesFB", "");
        std::ostringstream oss_eyeTracker;
        oss_eyeTracker << std::hex << reinterpret_cast<const void*>(eyeTracker);
        contents.emplace_back("XrEyeTrackerFB", "eyeTracker", oss_eyeTracker.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, gazeInfo, "gazeInfo", "const XrEyeGazesInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_eyeGazes;
        oss_eyeGazes << std::hex << reinterpret_cast<const void*>(eyeGazes);
        contents.emplace_back("XrEyeGazesFB*", "eyeGazes", oss_eyeGazes.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetEyeGazesFB(eyeTracker, gazeInfo, eyeGazes);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_passthrough_keyboard_hands extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrPassthroughLayerSetKeyboardHandsIntensityFB(
    XrPassthroughLayerFB layer,
    const XrPassthroughKeyboardHandsIntensityFB* intensity) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_passthroughlayerfb_dispatch_mutex);
            auto map_iter = g_passthroughlayerfb_dispatch_map.find(layer);
            if (map_iter == g_passthroughlayerfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrPassthroughLayerSetKeyboardHandsIntensityFB", "");
        std::ostringstream oss_layer;
        oss_layer << std::hex << reinterpret_cast<const void*>(layer);
        contents.emplace_back("XrPassthroughLayerFB", "layer", oss_layer.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, intensity, "intensity", "const XrPassthroughKeyboardHandsIntensityFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->PassthroughLayerSetKeyboardHandsIntensityFB(layer, intensity);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_haptic_pcm extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetDeviceSampleRateFB(
    XrSession session,
    const XrHapticActionInfo* hapticActionInfo,
    XrDevicePcmSampleRateGetInfoFB* deviceSampleRate) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetDeviceSampleRateFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, hapticActionInfo, "hapticActionInfo", "const XrHapticActionInfo*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_deviceSampleRate;
        oss_deviceSampleRate << std::hex << reinterpret_cast<const void*>(deviceSampleRate);
        contents.emplace_back("XrDevicePcmSampleRateGetInfoFB*", "deviceSampleRate", oss_deviceSampleRate.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetDeviceSampleRateFB(session, hapticActionInfo, deviceSampleRate);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_META_passthrough_preferences extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetPassthroughPreferencesMETA(
    XrSession session,
    XrPassthroughPreferencesMETA* preferences) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetPassthroughPreferencesMETA", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_preferences;
        oss_preferences << std::hex << reinterpret_cast<const void*>(preferences);
        contents.emplace_back("XrPassthroughPreferencesMETA*", "preferences", oss_preferences.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetPassthroughPreferencesMETA(session, preferences);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_META_virtual_keyboard extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateVirtualKeyboardMETA(
    XrSession session,
    const XrVirtualKeyboardCreateInfoMETA* createInfo,
    XrVirtualKeyboardMETA* keyboard) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateVirtualKeyboardMETA", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrVirtualKeyboardCreateInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA*", "keyboard", oss_keyboard.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateVirtualKeyboardMETA(session, createInfo, keyboard);
        if (XR_SUCCESS == result && nullptr != keyboard) {
            auto exists = g_virtualkeyboardmeta_dispatch_map.find(*keyboard);
            if (exists == g_virtualkeyboardmeta_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_virtualkeyboardmeta_dispatch_mutex);
                g_virtualkeyboardmeta_dispatch_map[*keyboard] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyVirtualKeyboardMETA(
    XrVirtualKeyboardMETA keyboard) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_virtualkeyboardmeta_dispatch_mutex);
            auto map_iter = g_virtualkeyboardmeta_dispatch_map.find(keyboard);
            if (map_iter == g_virtualkeyboardmeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyVirtualKeyboardMETA", "");
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA", "keyboard", oss_keyboard.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyVirtualKeyboardMETA(keyboard);
        auto exists = g_virtualkeyboardmeta_dispatch_map.find(keyboard);
        if (exists != g_virtualkeyboardmeta_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_virtualkeyboardmeta_dispatch_mutex);
            g_virtualkeyboardmeta_dispatch_map.erase(keyboard);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateVirtualKeyboardSpaceMETA(
    XrSession session,
    XrVirtualKeyboardMETA keyboard,
    const XrVirtualKeyboardSpaceCreateInfoMETA* createInfo,
    XrSpace* keyboardSpace) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateVirtualKeyboardSpaceMETA", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA", "keyboard", oss_keyboard.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrVirtualKeyboardSpaceCreateInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_keyboardSpace;
        oss_keyboardSpace << std::hex << reinterpret_cast<const void*>(keyboardSpace);
        contents.emplace_back("XrSpace*", "keyboardSpace", oss_keyboardSpace.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateVirtualKeyboardSpaceMETA(session, keyboard, createInfo, keyboardSpace);
        if (XR_SUCCESS == result && nullptr != keyboardSpace) {
            auto exists = g_space_dispatch_map.find(*keyboardSpace);
            if (exists == g_space_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_space_dispatch_mutex);
                g_space_dispatch_map[*keyboardSpace] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSuggestVirtualKeyboardLocationMETA(
    XrVirtualKeyboardMETA keyboard,
    const XrVirtualKeyboardLocationInfoMETA* locationInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_virtualkeyboardmeta_dispatch_mutex);
            auto map_iter = g_virtualkeyboardmeta_dispatch_map.find(keyboard);
            if (map_iter == g_virtualkeyboardmeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSuggestVirtualKeyboardLocationMETA", "");
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA", "keyboard", oss_keyboard.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, locationInfo, "locationInfo", "const XrVirtualKeyboardLocationInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SuggestVirtualKeyboardLocationMETA(keyboard, locationInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetVirtualKeyboardScaleMETA(
    XrVirtualKeyboardMETA keyboard,
    float* scale) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_virtualkeyboardmeta_dispatch_mutex);
            auto map_iter = g_virtualkeyboardmeta_dispatch_map.find(keyboard);
            if (map_iter == g_virtualkeyboardmeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetVirtualKeyboardScaleMETA", "");
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA", "keyboard", oss_keyboard.str());
        std::ostringstream oss_scale;
        oss_scale << std::setprecision(32) << (scale);
        contents.emplace_back("float*", "scale", oss_scale.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetVirtualKeyboardScaleMETA(keyboard, scale);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetVirtualKeyboardModelVisibilityMETA(
    XrVirtualKeyboardMETA keyboard,
    const XrVirtualKeyboardModelVisibilitySetInfoMETA* modelVisibility) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_virtualkeyboardmeta_dispatch_mutex);
            auto map_iter = g_virtualkeyboardmeta_dispatch_map.find(keyboard);
            if (map_iter == g_virtualkeyboardmeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetVirtualKeyboardModelVisibilityMETA", "");
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA", "keyboard", oss_keyboard.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, modelVisibility, "modelVisibility", "const XrVirtualKeyboardModelVisibilitySetInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetVirtualKeyboardModelVisibilityMETA(keyboard, modelVisibility);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetVirtualKeyboardModelAnimationStatesMETA(
    XrVirtualKeyboardMETA keyboard,
    XrVirtualKeyboardModelAnimationStatesMETA* animationStates) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_virtualkeyboardmeta_dispatch_mutex);
            auto map_iter = g_virtualkeyboardmeta_dispatch_map.find(keyboard);
            if (map_iter == g_virtualkeyboardmeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetVirtualKeyboardModelAnimationStatesMETA", "");
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA", "keyboard", oss_keyboard.str());
        std::ostringstream oss_animationStates;
        oss_animationStates << std::hex << reinterpret_cast<const void*>(animationStates);
        contents.emplace_back("XrVirtualKeyboardModelAnimationStatesMETA*", "animationStates", oss_animationStates.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetVirtualKeyboardModelAnimationStatesMETA(keyboard, animationStates);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetVirtualKeyboardDirtyTexturesMETA(
    XrVirtualKeyboardMETA keyboard,
    uint32_t textureIdCapacityInput,
    uint32_t* textureIdCountOutput,
    uint64_t* textureIds) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_virtualkeyboardmeta_dispatch_mutex);
            auto map_iter = g_virtualkeyboardmeta_dispatch_map.find(keyboard);
            if (map_iter == g_virtualkeyboardmeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetVirtualKeyboardDirtyTexturesMETA", "");
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA", "keyboard", oss_keyboard.str());
        std::ostringstream oss_textureIdCapacityInput;
        oss_textureIdCapacityInput << "0x" << std::hex << (textureIdCapacityInput);
        contents.emplace_back("uint32_t", "textureIdCapacityInput", oss_textureIdCapacityInput.str());
        std::ostringstream oss_textureIdCountOutput;
        oss_textureIdCountOutput << std::hex << (textureIdCountOutput);
        contents.emplace_back("uint32_t*", "textureIdCountOutput", oss_textureIdCountOutput.str());
        std::ostringstream oss_textureIds;
        oss_textureIds << "0x" << std::hex << (textureIds);
        contents.emplace_back("uint64_t*", "textureIds", oss_textureIds.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetVirtualKeyboardDirtyTexturesMETA(keyboard, textureIdCapacityInput, textureIdCountOutput, textureIds);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetVirtualKeyboardTextureDataMETA(
    XrVirtualKeyboardMETA keyboard,
    uint64_t textureId,
    XrVirtualKeyboardTextureDataMETA* textureData) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_virtualkeyboardmeta_dispatch_mutex);
            auto map_iter = g_virtualkeyboardmeta_dispatch_map.find(keyboard);
            if (map_iter == g_virtualkeyboardmeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetVirtualKeyboardTextureDataMETA", "");
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA", "keyboard", oss_keyboard.str());
        std::ostringstream oss_textureId;
        oss_textureId << "0x" << std::hex << (textureId);
        contents.emplace_back("uint64_t", "textureId", oss_textureId.str());
        std::ostringstream oss_textureData;
        oss_textureData << std::hex << reinterpret_cast<const void*>(textureData);
        contents.emplace_back("XrVirtualKeyboardTextureDataMETA*", "textureData", oss_textureData.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetVirtualKeyboardTextureDataMETA(keyboard, textureId, textureData);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSendVirtualKeyboardInputMETA(
    XrVirtualKeyboardMETA keyboard,
    const XrVirtualKeyboardInputInfoMETA* info,
    XrPosef* interactorRootPose) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_virtualkeyboardmeta_dispatch_mutex);
            auto map_iter = g_virtualkeyboardmeta_dispatch_map.find(keyboard);
            if (map_iter == g_virtualkeyboardmeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSendVirtualKeyboardInputMETA", "");
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA", "keyboard", oss_keyboard.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrVirtualKeyboardInputInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_interactorRootPose;
        oss_interactorRootPose << std::hex << reinterpret_cast<const void*>(interactorRootPose);
        contents.emplace_back("XrPosef*", "interactorRootPose", oss_interactorRootPose.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SendVirtualKeyboardInputMETA(keyboard, info, interactorRootPose);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrChangeVirtualKeyboardTextContextMETA(
    XrVirtualKeyboardMETA keyboard,
    const XrVirtualKeyboardTextContextChangeInfoMETA* changeInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_virtualkeyboardmeta_dispatch_mutex);
            auto map_iter = g_virtualkeyboardmeta_dispatch_map.find(keyboard);
            if (map_iter == g_virtualkeyboardmeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrChangeVirtualKeyboardTextContextMETA", "");
        std::ostringstream oss_keyboard;
        oss_keyboard << std::hex << reinterpret_cast<const void*>(keyboard);
        contents.emplace_back("XrVirtualKeyboardMETA", "keyboard", oss_keyboard.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, changeInfo, "changeInfo", "const XrVirtualKeyboardTextContextChangeInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ChangeVirtualKeyboardTextContextMETA(keyboard, changeInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_OCULUS_external_camera extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateExternalCamerasOCULUS(
    XrSession session,
    uint32_t cameraCapacityInput,
    uint32_t* cameraCountOutput,
    XrExternalCameraOCULUS* cameras) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateExternalCamerasOCULUS", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_cameraCapacityInput;
        oss_cameraCapacityInput << "0x" << std::hex << (cameraCapacityInput);
        contents.emplace_back("uint32_t", "cameraCapacityInput", oss_cameraCapacityInput.str());
        std::ostringstream oss_cameraCountOutput;
        oss_cameraCountOutput << std::hex << (cameraCountOutput);
        contents.emplace_back("uint32_t*", "cameraCountOutput", oss_cameraCountOutput.str());
        std::ostringstream oss_cameras;
        oss_cameras << std::hex << reinterpret_cast<const void*>(cameras);
        contents.emplace_back("XrExternalCameraOCULUS*", "cameras", oss_cameras.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateExternalCamerasOCULUS(session, cameraCapacityInput, cameraCountOutput, cameras);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_META_performance_metrics extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumeratePerformanceMetricsCounterPathsMETA(
    XrInstance instance,
    uint32_t counterPathCapacityInput,
    uint32_t* counterPathCountOutput,
    XrPath* counterPaths) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumeratePerformanceMetricsCounterPathsMETA", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        std::ostringstream oss_counterPathCapacityInput;
        oss_counterPathCapacityInput << "0x" << std::hex << (counterPathCapacityInput);
        contents.emplace_back("uint32_t", "counterPathCapacityInput", oss_counterPathCapacityInput.str());
        std::ostringstream oss_counterPathCountOutput;
        oss_counterPathCountOutput << std::hex << (counterPathCountOutput);
        contents.emplace_back("uint32_t*", "counterPathCountOutput", oss_counterPathCountOutput.str());
        std::ostringstream oss_counterPaths;
        oss_counterPaths << std::hex << reinterpret_cast<const void*>(counterPaths);
        contents.emplace_back("XrPath*", "counterPaths", oss_counterPaths.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumeratePerformanceMetricsCounterPathsMETA(instance, counterPathCapacityInput, counterPathCountOutput, counterPaths);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetPerformanceMetricsStateMETA(
    XrSession session,
    const XrPerformanceMetricsStateMETA* state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetPerformanceMetricsStateMETA", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, state, "state", "const XrPerformanceMetricsStateMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetPerformanceMetricsStateMETA(session, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetPerformanceMetricsStateMETA(
    XrSession session,
    XrPerformanceMetricsStateMETA* state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetPerformanceMetricsStateMETA", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_state;
        oss_state << std::hex << reinterpret_cast<const void*>(state);
        contents.emplace_back("XrPerformanceMetricsStateMETA*", "state", oss_state.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetPerformanceMetricsStateMETA(session, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrQueryPerformanceMetricsCounterMETA(
    XrSession session,
    XrPath counterPath,
    XrPerformanceMetricsCounterMETA* counter) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrQueryPerformanceMetricsCounterMETA", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrPath", "counterPath", std::to_string(counterPath));
        std::ostringstream oss_counter;
        oss_counter << std::hex << reinterpret_cast<const void*>(counter);
        contents.emplace_back("XrPerformanceMetricsCounterMETA*", "counter", oss_counter.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->QueryPerformanceMetricsCounterMETA(session, counterPath, counter);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_spatial_entity_storage_batch extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSaveSpaceListFB(
    XrSession session,
    const XrSpaceListSaveInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSaveSpaceListFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSpaceListSaveInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_requestId;
        oss_requestId << std::hex << reinterpret_cast<const void*>(requestId);
        contents.emplace_back("XrAsyncRequestIdFB*", "requestId", oss_requestId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SaveSpaceListFB(session, info, requestId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_spatial_entity_user extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpaceUserFB(
    XrSession session,
    const XrSpaceUserCreateInfoFB* info,
    XrSpaceUserFB* user) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpaceUserFB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSpaceUserCreateInfoFB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_user;
        oss_user << std::hex << reinterpret_cast<const void*>(user);
        contents.emplace_back("XrSpaceUserFB*", "user", oss_user.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpaceUserFB(session, info, user);
        if (XR_SUCCESS == result && nullptr != user) {
            auto exists = g_spaceuserfb_dispatch_map.find(*user);
            if (exists == g_spaceuserfb_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_spaceuserfb_dispatch_mutex);
                g_spaceuserfb_dispatch_map[*user] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSpaceUserIdFB(
    XrSpaceUserFB user,
    XrSpaceUserIdFB* userId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spaceuserfb_dispatch_mutex);
            auto map_iter = g_spaceuserfb_dispatch_map.find(user);
            if (map_iter == g_spaceuserfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSpaceUserIdFB", "");
        std::ostringstream oss_user;
        oss_user << std::hex << reinterpret_cast<const void*>(user);
        contents.emplace_back("XrSpaceUserFB", "user", oss_user.str());
        std::ostringstream oss_userId;
        oss_userId << std::hex << (userId);
        contents.emplace_back("XrSpaceUserIdFB*", "userId", oss_userId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSpaceUserIdFB(user, userId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroySpaceUserFB(
    XrSpaceUserFB user) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_spaceuserfb_dispatch_mutex);
            auto map_iter = g_spaceuserfb_dispatch_map.find(user);
            if (map_iter == g_spaceuserfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroySpaceUserFB", "");
        std::ostringstream oss_user;
        oss_user << std::hex << reinterpret_cast<const void*>(user);
        contents.emplace_back("XrSpaceUserFB", "user", oss_user.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroySpaceUserFB(user);
        auto exists = g_spaceuserfb_dispatch_map.find(user);
        if (exists != g_spaceuserfb_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_spaceuserfb_dispatch_mutex);
            g_spaceuserfb_dispatch_map.erase(user);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_META_recommended_layer_resolution extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetRecommendedLayerResolutionMETA(
    XrSession session,
    const XrRecommendedLayerResolutionGetInfoMETA* info,
    XrRecommendedLayerResolutionMETA* resolution) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetRecommendedLayerResolutionMETA", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrRecommendedLayerResolutionGetInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_resolution;
        oss_resolution << std::hex << reinterpret_cast<const void*>(resolution);
        contents.emplace_back("XrRecommendedLayerResolutionMETA*", "resolution", oss_resolution.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetRecommendedLayerResolutionMETA(session, info, resolution);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_META_passthrough_color_lut extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreatePassthroughColorLutMETA(
    XrPassthroughFB passthrough,
    const XrPassthroughColorLutCreateInfoMETA* createInfo,
    XrPassthroughColorLutMETA* colorLut) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_passthroughfb_dispatch_mutex);
            auto map_iter = g_passthroughfb_dispatch_map.find(passthrough);
            if (map_iter == g_passthroughfb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreatePassthroughColorLutMETA", "");
        std::ostringstream oss_passthrough;
        oss_passthrough << std::hex << reinterpret_cast<const void*>(passthrough);
        contents.emplace_back("XrPassthroughFB", "passthrough", oss_passthrough.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrPassthroughColorLutCreateInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_colorLut;
        oss_colorLut << std::hex << reinterpret_cast<const void*>(colorLut);
        contents.emplace_back("XrPassthroughColorLutMETA*", "colorLut", oss_colorLut.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreatePassthroughColorLutMETA(passthrough, createInfo, colorLut);
        if (XR_SUCCESS == result && nullptr != colorLut) {
            auto exists = g_passthroughcolorlutmeta_dispatch_map.find(*colorLut);
            if (exists == g_passthroughcolorlutmeta_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_passthroughcolorlutmeta_dispatch_mutex);
                g_passthroughcolorlutmeta_dispatch_map[*colorLut] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyPassthroughColorLutMETA(
    XrPassthroughColorLutMETA colorLut) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_passthroughcolorlutmeta_dispatch_mutex);
            auto map_iter = g_passthroughcolorlutmeta_dispatch_map.find(colorLut);
            if (map_iter == g_passthroughcolorlutmeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyPassthroughColorLutMETA", "");
        std::ostringstream oss_colorLut;
        oss_colorLut << std::hex << reinterpret_cast<const void*>(colorLut);
        contents.emplace_back("XrPassthroughColorLutMETA", "colorLut", oss_colorLut.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyPassthroughColorLutMETA(colorLut);
        auto exists = g_passthroughcolorlutmeta_dispatch_map.find(colorLut);
        if (exists != g_passthroughcolorlutmeta_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_passthroughcolorlutmeta_dispatch_mutex);
            g_passthroughcolorlutmeta_dispatch_map.erase(colorLut);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrUpdatePassthroughColorLutMETA(
    XrPassthroughColorLutMETA colorLut,
    const XrPassthroughColorLutUpdateInfoMETA* updateInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_passthroughcolorlutmeta_dispatch_mutex);
            auto map_iter = g_passthroughcolorlutmeta_dispatch_map.find(colorLut);
            if (map_iter == g_passthroughcolorlutmeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrUpdatePassthroughColorLutMETA", "");
        std::ostringstream oss_colorLut;
        oss_colorLut << std::hex << reinterpret_cast<const void*>(colorLut);
        contents.emplace_back("XrPassthroughColorLutMETA", "colorLut", oss_colorLut.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, updateInfo, "updateInfo", "const XrPassthroughColorLutUpdateInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->UpdatePassthroughColorLutMETA(colorLut, updateInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_META_spatial_entity_mesh extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSpaceTriangleMeshMETA(
    XrSpace space,
    const XrSpaceTriangleMeshGetInfoMETA* getInfo,
    XrSpaceTriangleMeshMETA* triangleMeshOutput) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_space_dispatch_mutex);
            auto map_iter = g_space_dispatch_map.find(space);
            if (map_iter == g_space_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSpaceTriangleMeshMETA", "");
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace", "space", oss_space.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, getInfo, "getInfo", "const XrSpaceTriangleMeshGetInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_triangleMeshOutput;
        oss_triangleMeshOutput << std::hex << reinterpret_cast<const void*>(triangleMeshOutput);
        contents.emplace_back("XrSpaceTriangleMeshMETA*", "triangleMeshOutput", oss_triangleMeshOutput.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSpaceTriangleMeshMETA(space, getInfo, triangleMeshOutput);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_FB_face_tracking2 extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateFaceTracker2FB(
    XrSession session,
    const XrFaceTrackerCreateInfo2FB* createInfo,
    XrFaceTracker2FB* faceTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateFaceTracker2FB", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrFaceTrackerCreateInfo2FB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_faceTracker;
        oss_faceTracker << std::hex << reinterpret_cast<const void*>(faceTracker);
        contents.emplace_back("XrFaceTracker2FB*", "faceTracker", oss_faceTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateFaceTracker2FB(session, createInfo, faceTracker);
        if (XR_SUCCESS == result && nullptr != faceTracker) {
            auto exists = g_facetracker2fb_dispatch_map.find(*faceTracker);
            if (exists == g_facetracker2fb_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_facetracker2fb_dispatch_mutex);
                g_facetracker2fb_dispatch_map[*faceTracker] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyFaceTracker2FB(
    XrFaceTracker2FB faceTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_facetracker2fb_dispatch_mutex);
            auto map_iter = g_facetracker2fb_dispatch_map.find(faceTracker);
            if (map_iter == g_facetracker2fb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyFaceTracker2FB", "");
        std::ostringstream oss_faceTracker;
        oss_faceTracker << std::hex << reinterpret_cast<const void*>(faceTracker);
        contents.emplace_back("XrFaceTracker2FB", "faceTracker", oss_faceTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyFaceTracker2FB(faceTracker);
        auto exists = g_facetracker2fb_dispatch_map.find(faceTracker);
        if (exists != g_facetracker2fb_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_facetracker2fb_dispatch_mutex);
            g_facetracker2fb_dispatch_map.erase(faceTracker);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetFaceExpressionWeights2FB(
    XrFaceTracker2FB faceTracker,
    const XrFaceExpressionInfo2FB* expressionInfo,
    XrFaceExpressionWeights2FB* expressionWeights) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_facetracker2fb_dispatch_mutex);
            auto map_iter = g_facetracker2fb_dispatch_map.find(faceTracker);
            if (map_iter == g_facetracker2fb_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetFaceExpressionWeights2FB", "");
        std::ostringstream oss_faceTracker;
        oss_faceTracker << std::hex << reinterpret_cast<const void*>(faceTracker);
        contents.emplace_back("XrFaceTracker2FB", "faceTracker", oss_faceTracker.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, expressionInfo, "expressionInfo", "const XrFaceExpressionInfo2FB*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_expressionWeights;
        oss_expressionWeights << std::hex << reinterpret_cast<const void*>(expressionWeights);
        contents.emplace_back("XrFaceExpressionWeights2FB*", "expressionWeights", oss_expressionWeights.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetFaceExpressionWeights2FB(faceTracker, expressionInfo, expressionWeights);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_META_spatial_entity_sharing extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrShareSpacesMETA(
    XrSession session,
    const XrShareSpacesInfoMETA* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrShareSpacesMETA", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrShareSpacesInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_requestId;
        oss_requestId << std::hex << reinterpret_cast<const void*>(requestId);
        contents.emplace_back("XrAsyncRequestIdFB*", "requestId", oss_requestId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ShareSpacesMETA(session, info, requestId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_META_environment_depth extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateEnvironmentDepthProviderMETA(
    XrSession session,
    const XrEnvironmentDepthProviderCreateInfoMETA* createInfo,
    XrEnvironmentDepthProviderMETA* environmentDepthProvider) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateEnvironmentDepthProviderMETA", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrEnvironmentDepthProviderCreateInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_environmentDepthProvider;
        oss_environmentDepthProvider << std::hex << reinterpret_cast<const void*>(environmentDepthProvider);
        contents.emplace_back("XrEnvironmentDepthProviderMETA*", "environmentDepthProvider", oss_environmentDepthProvider.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateEnvironmentDepthProviderMETA(session, createInfo, environmentDepthProvider);
        if (XR_SUCCESS == result && nullptr != environmentDepthProvider) {
            auto exists = g_environmentdepthprovidermeta_dispatch_map.find(*environmentDepthProvider);
            if (exists == g_environmentdepthprovidermeta_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_environmentdepthprovidermeta_dispatch_mutex);
                g_environmentdepthprovidermeta_dispatch_map[*environmentDepthProvider] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyEnvironmentDepthProviderMETA(
    XrEnvironmentDepthProviderMETA environmentDepthProvider) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_environmentdepthprovidermeta_dispatch_mutex);
            auto map_iter = g_environmentdepthprovidermeta_dispatch_map.find(environmentDepthProvider);
            if (map_iter == g_environmentdepthprovidermeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyEnvironmentDepthProviderMETA", "");
        std::ostringstream oss_environmentDepthProvider;
        oss_environmentDepthProvider << std::hex << reinterpret_cast<const void*>(environmentDepthProvider);
        contents.emplace_back("XrEnvironmentDepthProviderMETA", "environmentDepthProvider", oss_environmentDepthProvider.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyEnvironmentDepthProviderMETA(environmentDepthProvider);
        auto exists = g_environmentdepthprovidermeta_dispatch_map.find(environmentDepthProvider);
        if (exists != g_environmentdepthprovidermeta_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_environmentdepthprovidermeta_dispatch_mutex);
            g_environmentdepthprovidermeta_dispatch_map.erase(environmentDepthProvider);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrStartEnvironmentDepthProviderMETA(
    XrEnvironmentDepthProviderMETA environmentDepthProvider) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_environmentdepthprovidermeta_dispatch_mutex);
            auto map_iter = g_environmentdepthprovidermeta_dispatch_map.find(environmentDepthProvider);
            if (map_iter == g_environmentdepthprovidermeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrStartEnvironmentDepthProviderMETA", "");
        std::ostringstream oss_environmentDepthProvider;
        oss_environmentDepthProvider << std::hex << reinterpret_cast<const void*>(environmentDepthProvider);
        contents.emplace_back("XrEnvironmentDepthProviderMETA", "environmentDepthProvider", oss_environmentDepthProvider.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->StartEnvironmentDepthProviderMETA(environmentDepthProvider);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrStopEnvironmentDepthProviderMETA(
    XrEnvironmentDepthProviderMETA environmentDepthProvider) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_environmentdepthprovidermeta_dispatch_mutex);
            auto map_iter = g_environmentdepthprovidermeta_dispatch_map.find(environmentDepthProvider);
            if (map_iter == g_environmentdepthprovidermeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrStopEnvironmentDepthProviderMETA", "");
        std::ostringstream oss_environmentDepthProvider;
        oss_environmentDepthProvider << std::hex << reinterpret_cast<const void*>(environmentDepthProvider);
        contents.emplace_back("XrEnvironmentDepthProviderMETA", "environmentDepthProvider", oss_environmentDepthProvider.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->StopEnvironmentDepthProviderMETA(environmentDepthProvider);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateEnvironmentDepthSwapchainMETA(
    XrEnvironmentDepthProviderMETA environmentDepthProvider,
    const XrEnvironmentDepthSwapchainCreateInfoMETA* createInfo,
    XrEnvironmentDepthSwapchainMETA* swapchain) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_environmentdepthprovidermeta_dispatch_mutex);
            auto map_iter = g_environmentdepthprovidermeta_dispatch_map.find(environmentDepthProvider);
            if (map_iter == g_environmentdepthprovidermeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateEnvironmentDepthSwapchainMETA", "");
        std::ostringstream oss_environmentDepthProvider;
        oss_environmentDepthProvider << std::hex << reinterpret_cast<const void*>(environmentDepthProvider);
        contents.emplace_back("XrEnvironmentDepthProviderMETA", "environmentDepthProvider", oss_environmentDepthProvider.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrEnvironmentDepthSwapchainCreateInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_swapchain;
        oss_swapchain << std::hex << reinterpret_cast<const void*>(swapchain);
        contents.emplace_back("XrEnvironmentDepthSwapchainMETA*", "swapchain", oss_swapchain.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateEnvironmentDepthSwapchainMETA(environmentDepthProvider, createInfo, swapchain);
        if (XR_SUCCESS == result && nullptr != swapchain) {
            auto exists = g_environmentdepthswapchainmeta_dispatch_map.find(*swapchain);
            if (exists == g_environmentdepthswapchainmeta_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_environmentdepthswapchainmeta_dispatch_mutex);
                g_environmentdepthswapchainmeta_dispatch_map[*swapchain] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyEnvironmentDepthSwapchainMETA(
    XrEnvironmentDepthSwapchainMETA swapchain) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_environmentdepthswapchainmeta_dispatch_mutex);
            auto map_iter = g_environmentdepthswapchainmeta_dispatch_map.find(swapchain);
            if (map_iter == g_environmentdepthswapchainmeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyEnvironmentDepthSwapchainMETA", "");
        std::ostringstream oss_swapchain;
        oss_swapchain << std::hex << reinterpret_cast<const void*>(swapchain);
        contents.emplace_back("XrEnvironmentDepthSwapchainMETA", "swapchain", oss_swapchain.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyEnvironmentDepthSwapchainMETA(swapchain);
        auto exists = g_environmentdepthswapchainmeta_dispatch_map.find(swapchain);
        if (exists != g_environmentdepthswapchainmeta_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_environmentdepthswapchainmeta_dispatch_mutex);
            g_environmentdepthswapchainmeta_dispatch_map.erase(swapchain);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateEnvironmentDepthSwapchainImagesMETA(
    XrEnvironmentDepthSwapchainMETA swapchain,
    uint32_t imageCapacityInput,
    uint32_t* imageCountOutput,
    XrSwapchainImageBaseHeader* images) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_environmentdepthswapchainmeta_dispatch_mutex);
            auto map_iter = g_environmentdepthswapchainmeta_dispatch_map.find(swapchain);
            if (map_iter == g_environmentdepthswapchainmeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateEnvironmentDepthSwapchainImagesMETA", "");
        std::ostringstream oss_swapchain;
        oss_swapchain << std::hex << reinterpret_cast<const void*>(swapchain);
        contents.emplace_back("XrEnvironmentDepthSwapchainMETA", "swapchain", oss_swapchain.str());
        std::ostringstream oss_imageCapacityInput;
        oss_imageCapacityInput << "0x" << std::hex << (imageCapacityInput);
        contents.emplace_back("uint32_t", "imageCapacityInput", oss_imageCapacityInput.str());
        std::ostringstream oss_imageCountOutput;
        oss_imageCountOutput << std::hex << (imageCountOutput);
        contents.emplace_back("uint32_t*", "imageCountOutput", oss_imageCountOutput.str());
        std::ostringstream oss_images;
        oss_images << std::hex << reinterpret_cast<const void*>(images);
        contents.emplace_back("XrSwapchainImageBaseHeader*", "images", oss_images.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateEnvironmentDepthSwapchainImagesMETA(swapchain, imageCapacityInput, imageCountOutput, images);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetEnvironmentDepthSwapchainStateMETA(
    XrEnvironmentDepthSwapchainMETA swapchain,
    XrEnvironmentDepthSwapchainStateMETA* state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_environmentdepthswapchainmeta_dispatch_mutex);
            auto map_iter = g_environmentdepthswapchainmeta_dispatch_map.find(swapchain);
            if (map_iter == g_environmentdepthswapchainmeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetEnvironmentDepthSwapchainStateMETA", "");
        std::ostringstream oss_swapchain;
        oss_swapchain << std::hex << reinterpret_cast<const void*>(swapchain);
        contents.emplace_back("XrEnvironmentDepthSwapchainMETA", "swapchain", oss_swapchain.str());
        std::ostringstream oss_state;
        oss_state << std::hex << reinterpret_cast<const void*>(state);
        contents.emplace_back("XrEnvironmentDepthSwapchainStateMETA*", "state", oss_state.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetEnvironmentDepthSwapchainStateMETA(swapchain, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrAcquireEnvironmentDepthImageMETA(
    XrEnvironmentDepthProviderMETA environmentDepthProvider,
    const XrEnvironmentDepthImageAcquireInfoMETA* acquireInfo,
    XrEnvironmentDepthImageMETA* environmentDepthImage) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_environmentdepthprovidermeta_dispatch_mutex);
            auto map_iter = g_environmentdepthprovidermeta_dispatch_map.find(environmentDepthProvider);
            if (map_iter == g_environmentdepthprovidermeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrAcquireEnvironmentDepthImageMETA", "");
        std::ostringstream oss_environmentDepthProvider;
        oss_environmentDepthProvider << std::hex << reinterpret_cast<const void*>(environmentDepthProvider);
        contents.emplace_back("XrEnvironmentDepthProviderMETA", "environmentDepthProvider", oss_environmentDepthProvider.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, acquireInfo, "acquireInfo", "const XrEnvironmentDepthImageAcquireInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_environmentDepthImage;
        oss_environmentDepthImage << std::hex << reinterpret_cast<const void*>(environmentDepthImage);
        contents.emplace_back("XrEnvironmentDepthImageMETA*", "environmentDepthImage", oss_environmentDepthImage.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->AcquireEnvironmentDepthImageMETA(environmentDepthProvider, acquireInfo, environmentDepthImage);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetEnvironmentDepthHandRemovalMETA(
    XrEnvironmentDepthProviderMETA environmentDepthProvider,
    const XrEnvironmentDepthHandRemovalSetInfoMETA* setInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_environmentdepthprovidermeta_dispatch_mutex);
            auto map_iter = g_environmentdepthprovidermeta_dispatch_map.find(environmentDepthProvider);
            if (map_iter == g_environmentdepthprovidermeta_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetEnvironmentDepthHandRemovalMETA", "");
        std::ostringstream oss_environmentDepthProvider;
        oss_environmentDepthProvider << std::hex << reinterpret_cast<const void*>(environmentDepthProvider);
        contents.emplace_back("XrEnvironmentDepthProviderMETA", "environmentDepthProvider", oss_environmentDepthProvider.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, setInfo, "setInfo", "const XrEnvironmentDepthHandRemovalSetInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetEnvironmentDepthHandRemovalMETA(environmentDepthProvider, setInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_QCOM_tracking_optimization_settings extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetTrackingOptimizationSettingsHintQCOM(
    XrSession session,
    XrTrackingOptimizationSettingsDomainQCOM domain,
    XrTrackingOptimizationSettingsHintQCOM hint) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetTrackingOptimizationSettingsHintQCOM", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        contents.emplace_back("XrTrackingOptimizationSettingsDomainQCOM", "domain", std::to_string(domain));
        contents.emplace_back("XrTrackingOptimizationSettingsHintQCOM", "hint", std::to_string(hint));
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetTrackingOptimizationSettingsHintQCOM(session, domain, hint);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_HTC_passthrough extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreatePassthroughHTC(
    XrSession session,
    const XrPassthroughCreateInfoHTC* createInfo,
    XrPassthroughHTC* passthrough) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreatePassthroughHTC", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrPassthroughCreateInfoHTC*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_passthrough;
        oss_passthrough << std::hex << reinterpret_cast<const void*>(passthrough);
        contents.emplace_back("XrPassthroughHTC*", "passthrough", oss_passthrough.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreatePassthroughHTC(session, createInfo, passthrough);
        if (XR_SUCCESS == result && nullptr != passthrough) {
            auto exists = g_passthroughhtc_dispatch_map.find(*passthrough);
            if (exists == g_passthroughhtc_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_passthroughhtc_dispatch_mutex);
                g_passthroughhtc_dispatch_map[*passthrough] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyPassthroughHTC(
    XrPassthroughHTC passthrough) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_passthroughhtc_dispatch_mutex);
            auto map_iter = g_passthroughhtc_dispatch_map.find(passthrough);
            if (map_iter == g_passthroughhtc_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyPassthroughHTC", "");
        std::ostringstream oss_passthrough;
        oss_passthrough << std::hex << reinterpret_cast<const void*>(passthrough);
        contents.emplace_back("XrPassthroughHTC", "passthrough", oss_passthrough.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyPassthroughHTC(passthrough);
        auto exists = g_passthroughhtc_dispatch_map.find(passthrough);
        if (exists != g_passthroughhtc_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_passthroughhtc_dispatch_mutex);
            g_passthroughhtc_dispatch_map.erase(passthrough);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_HTC_foveation extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrApplyFoveationHTC(
    XrSession session,
    const XrFoveationApplyInfoHTC* applyInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrApplyFoveationHTC", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, applyInfo, "applyInfo", "const XrFoveationApplyInfoHTC*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ApplyFoveationHTC(session, applyInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_HTC_anchor extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpatialAnchorHTC(
    XrSession session,
    const XrSpatialAnchorCreateInfoHTC* createInfo,
    XrSpace* anchor) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpatialAnchorHTC", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrSpatialAnchorCreateInfoHTC*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(anchor);
        contents.emplace_back("XrSpace*", "anchor", oss_anchor.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpatialAnchorHTC(session, createInfo, anchor);
        if (XR_SUCCESS == result && nullptr != anchor) {
            auto exists = g_space_dispatch_map.find(*anchor);
            if (exists == g_space_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_space_dispatch_mutex);
                g_space_dispatch_map[*anchor] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSpatialAnchorNameHTC(
    XrSpace anchor,
    XrSpatialAnchorNameHTC* name) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_space_dispatch_mutex);
            auto map_iter = g_space_dispatch_map.find(anchor);
            if (map_iter == g_space_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSpatialAnchorNameHTC", "");
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(anchor);
        contents.emplace_back("XrSpace", "anchor", oss_anchor.str());
        std::ostringstream oss_name;
        oss_name << std::hex << reinterpret_cast<const void*>(name);
        contents.emplace_back("XrSpatialAnchorNameHTC*", "name", oss_name.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSpatialAnchorNameHTC(anchor, name);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_HTC_body_tracking extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateBodyTrackerHTC(
    XrSession session,
    const XrBodyTrackerCreateInfoHTC* createInfo,
    XrBodyTrackerHTC* bodyTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateBodyTrackerHTC", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrBodyTrackerCreateInfoHTC*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_bodyTracker;
        oss_bodyTracker << std::hex << reinterpret_cast<const void*>(bodyTracker);
        contents.emplace_back("XrBodyTrackerHTC*", "bodyTracker", oss_bodyTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateBodyTrackerHTC(session, createInfo, bodyTracker);
        if (XR_SUCCESS == result && nullptr != bodyTracker) {
            auto exists = g_bodytrackerhtc_dispatch_map.find(*bodyTracker);
            if (exists == g_bodytrackerhtc_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_bodytrackerhtc_dispatch_mutex);
                g_bodytrackerhtc_dispatch_map[*bodyTracker] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyBodyTrackerHTC(
    XrBodyTrackerHTC bodyTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_bodytrackerhtc_dispatch_mutex);
            auto map_iter = g_bodytrackerhtc_dispatch_map.find(bodyTracker);
            if (map_iter == g_bodytrackerhtc_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyBodyTrackerHTC", "");
        std::ostringstream oss_bodyTracker;
        oss_bodyTracker << std::hex << reinterpret_cast<const void*>(bodyTracker);
        contents.emplace_back("XrBodyTrackerHTC", "bodyTracker", oss_bodyTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyBodyTrackerHTC(bodyTracker);
        auto exists = g_bodytrackerhtc_dispatch_map.find(bodyTracker);
        if (exists != g_bodytrackerhtc_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_bodytrackerhtc_dispatch_mutex);
            g_bodytrackerhtc_dispatch_map.erase(bodyTracker);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrLocateBodyJointsHTC(
    XrBodyTrackerHTC bodyTracker,
    const XrBodyJointsLocateInfoHTC* locateInfo,
    XrBodyJointLocationsHTC* locations) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_bodytrackerhtc_dispatch_mutex);
            auto map_iter = g_bodytrackerhtc_dispatch_map.find(bodyTracker);
            if (map_iter == g_bodytrackerhtc_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrLocateBodyJointsHTC", "");
        std::ostringstream oss_bodyTracker;
        oss_bodyTracker << std::hex << reinterpret_cast<const void*>(bodyTracker);
        contents.emplace_back("XrBodyTrackerHTC", "bodyTracker", oss_bodyTracker.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, locateInfo, "locateInfo", "const XrBodyJointsLocateInfoHTC*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_locations;
        oss_locations << std::hex << reinterpret_cast<const void*>(locations);
        contents.emplace_back("XrBodyJointLocationsHTC*", "locations", oss_locations.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->LocateBodyJointsHTC(bodyTracker, locateInfo, locations);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetBodySkeletonHTC(
    XrBodyTrackerHTC bodyTracker,
    XrSpace baseSpace,
    uint32_t skeletonGenerationId,
    XrBodySkeletonHTC* skeleton) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_bodytrackerhtc_dispatch_mutex);
            auto map_iter = g_bodytrackerhtc_dispatch_map.find(bodyTracker);
            if (map_iter == g_bodytrackerhtc_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetBodySkeletonHTC", "");
        std::ostringstream oss_bodyTracker;
        oss_bodyTracker << std::hex << reinterpret_cast<const void*>(bodyTracker);
        contents.emplace_back("XrBodyTrackerHTC", "bodyTracker", oss_bodyTracker.str());
        std::ostringstream oss_baseSpace;
        oss_baseSpace << std::hex << reinterpret_cast<const void*>(baseSpace);
        contents.emplace_back("XrSpace", "baseSpace", oss_baseSpace.str());
        std::ostringstream oss_skeletonGenerationId;
        oss_skeletonGenerationId << "0x" << std::hex << (skeletonGenerationId);
        contents.emplace_back("uint32_t", "skeletonGenerationId", oss_skeletonGenerationId.str());
        std::ostringstream oss_skeleton;
        oss_skeleton << std::hex << reinterpret_cast<const void*>(skeleton);
        contents.emplace_back("XrBodySkeletonHTC*", "skeleton", oss_skeleton.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetBodySkeletonHTC(bodyTracker, baseSpace, skeletonGenerationId, skeleton);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_MNDX_force_feedback_curl extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrApplyForceFeedbackCurlMNDX(
    XrHandTrackerEXT handTracker,
    const XrForceFeedbackCurlApplyLocationsMNDX* locations) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_handtrackerext_dispatch_mutex);
            auto map_iter = g_handtrackerext_dispatch_map.find(handTracker);
            if (map_iter == g_handtrackerext_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrApplyForceFeedbackCurlMNDX", "");
        std::ostringstream oss_handTracker;
        oss_handTracker << std::hex << reinterpret_cast<const void*>(handTracker);
        contents.emplace_back("XrHandTrackerEXT", "handTracker", oss_handTracker.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, locations, "locations", "const XrForceFeedbackCurlApplyLocationsMNDX*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ApplyForceFeedbackCurlMNDX(handTracker, locations);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_BD_body_tracking extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateBodyTrackerBD(
    XrSession session,
    const XrBodyTrackerCreateInfoBD* createInfo,
    XrBodyTrackerBD* bodyTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateBodyTrackerBD", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrBodyTrackerCreateInfoBD*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_bodyTracker;
        oss_bodyTracker << std::hex << reinterpret_cast<const void*>(bodyTracker);
        contents.emplace_back("XrBodyTrackerBD*", "bodyTracker", oss_bodyTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateBodyTrackerBD(session, createInfo, bodyTracker);
        if (XR_SUCCESS == result && nullptr != bodyTracker) {
            auto exists = g_bodytrackerbd_dispatch_map.find(*bodyTracker);
            if (exists == g_bodytrackerbd_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_bodytrackerbd_dispatch_mutex);
                g_bodytrackerbd_dispatch_map[*bodyTracker] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyBodyTrackerBD(
    XrBodyTrackerBD bodyTracker) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_bodytrackerbd_dispatch_mutex);
            auto map_iter = g_bodytrackerbd_dispatch_map.find(bodyTracker);
            if (map_iter == g_bodytrackerbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyBodyTrackerBD", "");
        std::ostringstream oss_bodyTracker;
        oss_bodyTracker << std::hex << reinterpret_cast<const void*>(bodyTracker);
        contents.emplace_back("XrBodyTrackerBD", "bodyTracker", oss_bodyTracker.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyBodyTrackerBD(bodyTracker);
        auto exists = g_bodytrackerbd_dispatch_map.find(bodyTracker);
        if (exists != g_bodytrackerbd_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_bodytrackerbd_dispatch_mutex);
            g_bodytrackerbd_dispatch_map.erase(bodyTracker);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrLocateBodyJointsBD(
    XrBodyTrackerBD bodyTracker,
    const XrBodyJointsLocateInfoBD* locateInfo,
    XrBodyJointLocationsBD* locations) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_bodytrackerbd_dispatch_mutex);
            auto map_iter = g_bodytrackerbd_dispatch_map.find(bodyTracker);
            if (map_iter == g_bodytrackerbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrLocateBodyJointsBD", "");
        std::ostringstream oss_bodyTracker;
        oss_bodyTracker << std::hex << reinterpret_cast<const void*>(bodyTracker);
        contents.emplace_back("XrBodyTrackerBD", "bodyTracker", oss_bodyTracker.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, locateInfo, "locateInfo", "const XrBodyJointsLocateInfoBD*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_locations;
        oss_locations << std::hex << reinterpret_cast<const void*>(locations);
        contents.emplace_back("XrBodyJointLocationsBD*", "locations", oss_locations.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->LocateBodyJointsBD(bodyTracker, locateInfo, locations);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_BD_spatial_sensing extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnumerateSpatialEntityComponentTypesBD(
    XrSenseDataSnapshotBD snapshot,
    XrSpatialEntityIdBD entityId,
    uint32_t componentTypeCapacityInput,
    uint32_t* componentTypeCountOutput,
    XrSpatialEntityComponentTypeBD* componentTypes) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedatasnapshotbd_dispatch_mutex);
            auto map_iter = g_sensedatasnapshotbd_dispatch_map.find(snapshot);
            if (map_iter == g_sensedatasnapshotbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnumerateSpatialEntityComponentTypesBD", "");
        std::ostringstream oss_snapshot;
        oss_snapshot << std::hex << reinterpret_cast<const void*>(snapshot);
        contents.emplace_back("XrSenseDataSnapshotBD", "snapshot", oss_snapshot.str());
        contents.emplace_back("XrSpatialEntityIdBD", "entityId", std::to_string(entityId));
        std::ostringstream oss_componentTypeCapacityInput;
        oss_componentTypeCapacityInput << "0x" << std::hex << (componentTypeCapacityInput);
        contents.emplace_back("uint32_t", "componentTypeCapacityInput", oss_componentTypeCapacityInput.str());
        std::ostringstream oss_componentTypeCountOutput;
        oss_componentTypeCountOutput << std::hex << (componentTypeCountOutput);
        contents.emplace_back("uint32_t*", "componentTypeCountOutput", oss_componentTypeCountOutput.str());
        std::ostringstream oss_componentTypes;
        oss_componentTypes << std::hex << reinterpret_cast<const void*>(componentTypes);
        contents.emplace_back("XrSpatialEntityComponentTypeBD*", "componentTypes", oss_componentTypes.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnumerateSpatialEntityComponentTypesBD(snapshot, entityId, componentTypeCapacityInput, componentTypeCountOutput, componentTypes);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSpatialEntityUuidBD(
    XrSenseDataSnapshotBD snapshot,
    XrSpatialEntityIdBD entityId,
    XrUuidEXT* uuid) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedatasnapshotbd_dispatch_mutex);
            auto map_iter = g_sensedatasnapshotbd_dispatch_map.find(snapshot);
            if (map_iter == g_sensedatasnapshotbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSpatialEntityUuidBD", "");
        std::ostringstream oss_snapshot;
        oss_snapshot << std::hex << reinterpret_cast<const void*>(snapshot);
        contents.emplace_back("XrSenseDataSnapshotBD", "snapshot", oss_snapshot.str());
        contents.emplace_back("XrSpatialEntityIdBD", "entityId", std::to_string(entityId));
        std::ostringstream oss_uuid;
        oss_uuid << std::hex << reinterpret_cast<const void*>(uuid);
        contents.emplace_back("XrUuidEXT*", "uuid", oss_uuid.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSpatialEntityUuidBD(snapshot, entityId, uuid);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSpatialEntityComponentDataBD(
    XrSenseDataSnapshotBD snapshot,
    const XrSpatialEntityComponentGetInfoBD* getInfo,
    XrSpatialEntityComponentDataBaseHeaderBD* componentData) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedatasnapshotbd_dispatch_mutex);
            auto map_iter = g_sensedatasnapshotbd_dispatch_map.find(snapshot);
            if (map_iter == g_sensedatasnapshotbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSpatialEntityComponentDataBD", "");
        std::ostringstream oss_snapshot;
        oss_snapshot << std::hex << reinterpret_cast<const void*>(snapshot);
        contents.emplace_back("XrSenseDataSnapshotBD", "snapshot", oss_snapshot.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, getInfo, "getInfo", "const XrSpatialEntityComponentGetInfoBD*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_componentData;
        oss_componentData << std::hex << reinterpret_cast<const void*>(componentData);
        contents.emplace_back("XrSpatialEntityComponentDataBaseHeaderBD*", "componentData", oss_componentData.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSpatialEntityComponentDataBD(snapshot, getInfo, componentData);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSenseDataProviderBD(
    XrSession session,
    const XrSenseDataProviderCreateInfoBD* createInfo,
    XrSenseDataProviderBD* provider) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSenseDataProviderBD", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrSenseDataProviderCreateInfoBD*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD*", "provider", oss_provider.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSenseDataProviderBD(session, createInfo, provider);
        if (XR_SUCCESS == result && nullptr != provider) {
            auto exists = g_sensedataproviderbd_dispatch_map.find(*provider);
            if (exists == g_sensedataproviderbd_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_sensedataproviderbd_dispatch_mutex);
                g_sensedataproviderbd_dispatch_map[*provider] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrStartSenseDataProviderAsyncBD(
    XrSenseDataProviderBD provider,
    const XrSenseDataProviderStartInfoBD* startInfo,
    XrFutureEXT* future) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrStartSenseDataProviderAsyncBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, startInfo, "startInfo", "const XrSenseDataProviderStartInfoBD*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT*", "future", oss_future.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->StartSenseDataProviderAsyncBD(provider, startInfo, future);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrStartSenseDataProviderCompleteBD(
    XrSession session,
    XrFutureEXT future,
    XrFutureCompletionEXT* completion) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrStartSenseDataProviderCompleteBD", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT", "future", oss_future.str());
        std::ostringstream oss_completion;
        oss_completion << std::hex << reinterpret_cast<const void*>(completion);
        contents.emplace_back("XrFutureCompletionEXT*", "completion", oss_completion.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->StartSenseDataProviderCompleteBD(session, future, completion);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetSenseDataProviderStateBD(
    XrSenseDataProviderBD provider,
    XrSenseDataProviderStateBD* state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetSenseDataProviderStateBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        std::ostringstream oss_state;
        oss_state << std::hex << reinterpret_cast<const void*>(state);
        contents.emplace_back("XrSenseDataProviderStateBD*", "state", oss_state.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetSenseDataProviderStateBD(provider, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrQuerySenseDataAsyncBD(
    XrSenseDataProviderBD provider,
    const XrSenseDataQueryInfoBD* queryInfo,
    XrFutureEXT* future) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrQuerySenseDataAsyncBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, queryInfo, "queryInfo", "const XrSenseDataQueryInfoBD*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT*", "future", oss_future.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->QuerySenseDataAsyncBD(provider, queryInfo, future);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrQuerySenseDataCompleteBD(
    XrSenseDataProviderBD provider,
    XrFutureEXT future,
    XrSenseDataQueryCompletionBD* completion) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrQuerySenseDataCompleteBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT", "future", oss_future.str());
        std::ostringstream oss_completion;
        oss_completion << std::hex << reinterpret_cast<const void*>(completion);
        contents.emplace_back("XrSenseDataQueryCompletionBD*", "completion", oss_completion.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->QuerySenseDataCompleteBD(provider, future, completion);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroySenseDataSnapshotBD(
    XrSenseDataSnapshotBD snapshot) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedatasnapshotbd_dispatch_mutex);
            auto map_iter = g_sensedatasnapshotbd_dispatch_map.find(snapshot);
            if (map_iter == g_sensedatasnapshotbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroySenseDataSnapshotBD", "");
        std::ostringstream oss_snapshot;
        oss_snapshot << std::hex << reinterpret_cast<const void*>(snapshot);
        contents.emplace_back("XrSenseDataSnapshotBD", "snapshot", oss_snapshot.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroySenseDataSnapshotBD(snapshot);
        auto exists = g_sensedatasnapshotbd_dispatch_map.find(snapshot);
        if (exists != g_sensedatasnapshotbd_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_sensedatasnapshotbd_dispatch_mutex);
            g_sensedatasnapshotbd_dispatch_map.erase(snapshot);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetQueriedSenseDataBD(
    XrSenseDataSnapshotBD snapshot,
    XrQueriedSenseDataGetInfoBD* getInfo,
    XrQueriedSenseDataBD* queriedSenseData) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedatasnapshotbd_dispatch_mutex);
            auto map_iter = g_sensedatasnapshotbd_dispatch_map.find(snapshot);
            if (map_iter == g_sensedatasnapshotbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetQueriedSenseDataBD", "");
        std::ostringstream oss_snapshot;
        oss_snapshot << std::hex << reinterpret_cast<const void*>(snapshot);
        contents.emplace_back("XrSenseDataSnapshotBD", "snapshot", oss_snapshot.str());
        std::ostringstream oss_getInfo;
        oss_getInfo << std::hex << reinterpret_cast<const void*>(getInfo);
        contents.emplace_back("XrQueriedSenseDataGetInfoBD*", "getInfo", oss_getInfo.str());
        std::ostringstream oss_queriedSenseData;
        oss_queriedSenseData << std::hex << reinterpret_cast<const void*>(queriedSenseData);
        contents.emplace_back("XrQueriedSenseDataBD*", "queriedSenseData", oss_queriedSenseData.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetQueriedSenseDataBD(snapshot, getInfo, queriedSenseData);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrStopSenseDataProviderBD(
    XrSenseDataProviderBD provider) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrStopSenseDataProviderBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->StopSenseDataProviderBD(provider);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroySenseDataProviderBD(
    XrSenseDataProviderBD provider) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroySenseDataProviderBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroySenseDataProviderBD(provider);
        auto exists = g_sensedataproviderbd_dispatch_map.find(provider);
        if (exists != g_sensedataproviderbd_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_sensedataproviderbd_dispatch_mutex);
            g_sensedataproviderbd_dispatch_map.erase(provider);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpatialEntityAnchorBD(
    XrSenseDataProviderBD provider,
    const XrSpatialEntityAnchorCreateInfoBD* createInfo,
    XrAnchorBD* anchor) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpatialEntityAnchorBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrSpatialEntityAnchorCreateInfoBD*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(anchor);
        contents.emplace_back("XrAnchorBD*", "anchor", oss_anchor.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpatialEntityAnchorBD(provider, createInfo, anchor);
        if (XR_SUCCESS == result && nullptr != anchor) {
            auto exists = g_anchorbd_dispatch_map.find(*anchor);
            if (exists == g_anchorbd_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_anchorbd_dispatch_mutex);
                g_anchorbd_dispatch_map[*anchor] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyAnchorBD(
    XrAnchorBD anchor) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_anchorbd_dispatch_mutex);
            auto map_iter = g_anchorbd_dispatch_map.find(anchor);
            if (map_iter == g_anchorbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyAnchorBD", "");
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(anchor);
        contents.emplace_back("XrAnchorBD", "anchor", oss_anchor.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyAnchorBD(anchor);
        auto exists = g_anchorbd_dispatch_map.find(anchor);
        if (exists != g_anchorbd_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_anchorbd_dispatch_mutex);
            g_anchorbd_dispatch_map.erase(anchor);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetAnchorUuidBD(
    XrAnchorBD anchor,
    XrUuidEXT* uuid) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_anchorbd_dispatch_mutex);
            auto map_iter = g_anchorbd_dispatch_map.find(anchor);
            if (map_iter == g_anchorbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetAnchorUuidBD", "");
        std::ostringstream oss_anchor;
        oss_anchor << std::hex << reinterpret_cast<const void*>(anchor);
        contents.emplace_back("XrAnchorBD", "anchor", oss_anchor.str());
        std::ostringstream oss_uuid;
        oss_uuid << std::hex << reinterpret_cast<const void*>(uuid);
        contents.emplace_back("XrUuidEXT*", "uuid", oss_uuid.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetAnchorUuidBD(anchor, uuid);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateAnchorSpaceBD(
    XrSession session,
    const XrAnchorSpaceCreateInfoBD* createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateAnchorSpaceBD", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrAnchorSpaceCreateInfoBD*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_space;
        oss_space << std::hex << reinterpret_cast<const void*>(space);
        contents.emplace_back("XrSpace*", "space", oss_space.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateAnchorSpaceBD(session, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            auto exists = g_space_dispatch_map.find(*space);
            if (exists == g_space_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_space_dispatch_mutex);
                g_space_dispatch_map[*space] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_BD_spatial_anchor extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpatialAnchorAsyncBD(
    XrSenseDataProviderBD provider,
    const XrSpatialAnchorCreateInfoBD* info,
    XrFutureEXT* future) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpatialAnchorAsyncBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSpatialAnchorCreateInfoBD*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT*", "future", oss_future.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpatialAnchorAsyncBD(provider, info, future);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateSpatialAnchorCompleteBD(
    XrSenseDataProviderBD provider,
    XrFutureEXT future,
    XrSpatialAnchorCreateCompletionBD* completion) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateSpatialAnchorCompleteBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT", "future", oss_future.str());
        std::ostringstream oss_completion;
        oss_completion << std::hex << reinterpret_cast<const void*>(completion);
        contents.emplace_back("XrSpatialAnchorCreateCompletionBD*", "completion", oss_completion.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateSpatialAnchorCompleteBD(provider, future, completion);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrPersistSpatialAnchorAsyncBD(
    XrSenseDataProviderBD provider,
    const XrSpatialAnchorPersistInfoBD* info,
    XrFutureEXT* future) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrPersistSpatialAnchorAsyncBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSpatialAnchorPersistInfoBD*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT*", "future", oss_future.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->PersistSpatialAnchorAsyncBD(provider, info, future);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrPersistSpatialAnchorCompleteBD(
    XrSenseDataProviderBD provider,
    XrFutureEXT future,
    XrFutureCompletionEXT* completion) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrPersistSpatialAnchorCompleteBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT", "future", oss_future.str());
        std::ostringstream oss_completion;
        oss_completion << std::hex << reinterpret_cast<const void*>(completion);
        contents.emplace_back("XrFutureCompletionEXT*", "completion", oss_completion.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->PersistSpatialAnchorCompleteBD(provider, future, completion);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrUnpersistSpatialAnchorAsyncBD(
    XrSenseDataProviderBD provider,
    const XrSpatialAnchorUnpersistInfoBD* info,
    XrFutureEXT* future) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrUnpersistSpatialAnchorAsyncBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSpatialAnchorUnpersistInfoBD*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT*", "future", oss_future.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->UnpersistSpatialAnchorAsyncBD(provider, info, future);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrUnpersistSpatialAnchorCompleteBD(
    XrSenseDataProviderBD provider,
    XrFutureEXT future,
    XrFutureCompletionEXT* completion) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrUnpersistSpatialAnchorCompleteBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT", "future", oss_future.str());
        std::ostringstream oss_completion;
        oss_completion << std::hex << reinterpret_cast<const void*>(completion);
        contents.emplace_back("XrFutureCompletionEXT*", "completion", oss_completion.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->UnpersistSpatialAnchorCompleteBD(provider, future, completion);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_BD_spatial_anchor_sharing extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrShareSpatialAnchorAsyncBD(
    XrSenseDataProviderBD provider,
    const XrSpatialAnchorShareInfoBD* info,
    XrFutureEXT* future) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrShareSpatialAnchorAsyncBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSpatialAnchorShareInfoBD*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT*", "future", oss_future.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ShareSpatialAnchorAsyncBD(provider, info, future);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrShareSpatialAnchorCompleteBD(
    XrSenseDataProviderBD provider,
    XrFutureEXT future,
    XrFutureCompletionEXT* completion) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrShareSpatialAnchorCompleteBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT", "future", oss_future.str());
        std::ostringstream oss_completion;
        oss_completion << std::hex << reinterpret_cast<const void*>(completion);
        contents.emplace_back("XrFutureCompletionEXT*", "completion", oss_completion.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->ShareSpatialAnchorCompleteBD(provider, future, completion);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDownloadSharedSpatialAnchorAsyncBD(
    XrSenseDataProviderBD provider,
    const XrSharedSpatialAnchorDownloadInfoBD* info,
    XrFutureEXT* future) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDownloadSharedSpatialAnchorAsyncBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSharedSpatialAnchorDownloadInfoBD*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT*", "future", oss_future.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DownloadSharedSpatialAnchorAsyncBD(provider, info, future);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDownloadSharedSpatialAnchorCompleteBD(
    XrSenseDataProviderBD provider,
    XrFutureEXT future,
    XrFutureCompletionEXT* completion) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDownloadSharedSpatialAnchorCompleteBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT", "future", oss_future.str());
        std::ostringstream oss_completion;
        oss_completion << std::hex << reinterpret_cast<const void*>(completion);
        contents.emplace_back("XrFutureCompletionEXT*", "completion", oss_completion.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DownloadSharedSpatialAnchorCompleteBD(provider, future, completion);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_BD_spatial_scene extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCaptureSceneAsyncBD(
    XrSenseDataProviderBD provider,
    const XrSceneCaptureInfoBD* info,
    XrFutureEXT* future) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCaptureSceneAsyncBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSceneCaptureInfoBD*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT*", "future", oss_future.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CaptureSceneAsyncBD(provider, info, future);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCaptureSceneCompleteBD(
    XrSenseDataProviderBD provider,
    XrFutureEXT future,
    XrFutureCompletionEXT* completion) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_sensedataproviderbd_dispatch_mutex);
            auto map_iter = g_sensedataproviderbd_dispatch_map.find(provider);
            if (map_iter == g_sensedataproviderbd_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCaptureSceneCompleteBD", "");
        std::ostringstream oss_provider;
        oss_provider << std::hex << reinterpret_cast<const void*>(provider);
        contents.emplace_back("XrSenseDataProviderBD", "provider", oss_provider.str());
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT", "future", oss_future.str());
        std::ostringstream oss_completion;
        oss_completion << std::hex << reinterpret_cast<const void*>(completion);
        contents.emplace_back("XrFutureCompletionEXT*", "completion", oss_completion.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CaptureSceneCompleteBD(provider, future, completion);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_EXT_plane_detection extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreatePlaneDetectorEXT(
    XrSession session,
    const XrPlaneDetectorCreateInfoEXT* createInfo,
    XrPlaneDetectorEXT* planeDetector) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreatePlaneDetectorEXT", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrPlaneDetectorCreateInfoEXT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_planeDetector;
        oss_planeDetector << std::hex << reinterpret_cast<const void*>(planeDetector);
        contents.emplace_back("XrPlaneDetectorEXT*", "planeDetector", oss_planeDetector.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreatePlaneDetectorEXT(session, createInfo, planeDetector);
        if (XR_SUCCESS == result && nullptr != planeDetector) {
            auto exists = g_planedetectorext_dispatch_map.find(*planeDetector);
            if (exists == g_planedetectorext_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_planedetectorext_dispatch_mutex);
                g_planedetectorext_dispatch_map[*planeDetector] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyPlaneDetectorEXT(
    XrPlaneDetectorEXT planeDetector) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_planedetectorext_dispatch_mutex);
            auto map_iter = g_planedetectorext_dispatch_map.find(planeDetector);
            if (map_iter == g_planedetectorext_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyPlaneDetectorEXT", "");
        std::ostringstream oss_planeDetector;
        oss_planeDetector << std::hex << reinterpret_cast<const void*>(planeDetector);
        contents.emplace_back("XrPlaneDetectorEXT", "planeDetector", oss_planeDetector.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyPlaneDetectorEXT(planeDetector);
        auto exists = g_planedetectorext_dispatch_map.find(planeDetector);
        if (exists != g_planedetectorext_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_planedetectorext_dispatch_mutex);
            g_planedetectorext_dispatch_map.erase(planeDetector);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrBeginPlaneDetectionEXT(
    XrPlaneDetectorEXT planeDetector,
    const XrPlaneDetectorBeginInfoEXT* beginInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_planedetectorext_dispatch_mutex);
            auto map_iter = g_planedetectorext_dispatch_map.find(planeDetector);
            if (map_iter == g_planedetectorext_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrBeginPlaneDetectionEXT", "");
        std::ostringstream oss_planeDetector;
        oss_planeDetector << std::hex << reinterpret_cast<const void*>(planeDetector);
        contents.emplace_back("XrPlaneDetectorEXT", "planeDetector", oss_planeDetector.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, beginInfo, "beginInfo", "const XrPlaneDetectorBeginInfoEXT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->BeginPlaneDetectionEXT(planeDetector, beginInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetPlaneDetectionStateEXT(
    XrPlaneDetectorEXT planeDetector,
    XrPlaneDetectionStateEXT* state) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_planedetectorext_dispatch_mutex);
            auto map_iter = g_planedetectorext_dispatch_map.find(planeDetector);
            if (map_iter == g_planedetectorext_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetPlaneDetectionStateEXT", "");
        std::ostringstream oss_planeDetector;
        oss_planeDetector << std::hex << reinterpret_cast<const void*>(planeDetector);
        contents.emplace_back("XrPlaneDetectorEXT", "planeDetector", oss_planeDetector.str());
        std::ostringstream oss_state;
        oss_state << std::hex << reinterpret_cast<const void*>(state);
        contents.emplace_back("XrPlaneDetectionStateEXT*", "state", oss_state.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetPlaneDetectionStateEXT(planeDetector, state);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetPlaneDetectionsEXT(
    XrPlaneDetectorEXT planeDetector,
    const XrPlaneDetectorGetInfoEXT* info,
    XrPlaneDetectorLocationsEXT* locations) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_planedetectorext_dispatch_mutex);
            auto map_iter = g_planedetectorext_dispatch_map.find(planeDetector);
            if (map_iter == g_planedetectorext_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetPlaneDetectionsEXT", "");
        std::ostringstream oss_planeDetector;
        oss_planeDetector << std::hex << reinterpret_cast<const void*>(planeDetector);
        contents.emplace_back("XrPlaneDetectorEXT", "planeDetector", oss_planeDetector.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrPlaneDetectorGetInfoEXT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_locations;
        oss_locations << std::hex << reinterpret_cast<const void*>(locations);
        contents.emplace_back("XrPlaneDetectorLocationsEXT*", "locations", oss_locations.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetPlaneDetectionsEXT(planeDetector, info, locations);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetPlanePolygonBufferEXT(
    XrPlaneDetectorEXT planeDetector,
    uint64_t planeId,
    uint32_t polygonBufferIndex,
    XrPlaneDetectorPolygonBufferEXT* polygonBuffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_planedetectorext_dispatch_mutex);
            auto map_iter = g_planedetectorext_dispatch_map.find(planeDetector);
            if (map_iter == g_planedetectorext_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetPlanePolygonBufferEXT", "");
        std::ostringstream oss_planeDetector;
        oss_planeDetector << std::hex << reinterpret_cast<const void*>(planeDetector);
        contents.emplace_back("XrPlaneDetectorEXT", "planeDetector", oss_planeDetector.str());
        std::ostringstream oss_planeId;
        oss_planeId << "0x" << std::hex << (planeId);
        contents.emplace_back("uint64_t", "planeId", oss_planeId.str());
        std::ostringstream oss_polygonBufferIndex;
        oss_polygonBufferIndex << "0x" << std::hex << (polygonBufferIndex);
        contents.emplace_back("uint32_t", "polygonBufferIndex", oss_polygonBufferIndex.str());
        std::ostringstream oss_polygonBuffer;
        oss_polygonBuffer << std::hex << reinterpret_cast<const void*>(polygonBuffer);
        contents.emplace_back("XrPlaneDetectorPolygonBufferEXT*", "polygonBuffer", oss_polygonBuffer.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetPlanePolygonBufferEXT(planeDetector, planeId, polygonBufferIndex, polygonBuffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_EXT_future extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrPollFutureEXT(
    XrInstance instance,
    const XrFuturePollInfoEXT* pollInfo,
    XrFuturePollResultEXT* pollResult) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrPollFutureEXT", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, pollInfo, "pollInfo", "const XrFuturePollInfoEXT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_pollResult;
        oss_pollResult << std::hex << reinterpret_cast<const void*>(pollResult);
        contents.emplace_back("XrFuturePollResultEXT*", "pollResult", oss_pollResult.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->PollFutureEXT(instance, pollInfo, pollResult);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCancelFutureEXT(
    XrInstance instance,
    const XrFutureCancelInfoEXT* cancelInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCancelFutureEXT", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, cancelInfo, "cancelInfo", "const XrFutureCancelInfoEXT*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CancelFutureEXT(instance, cancelInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_ML_user_calibration extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrEnableUserCalibrationEventsML(
    XrInstance instance,
    const XrUserCalibrationEnableEventsInfoML* enableInfo) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrEnableUserCalibrationEventsML", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, enableInfo, "enableInfo", "const XrUserCalibrationEnableEventsInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->EnableUserCalibrationEventsML(instance, enableInfo);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_ML_system_notifications extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrSetSystemNotificationsML(
    XrInstance instance,
    const XrSystemNotificationsSetInfoML* info) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_instance_dispatch_mutex);
            auto map_iter = g_instance_dispatch_map.find(instance);
            if (map_iter == g_instance_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrSetSystemNotificationsML", "");
        std::ostringstream oss_instance;
        oss_instance << std::hex << reinterpret_cast<const void*>(instance);
        contents.emplace_back("XrInstance", "instance", oss_instance.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrSystemNotificationsSetInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->SetSystemNotificationsML(instance, info);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_ML_world_mesh_detection extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateWorldMeshDetectorML(
    XrSession session,
    const XrWorldMeshDetectorCreateInfoML* createInfo,
    XrWorldMeshDetectorML* detector) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateWorldMeshDetectorML", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrWorldMeshDetectorCreateInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_detector;
        oss_detector << std::hex << reinterpret_cast<const void*>(detector);
        contents.emplace_back("XrWorldMeshDetectorML*", "detector", oss_detector.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateWorldMeshDetectorML(session, createInfo, detector);
        if (XR_SUCCESS == result && nullptr != detector) {
            auto exists = g_worldmeshdetectorml_dispatch_map.find(*detector);
            if (exists == g_worldmeshdetectorml_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_worldmeshdetectorml_dispatch_mutex);
                g_worldmeshdetectorml_dispatch_map[*detector] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyWorldMeshDetectorML(
    XrWorldMeshDetectorML detector) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_worldmeshdetectorml_dispatch_mutex);
            auto map_iter = g_worldmeshdetectorml_dispatch_map.find(detector);
            if (map_iter == g_worldmeshdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyWorldMeshDetectorML", "");
        std::ostringstream oss_detector;
        oss_detector << std::hex << reinterpret_cast<const void*>(detector);
        contents.emplace_back("XrWorldMeshDetectorML", "detector", oss_detector.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyWorldMeshDetectorML(detector);
        auto exists = g_worldmeshdetectorml_dispatch_map.find(detector);
        if (exists != g_worldmeshdetectorml_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_worldmeshdetectorml_dispatch_mutex);
            g_worldmeshdetectorml_dispatch_map.erase(detector);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrRequestWorldMeshStateAsyncML(
    XrWorldMeshDetectorML detector,
    const XrWorldMeshStateRequestInfoML* stateRequest,
    XrFutureEXT* future) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_worldmeshdetectorml_dispatch_mutex);
            auto map_iter = g_worldmeshdetectorml_dispatch_map.find(detector);
            if (map_iter == g_worldmeshdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrRequestWorldMeshStateAsyncML", "");
        std::ostringstream oss_detector;
        oss_detector << std::hex << reinterpret_cast<const void*>(detector);
        contents.emplace_back("XrWorldMeshDetectorML", "detector", oss_detector.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, stateRequest, "stateRequest", "const XrWorldMeshStateRequestInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT*", "future", oss_future.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->RequestWorldMeshStateAsyncML(detector, stateRequest, future);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrRequestWorldMeshStateCompleteML(
    XrWorldMeshDetectorML detector,
    XrFutureEXT future,
    XrWorldMeshStateRequestCompletionML* completion) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_worldmeshdetectorml_dispatch_mutex);
            auto map_iter = g_worldmeshdetectorml_dispatch_map.find(detector);
            if (map_iter == g_worldmeshdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrRequestWorldMeshStateCompleteML", "");
        std::ostringstream oss_detector;
        oss_detector << std::hex << reinterpret_cast<const void*>(detector);
        contents.emplace_back("XrWorldMeshDetectorML", "detector", oss_detector.str());
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT", "future", oss_future.str());
        std::ostringstream oss_completion;
        oss_completion << std::hex << reinterpret_cast<const void*>(completion);
        contents.emplace_back("XrWorldMeshStateRequestCompletionML*", "completion", oss_completion.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->RequestWorldMeshStateCompleteML(detector, future, completion);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetWorldMeshBufferRecommendSizeML(
    XrWorldMeshDetectorML detector,
    const XrWorldMeshBufferRecommendedSizeInfoML* sizeInfo,
    XrWorldMeshBufferSizeML* size) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_worldmeshdetectorml_dispatch_mutex);
            auto map_iter = g_worldmeshdetectorml_dispatch_map.find(detector);
            if (map_iter == g_worldmeshdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetWorldMeshBufferRecommendSizeML", "");
        std::ostringstream oss_detector;
        oss_detector << std::hex << reinterpret_cast<const void*>(detector);
        contents.emplace_back("XrWorldMeshDetectorML", "detector", oss_detector.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, sizeInfo, "sizeInfo", "const XrWorldMeshBufferRecommendedSizeInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_size;
        oss_size << std::hex << reinterpret_cast<const void*>(size);
        contents.emplace_back("XrWorldMeshBufferSizeML*", "size", oss_size.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetWorldMeshBufferRecommendSizeML(detector, sizeInfo, size);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrAllocateWorldMeshBufferML(
    XrWorldMeshDetectorML detector,
    const XrWorldMeshBufferSizeML* size,
    XrWorldMeshBufferML* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_worldmeshdetectorml_dispatch_mutex);
            auto map_iter = g_worldmeshdetectorml_dispatch_map.find(detector);
            if (map_iter == g_worldmeshdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrAllocateWorldMeshBufferML", "");
        std::ostringstream oss_detector;
        oss_detector << std::hex << reinterpret_cast<const void*>(detector);
        contents.emplace_back("XrWorldMeshDetectorML", "detector", oss_detector.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, size, "size", "const XrWorldMeshBufferSizeML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_buffer;
        oss_buffer << std::hex << reinterpret_cast<const void*>(buffer);
        contents.emplace_back("XrWorldMeshBufferML*", "buffer", oss_buffer.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->AllocateWorldMeshBufferML(detector, size, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrFreeWorldMeshBufferML(
    XrWorldMeshDetectorML detector,
    const XrWorldMeshBufferML* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_worldmeshdetectorml_dispatch_mutex);
            auto map_iter = g_worldmeshdetectorml_dispatch_map.find(detector);
            if (map_iter == g_worldmeshdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrFreeWorldMeshBufferML", "");
        std::ostringstream oss_detector;
        oss_detector << std::hex << reinterpret_cast<const void*>(detector);
        contents.emplace_back("XrWorldMeshDetectorML", "detector", oss_detector.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, buffer, "buffer", "const XrWorldMeshBufferML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->FreeWorldMeshBufferML(detector, buffer);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrRequestWorldMeshAsyncML(
    XrWorldMeshDetectorML detector,
    const XrWorldMeshGetInfoML* getInfo,
    XrWorldMeshBufferML* buffer,
    XrFutureEXT* future) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_worldmeshdetectorml_dispatch_mutex);
            auto map_iter = g_worldmeshdetectorml_dispatch_map.find(detector);
            if (map_iter == g_worldmeshdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrRequestWorldMeshAsyncML", "");
        std::ostringstream oss_detector;
        oss_detector << std::hex << reinterpret_cast<const void*>(detector);
        contents.emplace_back("XrWorldMeshDetectorML", "detector", oss_detector.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, getInfo, "getInfo", "const XrWorldMeshGetInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_buffer;
        oss_buffer << std::hex << reinterpret_cast<const void*>(buffer);
        contents.emplace_back("XrWorldMeshBufferML*", "buffer", oss_buffer.str());
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT*", "future", oss_future.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->RequestWorldMeshAsyncML(detector, getInfo, buffer, future);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrRequestWorldMeshCompleteML(
    XrWorldMeshDetectorML detector,
    const XrWorldMeshRequestCompletionInfoML* completionInfo,
    XrFutureEXT future,
    XrWorldMeshRequestCompletionML* completion) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_worldmeshdetectorml_dispatch_mutex);
            auto map_iter = g_worldmeshdetectorml_dispatch_map.find(detector);
            if (map_iter == g_worldmeshdetectorml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrRequestWorldMeshCompleteML", "");
        std::ostringstream oss_detector;
        oss_detector << std::hex << reinterpret_cast<const void*>(detector);
        contents.emplace_back("XrWorldMeshDetectorML", "detector", oss_detector.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, completionInfo, "completionInfo", "const XrWorldMeshRequestCompletionInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_future;
        oss_future << std::hex << reinterpret_cast<const void*>(future);
        contents.emplace_back("XrFutureEXT", "future", oss_future.str());
        std::ostringstream oss_completion;
        oss_completion << std::hex << reinterpret_cast<const void*>(completion);
        contents.emplace_back("XrWorldMeshRequestCompletionML*", "completion", oss_completion.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->RequestWorldMeshCompleteML(detector, completionInfo, future, completion);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_ML_facial_expression extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrCreateFacialExpressionClientML(
    XrSession session,
    const XrFacialExpressionClientCreateInfoML* createInfo,
    XrFacialExpressionClientML* facialExpressionClient) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrCreateFacialExpressionClientML", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, createInfo, "createInfo", "const XrFacialExpressionClientCreateInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_facialExpressionClient;
        oss_facialExpressionClient << std::hex << reinterpret_cast<const void*>(facialExpressionClient);
        contents.emplace_back("XrFacialExpressionClientML*", "facialExpressionClient", oss_facialExpressionClient.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->CreateFacialExpressionClientML(session, createInfo, facialExpressionClient);
        if (XR_SUCCESS == result && nullptr != facialExpressionClient) {
            auto exists = g_facialexpressionclientml_dispatch_map.find(*facialExpressionClient);
            if (exists == g_facialexpressionclientml_dispatch_map.end()) {
                std::unique_lock<std::mutex> lock(g_facialexpressionclientml_dispatch_mutex);
                g_facialexpressionclientml_dispatch_map[*facialExpressionClient] = gen_dispatch_table;
            }
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrDestroyFacialExpressionClientML(
    XrFacialExpressionClientML facialExpressionClient) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_facialexpressionclientml_dispatch_mutex);
            auto map_iter = g_facialexpressionclientml_dispatch_map.find(facialExpressionClient);
            if (map_iter == g_facialexpressionclientml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrDestroyFacialExpressionClientML", "");
        std::ostringstream oss_facialExpressionClient;
        oss_facialExpressionClient << std::hex << reinterpret_cast<const void*>(facialExpressionClient);
        contents.emplace_back("XrFacialExpressionClientML", "facialExpressionClient", oss_facialExpressionClient.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->DestroyFacialExpressionClientML(facialExpressionClient);
        auto exists = g_facialexpressionclientml_dispatch_map.find(facialExpressionClient);
        if (exists != g_facialexpressionclientml_dispatch_map.end()) {
            std::unique_lock<std::mutex> lock(g_facialexpressionclientml_dispatch_mutex);
            g_facialexpressionclientml_dispatch_map.erase(facialExpressionClient);
        }
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrGetFacialExpressionBlendShapePropertiesML(
    XrFacialExpressionClientML facialExpressionClient,
    const XrFacialExpressionBlendShapeGetInfoML* blendShapeGetInfo,
    uint32_t blendShapeCount,
    XrFacialExpressionBlendShapePropertiesML* blendShapes) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_facialexpressionclientml_dispatch_mutex);
            auto map_iter = g_facialexpressionclientml_dispatch_map.find(facialExpressionClient);
            if (map_iter == g_facialexpressionclientml_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrGetFacialExpressionBlendShapePropertiesML", "");
        std::ostringstream oss_facialExpressionClient;
        oss_facialExpressionClient << std::hex << reinterpret_cast<const void*>(facialExpressionClient);
        contents.emplace_back("XrFacialExpressionClientML", "facialExpressionClient", oss_facialExpressionClient.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, blendShapeGetInfo, "blendShapeGetInfo", "const XrFacialExpressionBlendShapeGetInfoML*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_blendShapeCount;
        oss_blendShapeCount << "0x" << std::hex << (blendShapeCount);
        contents.emplace_back("uint32_t", "blendShapeCount", oss_blendShapeCount.str());
        std::ostringstream oss_blendShapes;
        oss_blendShapes << std::hex << reinterpret_cast<const void*>(blendShapes);
        contents.emplace_back("XrFacialExpressionBlendShapePropertiesML*", "blendShapes", oss_blendShapes.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->GetFacialExpressionBlendShapePropertiesML(facialExpressionClient, blendShapeGetInfo, blendShapeCount, blendShapes);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_META_colocation_discovery extension commands
XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrStartColocationDiscoveryMETA(
    XrSession session,
    const XrColocationDiscoveryStartInfoMETA* info,
    XrAsyncRequestIdFB* discoveryRequestId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrStartColocationDiscoveryMETA", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrColocationDiscoveryStartInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_discoveryRequestId;
        oss_discoveryRequestId << std::hex << reinterpret_cast<const void*>(discoveryRequestId);
        contents.emplace_back("XrAsyncRequestIdFB*", "discoveryRequestId", oss_discoveryRequestId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->StartColocationDiscoveryMETA(session, info, discoveryRequestId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrStopColocationDiscoveryMETA(
    XrSession session,
    const XrColocationDiscoveryStopInfoMETA* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrStopColocationDiscoveryMETA", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrColocationDiscoveryStopInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_requestId;
        oss_requestId << std::hex << reinterpret_cast<const void*>(requestId);
        contents.emplace_back("XrAsyncRequestIdFB*", "requestId", oss_requestId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->StopColocationDiscoveryMETA(session, info, requestId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrStartColocationAdvertisementMETA(
    XrSession session,
    const XrColocationAdvertisementStartInfoMETA* info,
    XrAsyncRequestIdFB* advertisementRequestId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrStartColocationAdvertisementMETA", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrColocationAdvertisementStartInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_advertisementRequestId;
        oss_advertisementRequestId << std::hex << reinterpret_cast<const void*>(advertisementRequestId);
        contents.emplace_back("XrAsyncRequestIdFB*", "advertisementRequestId", oss_advertisementRequestId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->StartColocationAdvertisementMETA(session, info, advertisementRequestId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL ApiDumpLayerXrStopColocationAdvertisementMETA(
    XrSession session,
    const XrColocationAdvertisementStopInfoMETA* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        // Generate output for this command
        std::vector<std::tuple<std::string, std::string, std::string>> contents;
        XrGeneratedDispatchTable *gen_dispatch_table = nullptr;

        {
            std::unique_lock<std::mutex> mlock(g_session_dispatch_mutex);
            auto map_iter = g_session_dispatch_map.find(session);
            if (map_iter == g_session_dispatch_map.end()) {
                return XR_ERROR_VALIDATION_FAILURE;
            }
            gen_dispatch_table = map_iter->second;
        }

        contents.emplace_back("XrResult", "xrStopColocationAdvertisementMETA", "");
        std::ostringstream oss_session;
        oss_session << std::hex << reinterpret_cast<const void*>(session);
        contents.emplace_back("XrSession", "session", oss_session.str());
        if (!ApiDumpOutputXrStruct(gen_dispatch_table, info, "info", "const XrColocationAdvertisementStopInfoMETA*", true, contents)) {
            throw std::invalid_argument("Invalid Operation");
        }
        std::ostringstream oss_requestId;
        oss_requestId << std::hex << reinterpret_cast<const void*>(requestId);
        contents.emplace_back("XrAsyncRequestIdFB*", "requestId", oss_requestId.str());
        ApiDumpLayerRecordContent(contents);

        result = gen_dispatch_table->StopColocationAdvertisementMETA(session, info, requestId);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

PFN_xrVoidFunction ApiDumpLayerInnerGetInstanceProcAddr(
    const char*                                 name) {
        std::string func_name = name;


        // ---- Core 1.0 commands
        if (func_name == "xrGetInstanceProcAddr") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetInstanceProcAddr);
        }
        if (func_name == "xrCreateInstance") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateInstance);
        }
        if (func_name == "xrDestroyInstance") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyInstance);
        }
        if (func_name == "xrGetInstanceProperties") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetInstanceProperties);
        }
        if (func_name == "xrPollEvent") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrPollEvent);
        }
        if (func_name == "xrResultToString") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrResultToString);
        }
        if (func_name == "xrStructureTypeToString") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrStructureTypeToString);
        }
        if (func_name == "xrGetSystem") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSystem);
        }
        if (func_name == "xrGetSystemProperties") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSystemProperties);
        }
        if (func_name == "xrEnumerateEnvironmentBlendModes") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateEnvironmentBlendModes);
        }
        if (func_name == "xrCreateSession") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSession);
        }
        if (func_name == "xrDestroySession") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroySession);
        }
        if (func_name == "xrEnumerateReferenceSpaces") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateReferenceSpaces);
        }
        if (func_name == "xrCreateReferenceSpace") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateReferenceSpace);
        }
        if (func_name == "xrGetReferenceSpaceBoundsRect") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetReferenceSpaceBoundsRect);
        }
        if (func_name == "xrCreateActionSpace") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateActionSpace);
        }
        if (func_name == "xrLocateSpace") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrLocateSpace);
        }
        if (func_name == "xrDestroySpace") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroySpace);
        }
        if (func_name == "xrEnumerateViewConfigurations") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateViewConfigurations);
        }
        if (func_name == "xrGetViewConfigurationProperties") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetViewConfigurationProperties);
        }
        if (func_name == "xrEnumerateViewConfigurationViews") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateViewConfigurationViews);
        }
        if (func_name == "xrEnumerateSwapchainFormats") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateSwapchainFormats);
        }
        if (func_name == "xrCreateSwapchain") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSwapchain);
        }
        if (func_name == "xrDestroySwapchain") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroySwapchain);
        }
        if (func_name == "xrEnumerateSwapchainImages") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateSwapchainImages);
        }
        if (func_name == "xrAcquireSwapchainImage") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrAcquireSwapchainImage);
        }
        if (func_name == "xrWaitSwapchainImage") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrWaitSwapchainImage);
        }
        if (func_name == "xrReleaseSwapchainImage") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrReleaseSwapchainImage);
        }
        if (func_name == "xrBeginSession") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrBeginSession);
        }
        if (func_name == "xrEndSession") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEndSession);
        }
        if (func_name == "xrRequestExitSession") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrRequestExitSession);
        }
        if (func_name == "xrWaitFrame") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrWaitFrame);
        }
        if (func_name == "xrBeginFrame") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrBeginFrame);
        }
        if (func_name == "xrEndFrame") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEndFrame);
        }
        if (func_name == "xrLocateViews") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrLocateViews);
        }
        if (func_name == "xrStringToPath") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrStringToPath);
        }
        if (func_name == "xrPathToString") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrPathToString);
        }
        if (func_name == "xrCreateActionSet") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateActionSet);
        }
        if (func_name == "xrDestroyActionSet") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyActionSet);
        }
        if (func_name == "xrCreateAction") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateAction);
        }
        if (func_name == "xrDestroyAction") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyAction);
        }
        if (func_name == "xrSuggestInteractionProfileBindings") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSuggestInteractionProfileBindings);
        }
        if (func_name == "xrAttachSessionActionSets") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrAttachSessionActionSets);
        }
        if (func_name == "xrGetCurrentInteractionProfile") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetCurrentInteractionProfile);
        }
        if (func_name == "xrGetActionStateBoolean") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetActionStateBoolean);
        }
        if (func_name == "xrGetActionStateFloat") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetActionStateFloat);
        }
        if (func_name == "xrGetActionStateVector2f") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetActionStateVector2f);
        }
        if (func_name == "xrGetActionStatePose") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetActionStatePose);
        }
        if (func_name == "xrSyncActions") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSyncActions);
        }
        if (func_name == "xrEnumerateBoundSourcesForAction") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateBoundSourcesForAction);
        }
        if (func_name == "xrGetInputSourceLocalizedName") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetInputSourceLocalizedName);
        }
        if (func_name == "xrApplyHapticFeedback") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrApplyHapticFeedback);
        }
        if (func_name == "xrStopHapticFeedback") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrStopHapticFeedback);
        }

        // ---- XR_LOADER_VERSION_1_0 extension commands

        // ---- Core 1.1 commands
        if (func_name == "xrLocateSpaces") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrLocateSpaces);
        }

        // ---- XR_KHR_android_thread_settings extension commands
#if defined(XR_USE_PLATFORM_ANDROID)
        if (func_name == "xrSetAndroidApplicationThreadKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetAndroidApplicationThreadKHR);
        }
#endif // defined(XR_USE_PLATFORM_ANDROID)

        // ---- XR_KHR_android_surface_swapchain extension commands
#if defined(XR_USE_PLATFORM_ANDROID)
        if (func_name == "xrCreateSwapchainAndroidSurfaceKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSwapchainAndroidSurfaceKHR);
        }
#endif // defined(XR_USE_PLATFORM_ANDROID)

        // ---- XR_KHR_opengl_enable extension commands
#if defined(XR_USE_GRAPHICS_API_OPENGL)
        if (func_name == "xrGetOpenGLGraphicsRequirementsKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetOpenGLGraphicsRequirementsKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL)

        // ---- XR_KHR_opengl_es_enable extension commands
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
        if (func_name == "xrGetOpenGLESGraphicsRequirementsKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetOpenGLESGraphicsRequirementsKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)

        // ---- XR_KHR_vulkan_enable extension commands
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrGetVulkanInstanceExtensionsKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetVulkanInstanceExtensionsKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrGetVulkanDeviceExtensionsKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetVulkanDeviceExtensionsKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrGetVulkanGraphicsDeviceKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetVulkanGraphicsDeviceKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrGetVulkanGraphicsRequirementsKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetVulkanGraphicsRequirementsKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

        // ---- XR_KHR_D3D11_enable extension commands
#if defined(XR_USE_GRAPHICS_API_D3D11)
        if (func_name == "xrGetD3D11GraphicsRequirementsKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetD3D11GraphicsRequirementsKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_D3D11)

        // ---- XR_KHR_D3D12_enable extension commands
#if defined(XR_USE_GRAPHICS_API_D3D12)
        if (func_name == "xrGetD3D12GraphicsRequirementsKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetD3D12GraphicsRequirementsKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_D3D12)

        // ---- XR_KHR_metal_enable extension commands
#if defined(XR_USE_GRAPHICS_API_METAL)
        if (func_name == "xrGetMetalGraphicsRequirementsKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetMetalGraphicsRequirementsKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_METAL)

        // ---- XR_KHR_visibility_mask extension commands
        if (func_name == "xrGetVisibilityMaskKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetVisibilityMaskKHR);
        }

        // ---- XR_KHR_win32_convert_performance_counter_time extension commands
#if defined(XR_USE_PLATFORM_WIN32)
        if (func_name == "xrConvertWin32PerformanceCounterToTimeKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrConvertWin32PerformanceCounterToTimeKHR);
        }
#endif // defined(XR_USE_PLATFORM_WIN32)
#if defined(XR_USE_PLATFORM_WIN32)
        if (func_name == "xrConvertTimeToWin32PerformanceCounterKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrConvertTimeToWin32PerformanceCounterKHR);
        }
#endif // defined(XR_USE_PLATFORM_WIN32)

        // ---- XR_KHR_convert_timespec_time extension commands
#if defined(XR_USE_TIMESPEC)
        if (func_name == "xrConvertTimespecTimeToTimeKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrConvertTimespecTimeToTimeKHR);
        }
#endif // defined(XR_USE_TIMESPEC)
#if defined(XR_USE_TIMESPEC)
        if (func_name == "xrConvertTimeToTimespecTimeKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrConvertTimeToTimespecTimeKHR);
        }
#endif // defined(XR_USE_TIMESPEC)

        // ---- XR_KHR_loader_init extension commands

        // ---- XR_KHR_vulkan_enable2 extension commands
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrCreateVulkanInstanceKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateVulkanInstanceKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrCreateVulkanDeviceKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateVulkanDeviceKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrGetVulkanGraphicsDevice2KHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetVulkanGraphicsDevice2KHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrGetVulkanGraphicsRequirements2KHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetVulkanGraphicsRequirements2KHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

        // ---- XR_KHR_extended_struct_name_lengths extension commands
        if (func_name == "xrStructureTypeToString2KHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrStructureTypeToString2KHR);
        }

        // ---- XR_KHR_locate_spaces extension commands
        if (func_name == "xrLocateSpacesKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrLocateSpacesKHR);
        }

        // ---- XR_EXT_performance_settings extension commands
        if (func_name == "xrPerfSettingsSetPerformanceLevelEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrPerfSettingsSetPerformanceLevelEXT);
        }

        // ---- XR_EXT_thermal_query extension commands
        if (func_name == "xrThermalGetTemperatureTrendEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrThermalGetTemperatureTrendEXT);
        }

        // ---- XR_EXT_debug_utils extension commands
        if (func_name == "xrSetDebugUtilsObjectNameEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetDebugUtilsObjectNameEXT);
        }
        if (func_name == "xrCreateDebugUtilsMessengerEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateDebugUtilsMessengerEXT);
        }
        if (func_name == "xrDestroyDebugUtilsMessengerEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyDebugUtilsMessengerEXT);
        }
        if (func_name == "xrSubmitDebugUtilsMessageEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSubmitDebugUtilsMessageEXT);
        }
        if (func_name == "xrSessionBeginDebugUtilsLabelRegionEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSessionBeginDebugUtilsLabelRegionEXT);
        }
        if (func_name == "xrSessionEndDebugUtilsLabelRegionEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSessionEndDebugUtilsLabelRegionEXT);
        }
        if (func_name == "xrSessionInsertDebugUtilsLabelEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSessionInsertDebugUtilsLabelEXT);
        }

        // ---- XR_MSFT_spatial_anchor extension commands
        if (func_name == "xrCreateSpatialAnchorMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpatialAnchorMSFT);
        }
        if (func_name == "xrCreateSpatialAnchorSpaceMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpatialAnchorSpaceMSFT);
        }
        if (func_name == "xrDestroySpatialAnchorMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroySpatialAnchorMSFT);
        }

        // ---- XR_EXT_conformance_automation extension commands
        if (func_name == "xrSetInputDeviceActiveEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetInputDeviceActiveEXT);
        }
        if (func_name == "xrSetInputDeviceStateBoolEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetInputDeviceStateBoolEXT);
        }
        if (func_name == "xrSetInputDeviceStateFloatEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetInputDeviceStateFloatEXT);
        }
        if (func_name == "xrSetInputDeviceStateVector2fEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetInputDeviceStateVector2fEXT);
        }
        if (func_name == "xrSetInputDeviceLocationEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetInputDeviceLocationEXT);
        }

        // ---- XR_MSFT_spatial_graph_bridge extension commands
        if (func_name == "xrCreateSpatialGraphNodeSpaceMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpatialGraphNodeSpaceMSFT);
        }
        if (func_name == "xrTryCreateSpatialGraphStaticNodeBindingMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrTryCreateSpatialGraphStaticNodeBindingMSFT);
        }
        if (func_name == "xrDestroySpatialGraphNodeBindingMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroySpatialGraphNodeBindingMSFT);
        }
        if (func_name == "xrGetSpatialGraphNodeBindingPropertiesMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSpatialGraphNodeBindingPropertiesMSFT);
        }

        // ---- XR_EXT_hand_tracking extension commands
        if (func_name == "xrCreateHandTrackerEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateHandTrackerEXT);
        }
        if (func_name == "xrDestroyHandTrackerEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyHandTrackerEXT);
        }
        if (func_name == "xrLocateHandJointsEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrLocateHandJointsEXT);
        }

        // ---- XR_MSFT_hand_tracking_mesh extension commands
        if (func_name == "xrCreateHandMeshSpaceMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateHandMeshSpaceMSFT);
        }
        if (func_name == "xrUpdateHandMeshMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrUpdateHandMeshMSFT);
        }

        // ---- XR_MSFT_controller_model extension commands
        if (func_name == "xrGetControllerModelKeyMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetControllerModelKeyMSFT);
        }
        if (func_name == "xrLoadControllerModelMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrLoadControllerModelMSFT);
        }
        if (func_name == "xrGetControllerModelPropertiesMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetControllerModelPropertiesMSFT);
        }
        if (func_name == "xrGetControllerModelStateMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetControllerModelStateMSFT);
        }

        // ---- XR_MSFT_perception_anchor_interop extension commands
#if defined(XR_USE_PLATFORM_WIN32)
        if (func_name == "xrCreateSpatialAnchorFromPerceptionAnchorMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpatialAnchorFromPerceptionAnchorMSFT);
        }
#endif // defined(XR_USE_PLATFORM_WIN32)
#if defined(XR_USE_PLATFORM_WIN32)
        if (func_name == "xrTryGetPerceptionAnchorFromSpatialAnchorMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrTryGetPerceptionAnchorFromSpatialAnchorMSFT);
        }
#endif // defined(XR_USE_PLATFORM_WIN32)

        // ---- XR_MSFT_composition_layer_reprojection extension commands
        if (func_name == "xrEnumerateReprojectionModesMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateReprojectionModesMSFT);
        }

        // ---- XR_FB_swapchain_update_state extension commands
        if (func_name == "xrUpdateSwapchainFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrUpdateSwapchainFB);
        }
        if (func_name == "xrGetSwapchainStateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSwapchainStateFB);
        }

        // ---- XR_FB_body_tracking extension commands
        if (func_name == "xrCreateBodyTrackerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateBodyTrackerFB);
        }
        if (func_name == "xrDestroyBodyTrackerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyBodyTrackerFB);
        }
        if (func_name == "xrLocateBodyJointsFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrLocateBodyJointsFB);
        }
        if (func_name == "xrGetBodySkeletonFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetBodySkeletonFB);
        }

        // ---- XR_MSFT_scene_understanding extension commands
        if (func_name == "xrEnumerateSceneComputeFeaturesMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateSceneComputeFeaturesMSFT);
        }
        if (func_name == "xrCreateSceneObserverMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSceneObserverMSFT);
        }
        if (func_name == "xrDestroySceneObserverMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroySceneObserverMSFT);
        }
        if (func_name == "xrCreateSceneMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSceneMSFT);
        }
        if (func_name == "xrDestroySceneMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroySceneMSFT);
        }
        if (func_name == "xrComputeNewSceneMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrComputeNewSceneMSFT);
        }
        if (func_name == "xrGetSceneComputeStateMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSceneComputeStateMSFT);
        }
        if (func_name == "xrGetSceneComponentsMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSceneComponentsMSFT);
        }
        if (func_name == "xrLocateSceneComponentsMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrLocateSceneComponentsMSFT);
        }
        if (func_name == "xrGetSceneMeshBuffersMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSceneMeshBuffersMSFT);
        }

        // ---- XR_MSFT_scene_understanding_serialization extension commands
        if (func_name == "xrDeserializeSceneMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDeserializeSceneMSFT);
        }
        if (func_name == "xrGetSerializedSceneFragmentDataMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSerializedSceneFragmentDataMSFT);
        }

        // ---- XR_FB_display_refresh_rate extension commands
        if (func_name == "xrEnumerateDisplayRefreshRatesFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateDisplayRefreshRatesFB);
        }
        if (func_name == "xrGetDisplayRefreshRateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetDisplayRefreshRateFB);
        }
        if (func_name == "xrRequestDisplayRefreshRateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrRequestDisplayRefreshRateFB);
        }

        // ---- XR_HTCX_vive_tracker_interaction extension commands
        if (func_name == "xrEnumerateViveTrackerPathsHTCX") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateViveTrackerPathsHTCX);
        }

        // ---- XR_HTC_facial_tracking extension commands
        if (func_name == "xrCreateFacialTrackerHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateFacialTrackerHTC);
        }
        if (func_name == "xrDestroyFacialTrackerHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyFacialTrackerHTC);
        }
        if (func_name == "xrGetFacialExpressionsHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetFacialExpressionsHTC);
        }

        // ---- XR_FB_color_space extension commands
        if (func_name == "xrEnumerateColorSpacesFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateColorSpacesFB);
        }
        if (func_name == "xrSetColorSpaceFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetColorSpaceFB);
        }

        // ---- XR_FB_hand_tracking_mesh extension commands
        if (func_name == "xrGetHandMeshFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetHandMeshFB);
        }

        // ---- XR_FB_spatial_entity extension commands
        if (func_name == "xrCreateSpatialAnchorFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpatialAnchorFB);
        }
        if (func_name == "xrGetSpaceUuidFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSpaceUuidFB);
        }
        if (func_name == "xrEnumerateSpaceSupportedComponentsFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateSpaceSupportedComponentsFB);
        }
        if (func_name == "xrSetSpaceComponentStatusFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetSpaceComponentStatusFB);
        }
        if (func_name == "xrGetSpaceComponentStatusFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSpaceComponentStatusFB);
        }

        // ---- XR_FB_foveation extension commands
        if (func_name == "xrCreateFoveationProfileFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateFoveationProfileFB);
        }
        if (func_name == "xrDestroyFoveationProfileFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyFoveationProfileFB);
        }

        // ---- XR_FB_keyboard_tracking extension commands
        if (func_name == "xrQuerySystemTrackedKeyboardFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrQuerySystemTrackedKeyboardFB);
        }
        if (func_name == "xrCreateKeyboardSpaceFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateKeyboardSpaceFB);
        }

        // ---- XR_FB_triangle_mesh extension commands
        if (func_name == "xrCreateTriangleMeshFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateTriangleMeshFB);
        }
        if (func_name == "xrDestroyTriangleMeshFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyTriangleMeshFB);
        }
        if (func_name == "xrTriangleMeshGetVertexBufferFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrTriangleMeshGetVertexBufferFB);
        }
        if (func_name == "xrTriangleMeshGetIndexBufferFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrTriangleMeshGetIndexBufferFB);
        }
        if (func_name == "xrTriangleMeshBeginUpdateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrTriangleMeshBeginUpdateFB);
        }
        if (func_name == "xrTriangleMeshEndUpdateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrTriangleMeshEndUpdateFB);
        }
        if (func_name == "xrTriangleMeshBeginVertexBufferUpdateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrTriangleMeshBeginVertexBufferUpdateFB);
        }
        if (func_name == "xrTriangleMeshEndVertexBufferUpdateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrTriangleMeshEndVertexBufferUpdateFB);
        }

        // ---- XR_FB_passthrough extension commands
        if (func_name == "xrCreatePassthroughFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreatePassthroughFB);
        }
        if (func_name == "xrDestroyPassthroughFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyPassthroughFB);
        }
        if (func_name == "xrPassthroughStartFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrPassthroughStartFB);
        }
        if (func_name == "xrPassthroughPauseFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrPassthroughPauseFB);
        }
        if (func_name == "xrCreatePassthroughLayerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreatePassthroughLayerFB);
        }
        if (func_name == "xrDestroyPassthroughLayerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyPassthroughLayerFB);
        }
        if (func_name == "xrPassthroughLayerPauseFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrPassthroughLayerPauseFB);
        }
        if (func_name == "xrPassthroughLayerResumeFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrPassthroughLayerResumeFB);
        }
        if (func_name == "xrPassthroughLayerSetStyleFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrPassthroughLayerSetStyleFB);
        }
        if (func_name == "xrCreateGeometryInstanceFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateGeometryInstanceFB);
        }
        if (func_name == "xrDestroyGeometryInstanceFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyGeometryInstanceFB);
        }
        if (func_name == "xrGeometryInstanceSetTransformFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGeometryInstanceSetTransformFB);
        }

        // ---- XR_FB_render_model extension commands
        if (func_name == "xrEnumerateRenderModelPathsFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateRenderModelPathsFB);
        }
        if (func_name == "xrGetRenderModelPropertiesFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetRenderModelPropertiesFB);
        }
        if (func_name == "xrLoadRenderModelFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrLoadRenderModelFB);
        }

        // ---- XR_VARJO_environment_depth_estimation extension commands
        if (func_name == "xrSetEnvironmentDepthEstimationVARJO") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetEnvironmentDepthEstimationVARJO);
        }

        // ---- XR_VARJO_marker_tracking extension commands
        if (func_name == "xrSetMarkerTrackingVARJO") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetMarkerTrackingVARJO);
        }
        if (func_name == "xrSetMarkerTrackingTimeoutVARJO") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetMarkerTrackingTimeoutVARJO);
        }
        if (func_name == "xrSetMarkerTrackingPredictionVARJO") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetMarkerTrackingPredictionVARJO);
        }
        if (func_name == "xrGetMarkerSizeVARJO") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetMarkerSizeVARJO);
        }
        if (func_name == "xrCreateMarkerSpaceVARJO") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateMarkerSpaceVARJO);
        }

        // ---- XR_VARJO_view_offset extension commands
        if (func_name == "xrSetViewOffsetVARJO") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetViewOffsetVARJO);
        }

        // ---- XR_ML_compat extension commands
#if defined(XR_USE_PLATFORM_ML)
        if (func_name == "xrCreateSpaceFromCoordinateFrameUIDML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpaceFromCoordinateFrameUIDML);
        }
#endif // defined(XR_USE_PLATFORM_ML)

        // ---- XR_ML_marker_understanding extension commands
        if (func_name == "xrCreateMarkerDetectorML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateMarkerDetectorML);
        }
        if (func_name == "xrDestroyMarkerDetectorML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyMarkerDetectorML);
        }
        if (func_name == "xrSnapshotMarkerDetectorML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSnapshotMarkerDetectorML);
        }
        if (func_name == "xrGetMarkerDetectorStateML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetMarkerDetectorStateML);
        }
        if (func_name == "xrGetMarkersML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetMarkersML);
        }
        if (func_name == "xrGetMarkerReprojectionErrorML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetMarkerReprojectionErrorML);
        }
        if (func_name == "xrGetMarkerLengthML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetMarkerLengthML);
        }
        if (func_name == "xrGetMarkerNumberML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetMarkerNumberML);
        }
        if (func_name == "xrGetMarkerStringML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetMarkerStringML);
        }
        if (func_name == "xrCreateMarkerSpaceML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateMarkerSpaceML);
        }

        // ---- XR_ML_localization_map extension commands
        if (func_name == "xrEnableLocalizationEventsML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnableLocalizationEventsML);
        }
        if (func_name == "xrQueryLocalizationMapsML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrQueryLocalizationMapsML);
        }
        if (func_name == "xrRequestMapLocalizationML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrRequestMapLocalizationML);
        }
        if (func_name == "xrImportLocalizationMapML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrImportLocalizationMapML);
        }
        if (func_name == "xrCreateExportedLocalizationMapML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateExportedLocalizationMapML);
        }
        if (func_name == "xrDestroyExportedLocalizationMapML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyExportedLocalizationMapML);
        }
        if (func_name == "xrGetExportedLocalizationMapDataML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetExportedLocalizationMapDataML);
        }

        // ---- XR_ML_spatial_anchors extension commands
        if (func_name == "xrCreateSpatialAnchorsAsyncML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpatialAnchorsAsyncML);
        }
        if (func_name == "xrCreateSpatialAnchorsCompleteML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpatialAnchorsCompleteML);
        }
        if (func_name == "xrGetSpatialAnchorStateML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSpatialAnchorStateML);
        }

        // ---- XR_ML_spatial_anchors_storage extension commands
        if (func_name == "xrCreateSpatialAnchorsStorageML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpatialAnchorsStorageML);
        }
        if (func_name == "xrDestroySpatialAnchorsStorageML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroySpatialAnchorsStorageML);
        }
        if (func_name == "xrQuerySpatialAnchorsAsyncML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrQuerySpatialAnchorsAsyncML);
        }
        if (func_name == "xrQuerySpatialAnchorsCompleteML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrQuerySpatialAnchorsCompleteML);
        }
        if (func_name == "xrPublishSpatialAnchorsAsyncML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrPublishSpatialAnchorsAsyncML);
        }
        if (func_name == "xrPublishSpatialAnchorsCompleteML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrPublishSpatialAnchorsCompleteML);
        }
        if (func_name == "xrDeleteSpatialAnchorsAsyncML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDeleteSpatialAnchorsAsyncML);
        }
        if (func_name == "xrDeleteSpatialAnchorsCompleteML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDeleteSpatialAnchorsCompleteML);
        }
        if (func_name == "xrUpdateSpatialAnchorsExpirationAsyncML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrUpdateSpatialAnchorsExpirationAsyncML);
        }
        if (func_name == "xrUpdateSpatialAnchorsExpirationCompleteML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrUpdateSpatialAnchorsExpirationCompleteML);
        }

        // ---- XR_MSFT_spatial_anchor_persistence extension commands
        if (func_name == "xrCreateSpatialAnchorStoreConnectionMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpatialAnchorStoreConnectionMSFT);
        }
        if (func_name == "xrDestroySpatialAnchorStoreConnectionMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroySpatialAnchorStoreConnectionMSFT);
        }
        if (func_name == "xrPersistSpatialAnchorMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrPersistSpatialAnchorMSFT);
        }
        if (func_name == "xrEnumeratePersistedSpatialAnchorNamesMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumeratePersistedSpatialAnchorNamesMSFT);
        }
        if (func_name == "xrCreateSpatialAnchorFromPersistedNameMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpatialAnchorFromPersistedNameMSFT);
        }
        if (func_name == "xrUnpersistSpatialAnchorMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrUnpersistSpatialAnchorMSFT);
        }
        if (func_name == "xrClearSpatialAnchorStoreMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrClearSpatialAnchorStoreMSFT);
        }

        // ---- XR_MSFT_scene_marker extension commands
        if (func_name == "xrGetSceneMarkerRawDataMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSceneMarkerRawDataMSFT);
        }
        if (func_name == "xrGetSceneMarkerDecodedStringMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSceneMarkerDecodedStringMSFT);
        }

        // ---- XR_FB_spatial_entity_query extension commands
        if (func_name == "xrQuerySpacesFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrQuerySpacesFB);
        }
        if (func_name == "xrRetrieveSpaceQueryResultsFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrRetrieveSpaceQueryResultsFB);
        }

        // ---- XR_FB_spatial_entity_storage extension commands
        if (func_name == "xrSaveSpaceFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSaveSpaceFB);
        }
        if (func_name == "xrEraseSpaceFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEraseSpaceFB);
        }

        // ---- XR_OCULUS_audio_device_guid extension commands
#if defined(XR_USE_PLATFORM_WIN32)
        if (func_name == "xrGetAudioOutputDeviceGuidOculus") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetAudioOutputDeviceGuidOculus);
        }
#endif // defined(XR_USE_PLATFORM_WIN32)
#if defined(XR_USE_PLATFORM_WIN32)
        if (func_name == "xrGetAudioInputDeviceGuidOculus") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetAudioInputDeviceGuidOculus);
        }
#endif // defined(XR_USE_PLATFORM_WIN32)

        // ---- XR_FB_spatial_entity_sharing extension commands
        if (func_name == "xrShareSpacesFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrShareSpacesFB);
        }

        // ---- XR_FB_scene extension commands
        if (func_name == "xrGetSpaceBoundingBox2DFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSpaceBoundingBox2DFB);
        }
        if (func_name == "xrGetSpaceBoundingBox3DFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSpaceBoundingBox3DFB);
        }
        if (func_name == "xrGetSpaceSemanticLabelsFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSpaceSemanticLabelsFB);
        }
        if (func_name == "xrGetSpaceBoundary2DFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSpaceBoundary2DFB);
        }
        if (func_name == "xrGetSpaceRoomLayoutFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSpaceRoomLayoutFB);
        }

        // ---- XR_ALMALENCE_digital_lens_control extension commands
        if (func_name == "xrSetDigitalLensControlALMALENCE") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetDigitalLensControlALMALENCE);
        }

        // ---- XR_FB_scene_capture extension commands
        if (func_name == "xrRequestSceneCaptureFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrRequestSceneCaptureFB);
        }

        // ---- XR_FB_spatial_entity_container extension commands
        if (func_name == "xrGetSpaceContainerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSpaceContainerFB);
        }

        // ---- XR_META_foveation_eye_tracked extension commands
        if (func_name == "xrGetFoveationEyeTrackedStateMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetFoveationEyeTrackedStateMETA);
        }

        // ---- XR_FB_face_tracking extension commands
        if (func_name == "xrCreateFaceTrackerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateFaceTrackerFB);
        }
        if (func_name == "xrDestroyFaceTrackerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyFaceTrackerFB);
        }
        if (func_name == "xrGetFaceExpressionWeightsFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetFaceExpressionWeightsFB);
        }

        // ---- XR_FB_eye_tracking_social extension commands
        if (func_name == "xrCreateEyeTrackerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateEyeTrackerFB);
        }
        if (func_name == "xrDestroyEyeTrackerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyEyeTrackerFB);
        }
        if (func_name == "xrGetEyeGazesFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetEyeGazesFB);
        }

        // ---- XR_FB_passthrough_keyboard_hands extension commands
        if (func_name == "xrPassthroughLayerSetKeyboardHandsIntensityFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrPassthroughLayerSetKeyboardHandsIntensityFB);
        }

        // ---- XR_FB_haptic_pcm extension commands
        if (func_name == "xrGetDeviceSampleRateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetDeviceSampleRateFB);
        }

        // ---- XR_META_passthrough_preferences extension commands
        if (func_name == "xrGetPassthroughPreferencesMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetPassthroughPreferencesMETA);
        }

        // ---- XR_META_virtual_keyboard extension commands
        if (func_name == "xrCreateVirtualKeyboardMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateVirtualKeyboardMETA);
        }
        if (func_name == "xrDestroyVirtualKeyboardMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyVirtualKeyboardMETA);
        }
        if (func_name == "xrCreateVirtualKeyboardSpaceMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateVirtualKeyboardSpaceMETA);
        }
        if (func_name == "xrSuggestVirtualKeyboardLocationMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSuggestVirtualKeyboardLocationMETA);
        }
        if (func_name == "xrGetVirtualKeyboardScaleMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetVirtualKeyboardScaleMETA);
        }
        if (func_name == "xrSetVirtualKeyboardModelVisibilityMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetVirtualKeyboardModelVisibilityMETA);
        }
        if (func_name == "xrGetVirtualKeyboardModelAnimationStatesMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetVirtualKeyboardModelAnimationStatesMETA);
        }
        if (func_name == "xrGetVirtualKeyboardDirtyTexturesMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetVirtualKeyboardDirtyTexturesMETA);
        }
        if (func_name == "xrGetVirtualKeyboardTextureDataMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetVirtualKeyboardTextureDataMETA);
        }
        if (func_name == "xrSendVirtualKeyboardInputMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSendVirtualKeyboardInputMETA);
        }
        if (func_name == "xrChangeVirtualKeyboardTextContextMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrChangeVirtualKeyboardTextContextMETA);
        }

        // ---- XR_OCULUS_external_camera extension commands
        if (func_name == "xrEnumerateExternalCamerasOCULUS") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateExternalCamerasOCULUS);
        }

        // ---- XR_META_performance_metrics extension commands
        if (func_name == "xrEnumeratePerformanceMetricsCounterPathsMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumeratePerformanceMetricsCounterPathsMETA);
        }
        if (func_name == "xrSetPerformanceMetricsStateMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetPerformanceMetricsStateMETA);
        }
        if (func_name == "xrGetPerformanceMetricsStateMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetPerformanceMetricsStateMETA);
        }
        if (func_name == "xrQueryPerformanceMetricsCounterMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrQueryPerformanceMetricsCounterMETA);
        }

        // ---- XR_FB_spatial_entity_storage_batch extension commands
        if (func_name == "xrSaveSpaceListFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSaveSpaceListFB);
        }

        // ---- XR_FB_spatial_entity_user extension commands
        if (func_name == "xrCreateSpaceUserFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpaceUserFB);
        }
        if (func_name == "xrGetSpaceUserIdFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSpaceUserIdFB);
        }
        if (func_name == "xrDestroySpaceUserFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroySpaceUserFB);
        }

        // ---- XR_META_recommended_layer_resolution extension commands
        if (func_name == "xrGetRecommendedLayerResolutionMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetRecommendedLayerResolutionMETA);
        }

        // ---- XR_META_passthrough_color_lut extension commands
        if (func_name == "xrCreatePassthroughColorLutMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreatePassthroughColorLutMETA);
        }
        if (func_name == "xrDestroyPassthroughColorLutMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyPassthroughColorLutMETA);
        }
        if (func_name == "xrUpdatePassthroughColorLutMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrUpdatePassthroughColorLutMETA);
        }

        // ---- XR_META_spatial_entity_mesh extension commands
        if (func_name == "xrGetSpaceTriangleMeshMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSpaceTriangleMeshMETA);
        }

        // ---- XR_FB_face_tracking2 extension commands
        if (func_name == "xrCreateFaceTracker2FB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateFaceTracker2FB);
        }
        if (func_name == "xrDestroyFaceTracker2FB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyFaceTracker2FB);
        }
        if (func_name == "xrGetFaceExpressionWeights2FB") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetFaceExpressionWeights2FB);
        }

        // ---- XR_META_spatial_entity_sharing extension commands
        if (func_name == "xrShareSpacesMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrShareSpacesMETA);
        }

        // ---- XR_META_environment_depth extension commands
        if (func_name == "xrCreateEnvironmentDepthProviderMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateEnvironmentDepthProviderMETA);
        }
        if (func_name == "xrDestroyEnvironmentDepthProviderMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyEnvironmentDepthProviderMETA);
        }
        if (func_name == "xrStartEnvironmentDepthProviderMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrStartEnvironmentDepthProviderMETA);
        }
        if (func_name == "xrStopEnvironmentDepthProviderMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrStopEnvironmentDepthProviderMETA);
        }
        if (func_name == "xrCreateEnvironmentDepthSwapchainMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateEnvironmentDepthSwapchainMETA);
        }
        if (func_name == "xrDestroyEnvironmentDepthSwapchainMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyEnvironmentDepthSwapchainMETA);
        }
        if (func_name == "xrEnumerateEnvironmentDepthSwapchainImagesMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateEnvironmentDepthSwapchainImagesMETA);
        }
        if (func_name == "xrGetEnvironmentDepthSwapchainStateMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetEnvironmentDepthSwapchainStateMETA);
        }
        if (func_name == "xrAcquireEnvironmentDepthImageMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrAcquireEnvironmentDepthImageMETA);
        }
        if (func_name == "xrSetEnvironmentDepthHandRemovalMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetEnvironmentDepthHandRemovalMETA);
        }

        // ---- XR_QCOM_tracking_optimization_settings extension commands
        if (func_name == "xrSetTrackingOptimizationSettingsHintQCOM") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetTrackingOptimizationSettingsHintQCOM);
        }

        // ---- XR_HTC_passthrough extension commands
        if (func_name == "xrCreatePassthroughHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreatePassthroughHTC);
        }
        if (func_name == "xrDestroyPassthroughHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyPassthroughHTC);
        }

        // ---- XR_HTC_foveation extension commands
        if (func_name == "xrApplyFoveationHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrApplyFoveationHTC);
        }

        // ---- XR_HTC_anchor extension commands
        if (func_name == "xrCreateSpatialAnchorHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpatialAnchorHTC);
        }
        if (func_name == "xrGetSpatialAnchorNameHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSpatialAnchorNameHTC);
        }

        // ---- XR_HTC_body_tracking extension commands
        if (func_name == "xrCreateBodyTrackerHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateBodyTrackerHTC);
        }
        if (func_name == "xrDestroyBodyTrackerHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyBodyTrackerHTC);
        }
        if (func_name == "xrLocateBodyJointsHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrLocateBodyJointsHTC);
        }
        if (func_name == "xrGetBodySkeletonHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetBodySkeletonHTC);
        }

        // ---- XR_MNDX_force_feedback_curl extension commands
        if (func_name == "xrApplyForceFeedbackCurlMNDX") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrApplyForceFeedbackCurlMNDX);
        }

        // ---- XR_BD_body_tracking extension commands
        if (func_name == "xrCreateBodyTrackerBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateBodyTrackerBD);
        }
        if (func_name == "xrDestroyBodyTrackerBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyBodyTrackerBD);
        }
        if (func_name == "xrLocateBodyJointsBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrLocateBodyJointsBD);
        }

        // ---- XR_BD_spatial_sensing extension commands
        if (func_name == "xrEnumerateSpatialEntityComponentTypesBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnumerateSpatialEntityComponentTypesBD);
        }
        if (func_name == "xrGetSpatialEntityUuidBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSpatialEntityUuidBD);
        }
        if (func_name == "xrGetSpatialEntityComponentDataBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSpatialEntityComponentDataBD);
        }
        if (func_name == "xrCreateSenseDataProviderBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSenseDataProviderBD);
        }
        if (func_name == "xrStartSenseDataProviderAsyncBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrStartSenseDataProviderAsyncBD);
        }
        if (func_name == "xrStartSenseDataProviderCompleteBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrStartSenseDataProviderCompleteBD);
        }
        if (func_name == "xrGetSenseDataProviderStateBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetSenseDataProviderStateBD);
        }
        if (func_name == "xrQuerySenseDataAsyncBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrQuerySenseDataAsyncBD);
        }
        if (func_name == "xrQuerySenseDataCompleteBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrQuerySenseDataCompleteBD);
        }
        if (func_name == "xrDestroySenseDataSnapshotBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroySenseDataSnapshotBD);
        }
        if (func_name == "xrGetQueriedSenseDataBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetQueriedSenseDataBD);
        }
        if (func_name == "xrStopSenseDataProviderBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrStopSenseDataProviderBD);
        }
        if (func_name == "xrDestroySenseDataProviderBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroySenseDataProviderBD);
        }
        if (func_name == "xrCreateSpatialEntityAnchorBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpatialEntityAnchorBD);
        }
        if (func_name == "xrDestroyAnchorBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyAnchorBD);
        }
        if (func_name == "xrGetAnchorUuidBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetAnchorUuidBD);
        }
        if (func_name == "xrCreateAnchorSpaceBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateAnchorSpaceBD);
        }

        // ---- XR_BD_spatial_anchor extension commands
        if (func_name == "xrCreateSpatialAnchorAsyncBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpatialAnchorAsyncBD);
        }
        if (func_name == "xrCreateSpatialAnchorCompleteBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateSpatialAnchorCompleteBD);
        }
        if (func_name == "xrPersistSpatialAnchorAsyncBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrPersistSpatialAnchorAsyncBD);
        }
        if (func_name == "xrPersistSpatialAnchorCompleteBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrPersistSpatialAnchorCompleteBD);
        }
        if (func_name == "xrUnpersistSpatialAnchorAsyncBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrUnpersistSpatialAnchorAsyncBD);
        }
        if (func_name == "xrUnpersistSpatialAnchorCompleteBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrUnpersistSpatialAnchorCompleteBD);
        }

        // ---- XR_BD_spatial_anchor_sharing extension commands
        if (func_name == "xrShareSpatialAnchorAsyncBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrShareSpatialAnchorAsyncBD);
        }
        if (func_name == "xrShareSpatialAnchorCompleteBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrShareSpatialAnchorCompleteBD);
        }
        if (func_name == "xrDownloadSharedSpatialAnchorAsyncBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDownloadSharedSpatialAnchorAsyncBD);
        }
        if (func_name == "xrDownloadSharedSpatialAnchorCompleteBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDownloadSharedSpatialAnchorCompleteBD);
        }

        // ---- XR_BD_spatial_scene extension commands
        if (func_name == "xrCaptureSceneAsyncBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCaptureSceneAsyncBD);
        }
        if (func_name == "xrCaptureSceneCompleteBD") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCaptureSceneCompleteBD);
        }

        // ---- XR_EXT_plane_detection extension commands
        if (func_name == "xrCreatePlaneDetectorEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreatePlaneDetectorEXT);
        }
        if (func_name == "xrDestroyPlaneDetectorEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyPlaneDetectorEXT);
        }
        if (func_name == "xrBeginPlaneDetectionEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrBeginPlaneDetectionEXT);
        }
        if (func_name == "xrGetPlaneDetectionStateEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetPlaneDetectionStateEXT);
        }
        if (func_name == "xrGetPlaneDetectionsEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetPlaneDetectionsEXT);
        }
        if (func_name == "xrGetPlanePolygonBufferEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetPlanePolygonBufferEXT);
        }

        // ---- XR_EXT_future extension commands
        if (func_name == "xrPollFutureEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrPollFutureEXT);
        }
        if (func_name == "xrCancelFutureEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCancelFutureEXT);
        }

        // ---- XR_ML_user_calibration extension commands
        if (func_name == "xrEnableUserCalibrationEventsML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrEnableUserCalibrationEventsML);
        }

        // ---- XR_ML_system_notifications extension commands
        if (func_name == "xrSetSystemNotificationsML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrSetSystemNotificationsML);
        }

        // ---- XR_ML_world_mesh_detection extension commands
        if (func_name == "xrCreateWorldMeshDetectorML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateWorldMeshDetectorML);
        }
        if (func_name == "xrDestroyWorldMeshDetectorML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyWorldMeshDetectorML);
        }
        if (func_name == "xrRequestWorldMeshStateAsyncML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrRequestWorldMeshStateAsyncML);
        }
        if (func_name == "xrRequestWorldMeshStateCompleteML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrRequestWorldMeshStateCompleteML);
        }
        if (func_name == "xrGetWorldMeshBufferRecommendSizeML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetWorldMeshBufferRecommendSizeML);
        }
        if (func_name == "xrAllocateWorldMeshBufferML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrAllocateWorldMeshBufferML);
        }
        if (func_name == "xrFreeWorldMeshBufferML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrFreeWorldMeshBufferML);
        }
        if (func_name == "xrRequestWorldMeshAsyncML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrRequestWorldMeshAsyncML);
        }
        if (func_name == "xrRequestWorldMeshCompleteML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrRequestWorldMeshCompleteML);
        }

        // ---- XR_ML_facial_expression extension commands
        if (func_name == "xrCreateFacialExpressionClientML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrCreateFacialExpressionClientML);
        }
        if (func_name == "xrDestroyFacialExpressionClientML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrDestroyFacialExpressionClientML);
        }
        if (func_name == "xrGetFacialExpressionBlendShapePropertiesML") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrGetFacialExpressionBlendShapePropertiesML);
        }

        // ---- XR_META_colocation_discovery extension commands
        if (func_name == "xrStartColocationDiscoveryMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrStartColocationDiscoveryMETA);
        }
        if (func_name == "xrStopColocationDiscoveryMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrStopColocationDiscoveryMETA);
        }
        if (func_name == "xrStartColocationAdvertisementMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrStartColocationAdvertisementMETA);
        }
        if (func_name == "xrStopColocationAdvertisementMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(ApiDumpLayerXrStopColocationAdvertisementMETA);
        }
        return nullptr;
    }

